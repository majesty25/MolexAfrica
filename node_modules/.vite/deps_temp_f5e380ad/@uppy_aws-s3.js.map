{
  "version": 3,
  "sources": ["../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../@uppy/utils/lib/hasProperty.js", "../../@uppy/utils/lib/ErrorWithCause.js", "../../@uppy/utils/lib/NetworkError.js", "../../@uppy/utils/lib/fetchWithNetworkError.js", "../../@uppy/utils/lib/getSocketHost.js", "../../@uppy/utils/lib/UserFacingApiError.js", "../../p-retry/index.js", "../../is-network-error/index.js", "../../@uppy/companion-client/package.json", "../../@uppy/companion-client/lib/AuthError.js", "../../@uppy/companion-client/lib/RequestClient.js", "../../@uppy/companion-client/lib/tokenStorage.js", "../../@uppy/core/lib/EventManager.js", "../../@uppy/utils/lib/AbortController.js", "../../@uppy/utils/lib/fileFilters.js", "../../@uppy/utils/lib/getAllowedMetaFields.js", "../../@uppy/utils/lib/RateLimitedQueue.js", "../../@uppy/aws-s3/package.json", "../../@uppy/aws-s3/lib/createSignedURL.js", "../../@uppy/aws-s3/lib/MultipartUploader.js", "../../@uppy/aws-s3/lib/utils.js", "../../@uppy/aws-s3/lib/HTTPCommunicationQueue.js", "../../@uppy/aws-s3/lib/index.js"],
  "sourcesContent": ["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "export default function hasProperty(object, key) {\n    return Object.hasOwn(object, key);\n}\n", "import hasProperty from './hasProperty.js';\nclass ErrorWithCause extends Error {\n    isNetworkError;\n    cause;\n    constructor(message, options) {\n        super(message);\n        this.cause = options?.cause;\n        if (this.cause && hasProperty(this.cause, 'isNetworkError')) {\n            this.isNetworkError = this.cause.isNetworkError;\n        }\n        else {\n            this.isNetworkError = false;\n        }\n    }\n}\nexport default ErrorWithCause;\n", "class NetworkError extends Error {\n    cause;\n    isNetworkError;\n    request;\n    constructor(error, xhr = null) {\n        super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);\n        this.cause = error;\n        this.isNetworkError = true;\n        this.request = xhr;\n    }\n}\nexport default NetworkError;\n", "import NetworkError from './NetworkError.js';\n/**\n * Wrapper around window.fetch that throws a NetworkError when appropriate\n */\nexport default function fetchWithNetworkError(...options) {\n    return fetch(...options).catch((err) => {\n        if (err.name === 'AbortError') {\n            throw err;\n        }\n        else {\n            throw new NetworkError(err);\n        }\n    });\n}\n", "export default function getSocketHost(url) {\n    // get the host domain\n    const regex = /^(?:https?:\\/\\/|\\/\\/)?(?:[^@\\n]+@)?([^\\n]+)/i;\n    const host = regex.exec(url)?.[1];\n    const socketProtocol = /^http:\\/\\//i.test(url) ? 'ws' : 'wss';\n    return `${socketProtocol}://${host}`;\n}\n", "class UserFacingApiError extends Error {\n    name = 'UserFacingApiError';\n}\nexport default UserFacingApiError;\n", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n", "{\n  \"name\": \"@uppy/companion-client\",\n  \"description\": \"Client library for communication with Companion. Intended for use in Uppy plugins.\",\n  \"version\": \"4.5.2\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"uppy\",\n    \"uppy-plugin\",\n    \"companion\",\n    \"provider\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"dependencies\": {\n    \"@uppy/utils\": \"^6.2.2\",\n    \"namespace-emitter\": \"^2.0.1\",\n    \"p-retry\": \"^6.1.0\"\n  },\n  \"devDependencies\": {\n    \"jsdom\": \"^26.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^4.5.2\"\n  }\n}", "class AuthError extends Error {\n    isAuthError;\n    constructor() {\n        super('Authorization required');\n        this.name = 'AuthError';\n        // we use a property because of instanceof is unsafe:\n        // https://github.com/transloadit/uppy/pull/4619#discussion_r1406225982\n        this.isAuthError = true;\n    }\n}\nexport default AuthError;\n", "import ErrorWithCause from '@uppy/utils/lib/ErrorWithCause';\nimport fetchWithNetworkError from '@uppy/utils/lib/fetchWithNetworkError';\nimport getSocketHost from '@uppy/utils/lib/getSocketHost';\nimport UserFacingApiError from '@uppy/utils/lib/UserFacingApiError';\nimport pRetry, { AbortError } from 'p-retry';\nimport packageJson from '../package.json' with { type: 'json' };\nimport AuthError from './AuthError.js';\n// Remove the trailing slash so we can always safely append /xyz.\nfunction stripSlash(url) {\n    return url.replace(/\\/$/, '');\n}\nconst retryCount = 10; // set to a low number, like 2 to test manual user retries\nconst socketActivityTimeoutMs = 5 * 60 * 1000; // set to a low number like 10000 to test this\nexport const authErrorStatusCode = 401;\nclass HttpError extends Error {\n    statusCode;\n    constructor({ statusCode, message, }) {\n        super(message);\n        this.name = 'HttpError';\n        this.statusCode = statusCode;\n    }\n}\nasync function handleJSONResponse(res) {\n    if (res.status === authErrorStatusCode) {\n        throw new AuthError();\n    }\n    if (res.ok) {\n        return res.json();\n    }\n    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;\n    let errData;\n    try {\n        errData = await res.json();\n        if (errData.message)\n            errMsg = `${errMsg} message: ${errData.message}`;\n        if (errData.requestId)\n            errMsg = `${errMsg} request-Id: ${errData.requestId}`;\n    }\n    catch (cause) {\n        // if the response contains invalid JSON, let's ignore the error data\n        throw new Error(errMsg, { cause });\n    }\n    if (res.status >= 400 && res.status <= 499 && errData.message) {\n        throw new UserFacingApiError(errData.message);\n    }\n    throw new HttpError({ statusCode: res.status, message: errMsg });\n}\nfunction emitSocketProgress(uploader, progressData, file) {\n    const { progress, bytesUploaded, bytesTotal } = progressData;\n    if (progress) {\n        uploader.uppy.log(`Upload progress: ${progress}`);\n        uploader.uppy.emit('upload-progress', file, {\n            uploadStarted: file.progress.uploadStarted ?? 0,\n            bytesUploaded,\n            bytesTotal,\n        });\n    }\n}\nexport default class RequestClient {\n    static VERSION = packageJson.version;\n    #companionHeaders;\n    uppy;\n    opts;\n    constructor(uppy, opts) {\n        this.uppy = uppy;\n        this.opts = opts;\n        this.onReceiveResponse = this.onReceiveResponse.bind(this);\n        this.#companionHeaders = opts.companionHeaders;\n    }\n    setCompanionHeaders(headers) {\n        this.#companionHeaders = headers;\n    }\n    [Symbol.for('uppy test: getCompanionHeaders')]() {\n        return this.#companionHeaders;\n    }\n    get hostname() {\n        const { companion } = this.uppy.getState();\n        const host = this.opts.companionUrl;\n        return stripSlash(companion?.[host] ? companion[host] : host);\n    }\n    async headers(emptyBody = false) {\n        const defaultHeaders = {\n            Accept: 'application/json',\n            ...(emptyBody\n                ? undefined\n                : {\n                    // Passing those headers on requests with no data forces browsers to first make a preflight request.\n                    'Content-Type': 'application/json',\n                }),\n        };\n        return {\n            ...defaultHeaders,\n            ...this.#companionHeaders,\n        };\n    }\n    onReceiveResponse(res) {\n        const { headers } = res;\n        const state = this.uppy.getState();\n        const companion = state.companion || {};\n        const host = this.opts.companionUrl;\n        // Store the self-identified domain name for the Companion instance we just hit.\n        if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {\n            this.uppy.setState({\n                companion: { ...companion, [host]: headers.get('i-am') },\n            });\n        }\n    }\n    #getUrl(url) {\n        if (/^(https?:|)\\/\\//.test(url)) {\n            return url;\n        }\n        return `${this.hostname}/${url}`;\n    }\n    async request({ path, method = 'GET', data, skipPostResponse, signal, }) {\n        try {\n            const headers = await this.headers(!data);\n            const response = await fetchWithNetworkError(this.#getUrl(path), {\n                method,\n                signal,\n                headers,\n                credentials: this.opts.companionCookiesRule || 'same-origin',\n                body: data ? JSON.stringify(data) : null,\n            });\n            if (!skipPostResponse)\n                this.onReceiveResponse(response);\n            return await handleJSONResponse(response);\n        }\n        catch (err) {\n            // pass these through\n            if (err.isAuthError ||\n                err.name === 'UserFacingApiError' ||\n                err.name === 'AbortError')\n                throw err;\n            throw new ErrorWithCause(`Could not ${method} ${this.#getUrl(path)}`, {\n                cause: err,\n            });\n        }\n    }\n    async get(path, options) {\n        return this.request({ ...options, path });\n    }\n    async post(path, data, options) {\n        return this.request({ ...options, path, method: 'POST', data });\n    }\n    async delete(path, data, options) {\n        return this.request({ ...options, path, method: 'DELETE', data });\n    }\n    /**\n     * Remote uploading consists of two steps:\n     * 1. #requestSocketToken which starts the download/upload in companion and returns a unique token for the upload.\n     * Then companion will halt the upload until:\n     * 2. #awaitRemoteFileUpload is called, which will open/ensure a websocket connection towards companion, with the\n     * previously generated token provided. It returns a promise that will resolve/reject once the file has finished\n     * uploading or is otherwise done (failed, canceled)\n     */\n    async uploadRemoteFile(file, reqBody, options) {\n        try {\n            const { signal, getQueue } = options || {};\n            return await pRetry(async () => {\n                // if we already have a serverToken, assume that we are resuming the existing server upload id\n                const existingServerToken = this.uppy.getFile(file.id)?.serverToken;\n                if (existingServerToken != null) {\n                    this.uppy.log(`Connecting to exiting websocket ${existingServerToken}`);\n                    return this.#awaitRemoteFileUpload({\n                        file,\n                        queue: getQueue(),\n                        signal,\n                    });\n                }\n                const queueRequestSocketToken = getQueue().wrapPromiseFunction(async (...args) => {\n                    try {\n                        return await this.#requestSocketToken(...args);\n                    }\n                    catch (outerErr) {\n                        // throwing AbortError will cause p-retry to stop retrying\n                        if (outerErr.isAuthError)\n                            throw new AbortError(outerErr);\n                        if (outerErr.cause == null)\n                            throw outerErr;\n                        const err = outerErr.cause;\n                        const isRetryableHttpError = () => [408, 409, 429, 418, 423].includes(err.statusCode) ||\n                            (err.statusCode >= 500 &&\n                                err.statusCode <= 599 &&\n                                ![501, 505].includes(err.statusCode));\n                        if (err.name === 'HttpError' && !isRetryableHttpError())\n                            throw new AbortError(err);\n                        // p-retry will retry most other errors,\n                        // but it will not retry TypeError (except network error TypeErrors)\n                        throw err;\n                    }\n                }, { priority: -1 });\n                const serverToken = await queueRequestSocketToken({\n                    file,\n                    postBody: reqBody,\n                    signal,\n                }).abortOn(signal);\n                if (!this.uppy.getFile(file.id))\n                    return undefined; // has file since been removed?\n                this.uppy.setFileState(file.id, { serverToken });\n                return this.#awaitRemoteFileUpload({\n                    file: this.uppy.getFile(file.id), // re-fetching file because it might have changed in the meantime\n                    queue: getQueue(),\n                    signal,\n                });\n            }, {\n                retries: retryCount,\n                signal,\n                onFailedAttempt: (err) => this.uppy.log(`Retrying upload due to: ${err.message}`, 'warning'),\n            });\n        }\n        catch (err) {\n            // this is a bit confusing, but note that an error with the `name` prop set to 'AbortError' (from AbortController)\n            // is not the same as `p-retry` `AbortError`\n            if (err.name === 'AbortError') {\n                // The file upload was aborted, it’s not an error\n                return undefined;\n            }\n            this.uppy.emit('upload-error', file, err);\n            throw err;\n        }\n    }\n    #requestSocketToken = async ({ file, postBody, signal, }) => {\n        if (file.remote?.url == null) {\n            throw new Error('Cannot connect to an undefined URL');\n        }\n        const res = await this.post(file.remote.url, {\n            ...file.remote.body,\n            ...postBody,\n        }, { signal });\n        return res.token;\n    };\n    /**\n     * This method will ensure a websocket for the specified file and returns a promise that resolves\n     * when the file has finished downloading, or rejects if it fails.\n     * It will retry if the websocket gets disconnected\n     */\n    async #awaitRemoteFileUpload({ file, queue, signal, }) {\n        let removeEventHandlers;\n        const { capabilities } = this.uppy.getState();\n        try {\n            return await new Promise((resolve, reject) => {\n                const token = file.serverToken;\n                const host = getSocketHost(file.remote.companionUrl);\n                let socket;\n                let socketAbortController;\n                let activityTimeout;\n                let { isPaused } = file;\n                const socketSend = (action, payload) => {\n                    if (socket == null || socket.readyState !== socket.OPEN) {\n                        this.uppy.log(`Cannot send \"${action}\" to socket ${file.id} because the socket state was ${String(socket?.readyState)}`, 'warning');\n                        return;\n                    }\n                    socket.send(JSON.stringify({\n                        action,\n                        payload: payload ?? {},\n                    }));\n                };\n                function sendState() {\n                    if (!capabilities.resumableUploads)\n                        return;\n                    if (isPaused)\n                        socketSend('pause');\n                    else\n                        socketSend('resume');\n                }\n                const createWebsocket = async () => {\n                    if (socketAbortController)\n                        socketAbortController.abort();\n                    socketAbortController = new AbortController();\n                    const onFatalError = (err) => {\n                        // Remove the serverToken so that a new one will be created for the retry.\n                        this.uppy.setFileState(file.id, { serverToken: null });\n                        socketAbortController?.abort?.();\n                        reject(err);\n                    };\n                    // todo instead implement the ability for users to cancel / retry *currently uploading files* in the UI\n                    function resetActivityTimeout() {\n                        clearTimeout(activityTimeout);\n                        if (isPaused)\n                            return;\n                        activityTimeout = setTimeout(() => onFatalError(new Error('Timeout waiting for message from Companion socket')), socketActivityTimeoutMs);\n                    }\n                    try {\n                        await queue\n                            .wrapPromiseFunction(async () => {\n                            const reconnectWebsocket = async () => new Promise((_, rejectSocket) => {\n                                socket = new WebSocket(`${host}/api/${token}`);\n                                resetActivityTimeout();\n                                socket.addEventListener('close', () => {\n                                    socket = undefined;\n                                    rejectSocket(new Error('Socket closed unexpectedly'));\n                                });\n                                socket.addEventListener('error', (error) => {\n                                    this.uppy.log(`Companion socket error ${JSON.stringify(error)}, closing socket`, 'warning');\n                                    socket?.close(); // will 'close' event to be emitted\n                                });\n                                socket.addEventListener('open', () => {\n                                    sendState();\n                                });\n                                socket.addEventListener('message', (e) => {\n                                    resetActivityTimeout();\n                                    try {\n                                        const { action, payload } = JSON.parse(e.data);\n                                        switch (action) {\n                                            case 'progress': {\n                                                emitSocketProgress(this, payload, this.uppy.getFile(file.id));\n                                                break;\n                                            }\n                                            case 'success': {\n                                                // payload.response is sent from companion for xhr-upload (aka uploadMultipart in companion) and\n                                                // s3 multipart (aka uploadS3Multipart)\n                                                // but not for tus/transloadit (aka uploadTus)\n                                                // responseText is a string which may or may not be in JSON format\n                                                // this means that an upload destination of xhr or s3 multipart MUST respond with valid JSON\n                                                // to companion, or the JSON.parse will crash\n                                                const text = payload.response?.responseText;\n                                                this.uppy.emit('upload-success', this.uppy.getFile(file.id), {\n                                                    uploadURL: payload.url,\n                                                    status: payload.response?.status ?? 200,\n                                                    body: text\n                                                        ? JSON.parse(text)\n                                                        : undefined,\n                                                });\n                                                socketAbortController?.abort?.();\n                                                resolve();\n                                                break;\n                                            }\n                                            case 'error': {\n                                                const { message } = payload.error;\n                                                throw Object.assign(new Error(message), {\n                                                    cause: payload.error,\n                                                });\n                                            }\n                                            default:\n                                                this.uppy.log(`Companion socket unknown action ${action}`, 'warning');\n                                        }\n                                    }\n                                    catch (err) {\n                                        onFatalError(err);\n                                    }\n                                });\n                                const closeSocket = () => {\n                                    this.uppy.log(`Closing socket ${file.id}`);\n                                    clearTimeout(activityTimeout);\n                                    if (socket)\n                                        socket.close();\n                                    socket = undefined;\n                                };\n                                socketAbortController.signal.addEventListener('abort', () => {\n                                    closeSocket();\n                                });\n                            });\n                            await pRetry(reconnectWebsocket, {\n                                retries: retryCount,\n                                signal: socketAbortController.signal,\n                                onFailedAttempt: () => {\n                                    if (socketAbortController.signal.aborted)\n                                        return; // don't log in this case\n                                    this.uppy.log(`Retrying websocket ${file.id}`);\n                                },\n                            });\n                        })()\n                            .abortOn(socketAbortController.signal);\n                    }\n                    catch (err) {\n                        if (socketAbortController.signal.aborted)\n                            return;\n                        onFatalError(err);\n                    }\n                };\n                const pause = (newPausedState) => {\n                    if (!capabilities.resumableUploads)\n                        return;\n                    isPaused = newPausedState;\n                    if (socket)\n                        sendState();\n                };\n                const onFileRemove = (targetFile) => {\n                    if (!capabilities.individualCancellation)\n                        return;\n                    if (targetFile.id !== file.id)\n                        return;\n                    socketSend('cancel');\n                    socketAbortController?.abort?.();\n                    this.uppy.log(`upload ${file.id} was removed`);\n                    resolve();\n                };\n                const onCancelAll = () => {\n                    socketSend('cancel');\n                    socketAbortController?.abort?.();\n                    this.uppy.log(`upload ${file.id} was canceled`);\n                    resolve();\n                };\n                const onFilePausedChange = (targetFile, newPausedState) => {\n                    if (targetFile?.id !== file.id)\n                        return;\n                    pause(newPausedState);\n                };\n                const onPauseAll = () => pause(true);\n                const onResumeAll = () => pause(false);\n                this.uppy.on('file-removed', onFileRemove);\n                this.uppy.on('cancel-all', onCancelAll);\n                this.uppy.on('upload-pause', onFilePausedChange);\n                this.uppy.on('pause-all', onPauseAll);\n                this.uppy.on('resume-all', onResumeAll);\n                removeEventHandlers = () => {\n                    this.uppy.off('file-removed', onFileRemove);\n                    this.uppy.off('cancel-all', onCancelAll);\n                    this.uppy.off('upload-pause', onFilePausedChange);\n                    this.uppy.off('pause-all', onPauseAll);\n                    this.uppy.off('resume-all', onResumeAll);\n                };\n                signal.addEventListener('abort', () => {\n                    socketAbortController?.abort();\n                });\n                createWebsocket();\n            });\n        }\n        finally {\n            // @ts-expect-error used before defined\n            removeEventHandlers?.();\n        }\n    }\n}\n", "/**\n * This module serves as an Async wrapper for LocalStorage\n * Why? Because the Provider API `storage` option allows an async storage\n */\nexport async function setItem(key, value) {\n    localStorage.setItem(key, value);\n}\nexport async function getItem(key) {\n    return localStorage.getItem(key);\n}\nexport async function removeItem(key) {\n    localStorage.removeItem(key);\n}\n", "/**\n * Create a wrapper around an event emitter with a `remove` method to remove\n * all events that were added using the wrapped emitter.\n */\nexport default class EventManager {\n    #uppy;\n    #events = [];\n    constructor(uppy) {\n        this.#uppy = uppy;\n    }\n    on(event, fn) {\n        this.#events.push([event, fn]);\n        return this.#uppy.on(event, fn);\n    }\n    remove() {\n        for (const [event, fn] of this.#events.splice(0)) {\n            this.#uppy.off(event, fn);\n        }\n    }\n    onFilePause(fileID, cb) {\n        this.on('upload-pause', (file, isPaused) => {\n            if (fileID === file?.id) {\n                cb(isPaused);\n            }\n        });\n    }\n    onFileRemove(fileID, cb) {\n        this.on('file-removed', (file) => {\n            if (fileID === file.id)\n                cb(file.id);\n        });\n    }\n    onPause(fileID, cb) {\n        this.on('upload-pause', (file, isPaused) => {\n            if (fileID === file?.id) {\n                // const isPaused = this.#uppy.pauseResume(fileID)\n                cb(isPaused);\n            }\n        });\n    }\n    onRetry(fileID, cb) {\n        this.on('upload-retry', (file) => {\n            if (fileID === file?.id) {\n                cb();\n            }\n        });\n    }\n    onRetryAll(fileID, cb) {\n        this.on('retry-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n    onPauseAll(fileID, cb) {\n        this.on('pause-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n    onCancelAll(fileID, eventHandler) {\n        this.on('cancel-all', (...args) => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            eventHandler(...args);\n        });\n    }\n    onResumeAll(fileID, cb) {\n        this.on('resume-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n}\n", "import hasProperty from './hasProperty.js';\n/**\n * Little AbortController proxy module so we can swap out the implementation easily later.\n */\nexport const { AbortController } = globalThis;\nexport const { AbortSignal } = globalThis;\nexport const createAbortError = (message = 'Aborted', options) => {\n    const err = new DOMException(message, 'AbortError');\n    if (options != null && hasProperty(options, 'cause')) {\n        Object.defineProperty(err, 'cause', {\n            // @ts-expect-error TS is drunk\n            __proto__: null,\n            configurable: true,\n            writable: true,\n            value: options.cause,\n        });\n    }\n    return err;\n};\n", "export function filterNonFailedFiles(files) {\n    const hasError = (file) => 'error' in file && !!file.error;\n    return files.filter((file) => !hasError(file));\n}\n// Don't double-emit upload-started for Golden Retriever-restored files that were already started\nexport function filterFilesToEmitUploadStarted(files) {\n    return files.filter((file) => !file.progress?.uploadStarted || !file.isRestored);\n}\n", "export default function getAllowedMetaFields(fields, meta) {\n    if (fields === true) {\n        return Object.keys(meta);\n    }\n    if (Array.isArray(fields)) {\n        return fields;\n    }\n    return [];\n}\n", "function createCancelError(cause) {\n    return new Error('Cancelled', { cause });\n}\nfunction abortOn(signal) {\n    if (signal != null) {\n        const abortPromise = () => this.abort(signal.reason);\n        signal.addEventListener('abort', abortPromise, { once: true });\n        const removeAbortListener = () => {\n            signal.removeEventListener('abort', abortPromise);\n        };\n        this.then?.(removeAbortListener, removeAbortListener);\n    }\n    return this;\n}\nexport class RateLimitedQueue {\n    #activeRequests = 0;\n    #queuedHandlers = [];\n    #paused = false;\n    #pauseTimer;\n    #downLimit = 1;\n    #upperLimit;\n    #rateLimitingTimer;\n    limit;\n    constructor(limit) {\n        if (typeof limit !== 'number' || limit === 0) {\n            this.limit = Infinity;\n        }\n        else {\n            this.limit = limit;\n        }\n    }\n    #call(fn) {\n        this.#activeRequests += 1;\n        let done = false;\n        let cancelActive;\n        try {\n            cancelActive = fn();\n        }\n        catch (err) {\n            this.#activeRequests -= 1;\n            throw err;\n        }\n        return {\n            abort: (cause) => {\n                if (done)\n                    return;\n                done = true;\n                this.#activeRequests -= 1;\n                cancelActive?.(cause);\n                this.#queueNext();\n            },\n            done: () => {\n                if (done)\n                    return;\n                done = true;\n                this.#activeRequests -= 1;\n                this.#queueNext();\n            },\n        };\n    }\n    #queueNext() {\n        // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n        // one by one without continuously _advancing_ it (and starting new tasks before immediately\n        // aborting them)\n        queueMicrotask(() => this.#next());\n    }\n    #next() {\n        if (this.#paused || this.#activeRequests >= this.limit) {\n            return;\n        }\n        if (this.#queuedHandlers.length === 0) {\n            return;\n        }\n        // Dispatch the next request, and update the abort/done handlers\n        // so that cancelling it does the Right Thing (and doesn't just try\n        // to dequeue an already-running request).\n        const next = this.#queuedHandlers.shift();\n        if (next == null) {\n            throw new Error('Invariant violation: next is null');\n        }\n        const handler = this.#call(next.fn);\n        next.abort = handler.abort;\n        next.done = handler.done;\n    }\n    #queue(fn, options) {\n        const handler = {\n            fn,\n            priority: options?.priority || 0,\n            abort: () => {\n                this.#dequeue(handler);\n            },\n            done: () => {\n                throw new Error('Cannot mark a queued request as done: this indicates a bug');\n            },\n        };\n        const index = this.#queuedHandlers.findIndex((other) => {\n            return handler.priority > other.priority;\n        });\n        if (index === -1) {\n            this.#queuedHandlers.push(handler);\n        }\n        else {\n            this.#queuedHandlers.splice(index, 0, handler);\n        }\n        return handler;\n    }\n    #dequeue(handler) {\n        const index = this.#queuedHandlers.indexOf(handler);\n        if (index !== -1) {\n            this.#queuedHandlers.splice(index, 1);\n        }\n    }\n    run(fn, queueOptions) {\n        if (!this.#paused && this.#activeRequests < this.limit) {\n            return this.#call(fn);\n        }\n        return this.#queue(fn, queueOptions);\n    }\n    wrapSyncFunction(fn, queueOptions) {\n        return (...args) => {\n            const queuedRequest = this.run(() => {\n                fn(...args);\n                queueMicrotask(() => queuedRequest.done());\n                return () => { };\n            }, queueOptions);\n            return {\n                abortOn,\n                abort() {\n                    queuedRequest.abort();\n                },\n            };\n        };\n    }\n    wrapPromiseFunction(fn, queueOptions) {\n        return (...args) => {\n            let queuedRequest;\n            const outerPromise = new Promise((resolve, reject) => {\n                queuedRequest = this.run(() => {\n                    let cancelError;\n                    let innerPromise;\n                    try {\n                        innerPromise = Promise.resolve(fn(...args));\n                    }\n                    catch (err) {\n                        innerPromise = Promise.reject(err);\n                    }\n                    innerPromise.then((result) => {\n                        if (cancelError) {\n                            reject(cancelError);\n                        }\n                        else {\n                            queuedRequest.done();\n                            resolve(result);\n                        }\n                    }, (err) => {\n                        if (cancelError) {\n                            reject(cancelError);\n                        }\n                        else {\n                            queuedRequest.done();\n                            reject(err);\n                        }\n                    });\n                    return (cause) => {\n                        cancelError = createCancelError(cause);\n                    };\n                }, queueOptions);\n            });\n            outerPromise.abort = (cause) => {\n                queuedRequest.abort(cause);\n            };\n            outerPromise.abortOn = abortOn;\n            return outerPromise;\n        };\n    }\n    resume() {\n        this.#paused = false;\n        clearTimeout(this.#pauseTimer);\n        for (let i = 0; i < this.limit; i++) {\n            this.#queueNext();\n        }\n    }\n    #resume = () => this.resume();\n    /**\n     * Freezes the queue for a while or indefinitely.\n     *\n     * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n     *                                    If omitted, the queue won't resume automatically.\n     */\n    pause(duration = null) {\n        this.#paused = true;\n        clearTimeout(this.#pauseTimer);\n        if (duration != null) {\n            this.#pauseTimer = setTimeout(this.#resume, duration);\n        }\n    }\n    /**\n     * Pauses the queue for a duration, and lower the limit of concurrent requests\n     * when the queue resumes. When the queue resumes, it tries to progressively\n     * increase the limit in `this.#increaseLimit` until another call is made to\n     * `this.rateLimit`.\n     * Call this function when using the RateLimitedQueue for network requests and\n     * the remote server responds with 429 HTTP code.\n     *\n     * @param {number} duration in milliseconds.\n     */\n    rateLimit(duration) {\n        clearTimeout(this.#rateLimitingTimer);\n        this.pause(duration);\n        if (this.limit > 1 && Number.isFinite(this.limit)) {\n            this.#upperLimit = this.limit - 1;\n            this.limit = this.#downLimit;\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, duration);\n        }\n    }\n    #increaseLimit = () => {\n        if (this.#paused) {\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 0);\n            return;\n        }\n        this.#downLimit = this.limit;\n        this.limit = Math.ceil((this.#upperLimit + this.#downLimit) / 2);\n        for (let i = this.#downLimit; i <= this.limit; i++) {\n            this.#queueNext();\n        }\n        if (this.#upperLimit - this.#downLimit > 3) {\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 2000);\n        }\n        else {\n            this.#downLimit = Math.floor(this.#downLimit / 2);\n        }\n    };\n    get isPaused() {\n        return this.#paused;\n    }\n}\nexport const internalRateLimitedQueue = Symbol('__queue');\n", "{\n  \"name\": \"@uppy/aws-s3\",\n  \"description\": \"Upload to Amazon S3 with Uppy\",\n  \"version\": \"4.3.2\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"aws s3\",\n    \"amazon s3\",\n    \"s3\",\n    \"uppy\",\n    \"uppy-plugin\",\n    \"multipart\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"dependencies\": {\n    \"@uppy/companion-client\": \"^4.5.2\",\n    \"@uppy/utils\": \"^6.2.2\"\n  },\n  \"devDependencies\": {\n    \"@aws-sdk/client-s3\": \"^3.362.0\",\n    \"@aws-sdk/s3-request-presigner\": \"^3.362.0\",\n    \"@uppy/core\": \"^4.5.2\",\n    \"jsdom\": \"^26.1.0\",\n    \"nock\": \"^13.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\",\n    \"whatwg-fetch\": \"3.6.2\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^4.5.2\"\n  }\n}", "/**\n * Create a canonical request by concatenating the following strings, separated\n * by newline characters. This helps ensure that the signature that you\n * calculate and the signature that AWS calculates can match.\n *\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html#create-canonical-request\n *\n * @param param0\n * @param param0.method – The HTTP method.\n * @param param0.CanonicalUri – The URI-encoded version of the absolute\n * path component URL (everything between the host and the question mark\n * character (?) that starts the query string parameters). If the absolute path\n * is empty, use a forward slash character (/).\n * @param param0.CanonicalQueryString – The URL-encoded query string\n * parameters, separated by ampersands (&). Percent-encode reserved characters,\n * including the space character. Encode names and values separately. If there\n * are empty parameters, append the equals sign to the parameter name before\n * encoding. After encoding, sort the parameters alphabetically by key name. If\n * there is no query string, use an empty string (\"\").\n * @param param0.SignedHeaders – The request headers,\n * that will be signed, and their values, separated by newline characters.\n * For the values, trim any leading or trailing spaces, convert sequential\n * spaces to a single space, and separate the values for a multi-value header\n * using commas. You must include the host header (HTTP/1.1), and any x-amz-*\n * headers in the signature. You can optionally include other standard headers\n * in the signature, such as content-type.\n * @param param0.HashedPayload – A string created using the payload in\n * the body of the HTTP request as input to a hash function. This string uses\n * lowercase hexadecimal characters. If the payload is empty, use an empty\n * string as the input to the hash function.\n */\nfunction createCanonicalRequest({ method = 'PUT', CanonicalUri = '/', CanonicalQueryString = '', SignedHeaders, HashedPayload, }) {\n    const headerKeys = Object.keys(SignedHeaders)\n        .map((k) => k.toLowerCase())\n        .sort();\n    return [\n        method,\n        CanonicalUri,\n        CanonicalQueryString,\n        ...headerKeys.map((k) => `${k}:${SignedHeaders[k]}`),\n        '',\n        headerKeys.join(';'),\n        HashedPayload,\n    ].join('\\n');\n}\nconst ec = new TextEncoder();\nconst algorithm = { name: 'HMAC', hash: 'SHA-256' };\nasync function digest(data) {\n    const { subtle } = globalThis.crypto;\n    return subtle.digest(algorithm.hash, ec.encode(data));\n}\nasync function generateHmacKey(secret) {\n    const { subtle } = globalThis.crypto;\n    return subtle.importKey('raw', typeof secret === 'string' ? ec.encode(secret) : secret, algorithm, false, ['sign']);\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n    const byteArray = new Uint8Array(arrayBuffer);\n    let hexString = '';\n    for (let i = 0; i < byteArray.length; i++) {\n        hexString += byteArray[i].toString(16).padStart(2, '0');\n    }\n    return hexString;\n}\nasync function hash(key, data) {\n    const { subtle } = globalThis.crypto;\n    return subtle.sign(algorithm, await generateHmacKey(key), ec.encode(data));\n}\n/**\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html\n */\nexport default async function createSignedURL({ accountKey, accountSecret, sessionToken, bucketName, Key, Region, expires, uploadId, partNumber, }) {\n    const Service = 's3';\n    const host = `${Service}.${Region}.amazonaws.com`;\n    /**\n     * List of char out of `encodeURI()` is taken from ECMAScript spec.\n     * Note that the `/` character is purposefully not included in list below.\n     *\n     * @see https://tc39.es/ecma262/#sec-encodeuri-uri\n     */\n    const CanonicalUri = `/${bucketName}/${encodeURI(Key).replace(/[;?:@&=+$,#!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)}`;\n    const payload = 'UNSIGNED-PAYLOAD';\n    const requestDateTime = new Date().toISOString().replace(/[-:]|\\.\\d+/g, ''); // YYYYMMDDTHHMMSSZ\n    const date = requestDateTime.slice(0, 8); // YYYYMMDD\n    const scope = `${date}/${Region}/${Service}/aws4_request`;\n    const url = new URL(`https://${host}${CanonicalUri}`);\n    // N.B.: URL search params needs to be added in the ASCII order\n    url.searchParams.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n    url.searchParams.set('X-Amz-Content-Sha256', payload);\n    url.searchParams.set('X-Amz-Credential', `${accountKey}/${scope}`);\n    url.searchParams.set('X-Amz-Date', requestDateTime);\n    url.searchParams.set('X-Amz-Expires', expires);\n    // We are signing on the client, so we expect there's going to be a session token:\n    url.searchParams.set('X-Amz-Security-Token', sessionToken);\n    url.searchParams.set('X-Amz-SignedHeaders', 'host');\n    // Those two are present only for Multipart Uploads:\n    if (partNumber)\n        url.searchParams.set('partNumber', partNumber);\n    if (uploadId)\n        url.searchParams.set('uploadId', uploadId);\n    url.searchParams.set('x-id', partNumber && uploadId ? 'UploadPart' : 'PutObject');\n    // Step 1: Create a canonical request\n    const canonical = createCanonicalRequest({\n        CanonicalUri,\n        CanonicalQueryString: url.search.slice(1),\n        SignedHeaders: {\n            host,\n        },\n        HashedPayload: payload,\n    });\n    // Step 2: Create a hash of the canonical request\n    const hashedCanonical = arrayBufferToHexString(await digest(canonical));\n    // Step 3: Create a string to sign\n    const stringToSign = [\n        `AWS4-HMAC-SHA256`, // The algorithm used to create the hash of the canonical request.\n        requestDateTime, // The date and time used in the credential scope.\n        scope, // The credential scope. This restricts the resulting signature to the specified Region and service.\n        hashedCanonical, // The hash of the canonical request.\n    ].join('\\n');\n    // Step 4: Calculate the signature\n    const kDate = await hash(`AWS4${accountSecret}`, date);\n    const kRegion = await hash(kDate, Region);\n    const kService = await hash(kRegion, Service);\n    const kSigning = await hash(kService, 'aws4_request');\n    const signature = arrayBufferToHexString(await hash(kSigning, stringToSign));\n    // Step 5: Add the signature to the request\n    url.searchParams.set('X-Amz-Signature', signature);\n    return url;\n}\n", "import { AbortController } from '@uppy/utils/lib/AbortController';\nconst MB = 1024 * 1024;\nconst defaultOptions = {\n    getChunkSize(file) {\n        return Math.ceil(file.size / 10000);\n    },\n    onProgress() { },\n    onPartComplete() { },\n    onSuccess() { },\n    onError(err) {\n        throw err;\n    },\n};\nfunction ensureInt(value) {\n    if (typeof value === 'string') {\n        // @ts-expect-error TS is not able to recognize it's fine.\n        return parseInt(value, 10);\n    }\n    if (typeof value === 'number') {\n        // @ts-expect-error TS is not able to recognize it's fine.\n        return value;\n    }\n    throw new TypeError('Expected a number');\n}\nexport const pausingUploadReason = Symbol('pausing upload, not an actual error');\n/**\n * A MultipartUploader instance is used per file upload to determine whether a\n * upload should be done as multipart or as a regular S3 upload\n * (based on the user-provided `shouldUseMultipart` option value) and to manage\n * the chunk splitting.\n */\nclass MultipartUploader {\n    options;\n    #abortController = new AbortController();\n    #chunks = [];\n    #chunkState = [];\n    /**\n     * The (un-chunked) data to upload.\n     */\n    #data;\n    #file;\n    #uploadHasStarted = false;\n    #onError;\n    #onSuccess;\n    #shouldUseMultipart;\n    #isRestoring;\n    #onReject = (err) => err?.cause === pausingUploadReason ? null : this.#onError(err);\n    #maxMultipartParts = 10_000;\n    #minPartSize = 5 * MB;\n    constructor(data, options) {\n        this.options = {\n            ...defaultOptions,\n            ...options,\n        };\n        // Use default `getChunkSize` if it was null or something\n        this.options.getChunkSize ??= defaultOptions.getChunkSize;\n        this.#data = data;\n        this.#file = options.file;\n        this.#onSuccess = this.options.onSuccess;\n        this.#onError = this.options.onError;\n        this.#shouldUseMultipart = this.options.shouldUseMultipart;\n        // When we are restoring an upload, we already have an UploadId and a Key. Otherwise\n        // we need to call `createMultipartUpload` to get an `uploadId` and a `key`.\n        // Non-multipart uploads are not restorable.\n        this.#isRestoring = (options.uploadId && options.key);\n        this.#initChunks();\n    }\n    // initChunks checks the user preference for using multipart uploads (opts.shouldUseMultipart)\n    // and calculates the optimal part size. When using multipart part uploads every part except for the last has\n    // to be at least 5 MB and there can be no more than 10K parts.\n    // This means we sometimes need to change the preferred part size from the user in order to meet these requirements.\n    #initChunks() {\n        const fileSize = this.#data.size;\n        const shouldUseMultipart = typeof this.#shouldUseMultipart === 'function'\n            ? this.#shouldUseMultipart(this.#file)\n            : Boolean(this.#shouldUseMultipart);\n        if (shouldUseMultipart && fileSize > this.#minPartSize) {\n            // At least 5MB per request:\n            let chunkSize = Math.max(this.options.getChunkSize(this.#data), // Math.max can take undefined but TS does not think so\n            this.#minPartSize);\n            let arraySize = Math.floor(fileSize / chunkSize);\n            // At most 10k requests per file:\n            if (arraySize > this.#maxMultipartParts) {\n                arraySize = this.#maxMultipartParts;\n                chunkSize = fileSize / this.#maxMultipartParts;\n            }\n            this.#chunks = Array(arraySize);\n            for (let offset = 0, j = 0; offset < fileSize; offset += chunkSize, j++) {\n                const end = Math.min(fileSize, offset + chunkSize);\n                // Defer data fetching/slicing until we actually need the data, because it's slow if we have a lot of files\n                const getData = () => {\n                    const i2 = offset;\n                    return this.#data.slice(i2, end);\n                };\n                this.#chunks[j] = {\n                    getData,\n                    onProgress: this.#onPartProgress(j),\n                    onComplete: this.#onPartComplete(j),\n                    shouldUseMultipart,\n                };\n                if (this.#isRestoring) {\n                    const size = offset + chunkSize > fileSize ? fileSize - offset : chunkSize;\n                    // setAsUploaded is called by listPart, to keep up-to-date the\n                    // quantity of data that is left to actually upload.\n                    this.#chunks[j].setAsUploaded = () => {\n                        this.#chunks[j] = null;\n                        this.#chunkState[j].uploaded = size;\n                    };\n                }\n            }\n        }\n        else {\n            this.#chunks = [\n                {\n                    getData: () => this.#data,\n                    onProgress: this.#onPartProgress(0),\n                    onComplete: this.#onPartComplete(0),\n                    shouldUseMultipart,\n                },\n            ];\n        }\n        this.#chunkState = this.#chunks.map(() => ({ uploaded: 0 }));\n    }\n    #createUpload() {\n        this.options.companionComm\n            .uploadFile(this.#file, this.#chunks, this.#abortController.signal)\n            .then(this.#onSuccess, this.#onReject);\n        this.#uploadHasStarted = true;\n    }\n    #resumeUpload() {\n        this.options.companionComm\n            .resumeUploadFile(this.#file, this.#chunks, this.#abortController.signal)\n            .then(this.#onSuccess, this.#onReject);\n    }\n    #onPartProgress = (index) => (ev) => {\n        if (!ev.lengthComputable)\n            return;\n        this.#chunkState[index].uploaded = ensureInt(ev.loaded);\n        const totalUploaded = this.#chunkState.reduce((n, c) => n + c.uploaded, 0);\n        this.options.onProgress(totalUploaded, this.#data.size);\n    };\n    #onPartComplete = (index) => (etag) => {\n        // This avoids the net::ERR_OUT_OF_MEMORY in Chromium Browsers.\n        this.#chunks[index] = null;\n        this.#chunkState[index].etag = etag;\n        this.#chunkState[index].done = true;\n        const part = {\n            PartNumber: index + 1,\n            ETag: etag,\n        };\n        this.options.onPartComplete(part);\n    };\n    #abortUpload() {\n        this.#abortController.abort();\n        this.options.companionComm\n            .abortFileUpload(this.#file)\n            .catch((err) => this.options.log(err));\n    }\n    start() {\n        if (this.#uploadHasStarted) {\n            if (!this.#abortController.signal.aborted)\n                this.#abortController.abort(pausingUploadReason);\n            this.#abortController = new AbortController();\n            this.#resumeUpload();\n        }\n        else if (this.#isRestoring) {\n            this.options.companionComm.restoreUploadFile(this.#file, {\n                uploadId: this.options.uploadId,\n                key: this.options.key,\n            });\n            this.#resumeUpload();\n        }\n        else {\n            this.#createUpload();\n        }\n    }\n    pause() {\n        this.#abortController.abort(pausingUploadReason);\n        // Swap it out for a new controller, because this instance may be resumed later.\n        this.#abortController = new AbortController();\n    }\n    abort(opts) {\n        if (opts?.really)\n            this.#abortUpload();\n        else\n            this.pause();\n    }\n    [Symbol.for('uppy test: getChunkState')]() {\n        return this.#chunkState;\n    }\n}\nexport default MultipartUploader;\n", "import { createAbortError } from '@uppy/utils/lib/AbortController';\nexport function throwIfAborted(signal) {\n    if (signal?.aborted) {\n        throw createAbortError('The operation was aborted', {\n            cause: signal.reason,\n        });\n    }\n}\n", "import { pausingUploadReason } from './MultipartUploader.js';\nimport { throwIfAborted } from './utils.js';\nfunction removeMetadataFromURL(urlString) {\n    const urlObject = new URL(urlString);\n    urlObject.search = '';\n    urlObject.hash = '';\n    return urlObject.href;\n}\nexport class HTTPCommunicationQueue {\n    #abortMultipartUpload;\n    #cache = new WeakMap();\n    #createMultipartUpload;\n    #fetchSignature;\n    #getUploadParameters;\n    #listParts;\n    #previousRetryDelay;\n    #requests;\n    #retryDelays;\n    #sendCompletionRequest;\n    #setS3MultipartState;\n    #uploadPartBytes;\n    #getFile;\n    constructor(requests, options, setS3MultipartState, getFile) {\n        this.#requests = requests;\n        this.#setS3MultipartState = setS3MultipartState;\n        this.#getFile = getFile;\n        this.setOptions(options);\n    }\n    setOptions(options) {\n        const requests = this.#requests;\n        if ('abortMultipartUpload' in options) {\n            this.#abortMultipartUpload = requests.wrapPromiseFunction(options.abortMultipartUpload, { priority: 1 });\n        }\n        if ('createMultipartUpload' in options) {\n            this.#createMultipartUpload = requests.wrapPromiseFunction(options.createMultipartUpload, { priority: -1 });\n        }\n        if ('signPart' in options) {\n            this.#fetchSignature = requests.wrapPromiseFunction(options.signPart);\n        }\n        if ('listParts' in options) {\n            this.#listParts = requests.wrapPromiseFunction(options.listParts);\n        }\n        if ('completeMultipartUpload' in options) {\n            this.#sendCompletionRequest = requests.wrapPromiseFunction(options.completeMultipartUpload, { priority: 1 });\n        }\n        if ('retryDelays' in options) {\n            this.#retryDelays = options.retryDelays ?? [];\n        }\n        if ('uploadPartBytes' in options) {\n            this.#uploadPartBytes = requests.wrapPromiseFunction(options.uploadPartBytes, { priority: Infinity });\n        }\n        if ('getUploadParameters' in options) {\n            this.#getUploadParameters = requests.wrapPromiseFunction(options.getUploadParameters);\n        }\n    }\n    async #shouldRetry(err, retryDelayIterator) {\n        const requests = this.#requests;\n        const status = err?.source?.status;\n        // TODO: this retry logic is taken out of Tus. We should have a centralized place for retrying,\n        // perhaps the rate limited queue, and dedupe all plugins with that.\n        if (status == null) {\n            return false;\n        }\n        if (status === 403 && err.message === 'Request has expired') {\n            if (!requests.isPaused) {\n                // We don't want to exhaust the retryDelayIterator as long as there are\n                // more than one request in parallel, to give slower connection a chance\n                // to catch up with the expiry set in Companion.\n                if (requests.limit === 1 || this.#previousRetryDelay == null) {\n                    const next = retryDelayIterator.next();\n                    if (next == null || next.done) {\n                        return false;\n                    }\n                    // If there are more than 1 request done in parallel, the RLQ limit is\n                    // decreased and the failed request is requeued after waiting for a bit.\n                    // If there is only one request in parallel, the limit can't be\n                    // decreased, so we iterate over `retryDelayIterator` as we do for\n                    // other failures.\n                    // `#previousRetryDelay` caches the value so we can re-use it next time.\n                    this.#previousRetryDelay = next.value;\n                }\n                // No need to stop the other requests, we just want to lower the limit.\n                requests.rateLimit(0);\n                await new Promise((resolve) => setTimeout(resolve, this.#previousRetryDelay));\n            }\n        }\n        else if (status === 429) {\n            // HTTP 429 Too Many Requests => to avoid the whole download to fail, pause all requests.\n            if (!requests.isPaused) {\n                const next = retryDelayIterator.next();\n                if (next == null || next.done) {\n                    return false;\n                }\n                requests.rateLimit(next.value);\n            }\n        }\n        else if (status > 400 && status < 500 && status !== 409) {\n            // HTTP 4xx, the server won't send anything, it's doesn't make sense to retry\n            return false;\n        }\n        else if (typeof navigator !== 'undefined' && navigator.onLine === false) {\n            // The navigator is offline, let's wait for it to come back online.\n            if (!requests.isPaused) {\n                requests.pause();\n                window.addEventListener('online', () => {\n                    requests.resume();\n                }, { once: true });\n            }\n        }\n        else {\n            // Other error code means the request can be retried later.\n            const next = retryDelayIterator.next();\n            if (next == null || next.done) {\n                return false;\n            }\n            await new Promise((resolve) => setTimeout(resolve, next.value));\n        }\n        return true;\n    }\n    async getUploadId(file, signal) {\n        let cachedResult;\n        // As the cache is updated asynchronously, there could be a race condition\n        // where we just miss a new result so we loop here until we get nothing back,\n        // at which point it's out turn to create a new cache entry.\n        for (;;) {\n            cachedResult = this.#cache.get(file.data);\n            if (cachedResult == null)\n                break;\n            try {\n                return await cachedResult;\n            }\n            catch {\n                // In case of failure, we want to ignore the cached error.\n                // At this point, either there's a new cached value, or we'll exit the loop a create a new one.\n            }\n        }\n        const promise = this.#createMultipartUpload(this.#getFile(file), signal);\n        const abortPromise = () => {\n            promise.abort(signal.reason);\n            this.#cache.delete(file.data);\n        };\n        signal.addEventListener('abort', abortPromise, { once: true });\n        this.#cache.set(file.data, promise);\n        promise.then(async (result) => {\n            signal.removeEventListener('abort', abortPromise);\n            this.#setS3MultipartState(file, result);\n            this.#cache.set(file.data, result);\n        }, () => {\n            signal.removeEventListener('abort', abortPromise);\n            this.#cache.delete(file.data);\n        });\n        return promise;\n    }\n    async abortFileUpload(file) {\n        const result = this.#cache.get(file.data);\n        if (result == null) {\n            // If the createMultipartUpload request never was made, we don't\n            // need to send the abortMultipartUpload request.\n            return;\n        }\n        // Remove the cache entry right away for follow-up requests do not try to\n        // use the soon-to-be aborted cached values.\n        this.#cache.delete(file.data);\n        this.#setS3MultipartState(file, Object.create(null));\n        let awaitedResult;\n        try {\n            awaitedResult = await result;\n        }\n        catch {\n            // If the cached result rejects, there's nothing to abort.\n            return;\n        }\n        await this.#abortMultipartUpload(this.#getFile(file), awaitedResult);\n    }\n    async #nonMultipartUpload(file, chunk, signal) {\n        const { method = 'POST', url, fields, headers, } = await this.#getUploadParameters(this.#getFile(file), {\n            signal,\n        }).abortOn(signal);\n        let body;\n        const data = chunk.getData();\n        if (method.toUpperCase() === 'POST') {\n            const formData = new FormData();\n            Object.entries(fields).forEach(([key, value]) => formData.set(key, value));\n            formData.set('file', data);\n            body = formData;\n        }\n        else {\n            body = data;\n        }\n        const { onProgress, onComplete } = chunk;\n        const result = (await this.#uploadPartBytes({\n            signature: { url, headers, method },\n            body,\n            size: data.size,\n            onProgress,\n            onComplete,\n            signal,\n        }).abortOn(signal)); // todo this doesn't make sense\n        // Note: `fields.key` is not returned by old Companion versions.\n        // See https://github.com/transloadit/uppy/pull/5602\n        const key = fields?.key;\n        this.#setS3MultipartState(file, { key: key });\n        return {\n            ...result,\n            location: result.location ?? removeMetadataFromURL(url),\n            bucket: fields?.bucket,\n            key,\n        };\n    }\n    async uploadFile(file, chunks, signal) {\n        throwIfAborted(signal);\n        if (chunks.length === 1 && !chunks[0].shouldUseMultipart) {\n            return this.#nonMultipartUpload(file, chunks[0], signal);\n        }\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        throwIfAborted(signal);\n        try {\n            const parts = await Promise.all(chunks.map((chunk, i) => this.uploadChunk(file, i + 1, chunk, signal)));\n            throwIfAborted(signal);\n            return await this.#sendCompletionRequest(this.#getFile(file), { key, uploadId, parts, signal }, signal).abortOn(signal);\n        }\n        catch (err) {\n            if (err?.cause !== pausingUploadReason && err?.name !== 'AbortError') {\n                // We purposefully don't wait for the promise and ignore its status,\n                // because we want the error `err` to bubble up ASAP to report it to the\n                // user. A failure to abort is not that big of a deal anyway.\n                this.abortFileUpload(file);\n            }\n            throw err;\n        }\n    }\n    restoreUploadFile(file, uploadIdAndKey) {\n        this.#cache.set(file.data, uploadIdAndKey);\n    }\n    async resumeUploadFile(file, chunks, signal) {\n        throwIfAborted(signal);\n        if (chunks.length === 1 &&\n            chunks[0] != null &&\n            !chunks[0].shouldUseMultipart) {\n            return this.#nonMultipartUpload(file, chunks[0], signal);\n        }\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        throwIfAborted(signal);\n        const alreadyUploadedParts = await this.#listParts(this.#getFile(file), { uploadId, key, signal }, signal).abortOn(signal);\n        throwIfAborted(signal);\n        const parts = await Promise.all(chunks.map((chunk, i) => {\n            const partNumber = i + 1;\n            const alreadyUploadedInfo = alreadyUploadedParts.find(({ PartNumber }) => PartNumber === partNumber);\n            if (alreadyUploadedInfo == null) {\n                return this.uploadChunk(file, partNumber, chunk, signal);\n            }\n            // Already uploaded chunks are set to null. If we are restoring the upload, we need to mark it as already uploaded.\n            chunk?.setAsUploaded?.();\n            return { PartNumber: partNumber, ETag: alreadyUploadedInfo.ETag };\n        }));\n        throwIfAborted(signal);\n        return this.#sendCompletionRequest(this.#getFile(file), { key, uploadId, parts, signal }, signal).abortOn(signal);\n    }\n    async uploadChunk(file, partNumber, chunk, signal) {\n        throwIfAborted(signal);\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        const signatureRetryIterator = this.#retryDelays.values();\n        const chunkRetryIterator = this.#retryDelays.values();\n        const shouldRetrySignature = () => {\n            const next = signatureRetryIterator.next();\n            if (next == null || next.done) {\n                return null;\n            }\n            return next.value;\n        };\n        for (;;) {\n            throwIfAborted(signal);\n            const chunkData = chunk.getData();\n            const { onProgress, onComplete } = chunk;\n            let signature;\n            try {\n                signature = await this.#fetchSignature(this.#getFile(file), {\n                    // Always defined for multipart uploads\n                    uploadId: uploadId,\n                    key,\n                    partNumber,\n                    body: chunkData,\n                    signal,\n                }).abortOn(signal);\n            }\n            catch (err) {\n                const timeout = shouldRetrySignature();\n                if (timeout == null || signal.aborted) {\n                    throw err;\n                }\n                await new Promise((resolve) => setTimeout(resolve, timeout));\n                continue;\n            }\n            throwIfAborted(signal);\n            try {\n                return {\n                    PartNumber: partNumber,\n                    ...(await this.#uploadPartBytes({\n                        signature,\n                        body: chunkData,\n                        size: chunkData.size,\n                        onProgress,\n                        onComplete,\n                        signal,\n                    }).abortOn(signal)),\n                };\n            }\n            catch (err) {\n                if (!(await this.#shouldRetry(err, chunkRetryIterator)))\n                    throw err;\n            }\n        }\n    }\n}\n", "import { RequestClient } from '@uppy/companion-client';\nimport { BasePlugin, } from '@uppy/core';\nimport EventManager from '@uppy/core/lib/EventManager.js';\nimport { createAbortError } from '@uppy/utils/lib/AbortController';\nimport { filterFilesToEmitUploadStarted, filterNonFailedFiles, } from '@uppy/utils/lib/fileFilters';\nimport getAllowedMetaFields from '@uppy/utils/lib/getAllowedMetaFields';\nimport { RateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport packageJson from '../package.json' with { type: 'json' };\nimport createSignedURL from './createSignedURL.js';\nimport { HTTPCommunicationQueue } from './HTTPCommunicationQueue.js';\nimport MultipartUploader from './MultipartUploader.js';\nimport { throwIfAborted } from './utils.js';\nfunction assertServerError(res) {\n    if (res?.error) {\n        const error = new Error(res.message);\n        Object.assign(error, res.error);\n        throw error;\n    }\n    return res;\n}\n/**\n * Computes the expiry time for a request signed with temporary credentials. If\n * no expiration was provided, or an invalid value (e.g. in the past) is\n * provided, undefined is returned. This function assumes the client clock is in\n * sync with the remote server, which is a requirement for the signature to be\n * validated for AWS anyway.\n */\nfunction getExpiry(credentials) {\n    const expirationDate = credentials.Expiration;\n    if (expirationDate) {\n        const timeUntilExpiry = Math.floor((new Date(expirationDate) - Date.now()) / 1000);\n        if (timeUntilExpiry > 9) {\n            return timeUntilExpiry;\n        }\n    }\n    return undefined;\n}\nfunction getAllowedMetadata({ meta, allowedMetaFields, querify = false, }) {\n    const metaFields = allowedMetaFields ?? Object.keys(meta);\n    if (!meta)\n        return {};\n    return Object.fromEntries(metaFields\n        .filter((key) => meta[key] != null)\n        .map((key) => {\n        const realKey = querify ? `metadata[${key}]` : key;\n        const value = String(meta[key]);\n        return [realKey, value];\n    }));\n}\nconst defaultOptions = {\n    allowedMetaFields: true,\n    limit: 6,\n    getTemporarySecurityCredentials: false,\n    shouldUseMultipart: ((file) => (file.size || 0) > 100 * 1024 * 1024),\n    retryDelays: [0, 1000, 3000, 5000],\n};\nexport default class AwsS3Multipart extends BasePlugin {\n    static VERSION = packageJson.version;\n    #companionCommunicationQueue;\n    #client;\n    requests;\n    uploaderEvents;\n    uploaders;\n    constructor(uppy, opts) {\n        super(uppy, {\n            ...defaultOptions,\n            uploadPartBytes: AwsS3Multipart.uploadPartBytes,\n            createMultipartUpload: null,\n            listParts: null,\n            abortMultipartUpload: null,\n            completeMultipartUpload: null,\n            signPart: null,\n            getUploadParameters: null,\n            ...opts,\n        });\n        // We need the `as any` here because of the dynamic default options.\n        this.type = 'uploader';\n        this.id = this.opts.id || 'AwsS3Multipart';\n        this.#setClient(opts);\n        const dynamicDefaultOptions = {\n            createMultipartUpload: this.createMultipartUpload,\n            listParts: this.listParts,\n            abortMultipartUpload: this.abortMultipartUpload,\n            completeMultipartUpload: this.completeMultipartUpload,\n            signPart: opts?.getTemporarySecurityCredentials\n                ? this.createSignedURL\n                : this.signPart,\n            getUploadParameters: opts?.getTemporarySecurityCredentials\n                ? this.createSignedURL\n                : this.getUploadParameters,\n        };\n        for (const key of Object.keys(dynamicDefaultOptions)) {\n            if (this.opts[key] == null) {\n                this.opts[key] =\n                    dynamicDefaultOptions[key].bind(this);\n            }\n        }\n        /**\n         * Simultaneous upload limiting is shared across all uploads with this plugin.\n         *\n         * @type {RateLimitedQueue}\n         */\n        this.requests =\n            this.opts.rateLimitedQueue ??\n                new RateLimitedQueue(this.opts.limit);\n        this.#companionCommunicationQueue = new HTTPCommunicationQueue(this.requests, this.opts, this.#setS3MultipartState, this.#getFile);\n        this.uploaders = Object.create(null);\n        this.uploaderEvents = Object.create(null);\n    }\n    [Symbol.for('uppy test: getClient')]() {\n        return this.#client;\n    }\n    #setClient(opts) {\n        if (opts == null ||\n            !('endpoint' in opts ||\n                'companionUrl' in opts ||\n                'headers' in opts ||\n                'companionHeaders' in opts ||\n                'cookiesRule' in opts ||\n                'companionCookiesRule' in opts))\n            return;\n        if ('companionUrl' in opts && !('endpoint' in opts)) {\n            this.uppy.log('`companionUrl` option has been removed in @uppy/aws-s3, use `endpoint` instead.', 'warning');\n        }\n        if ('companionHeaders' in opts && !('headers' in opts)) {\n            this.uppy.log('`companionHeaders` option has been removed in @uppy/aws-s3, use `headers` instead.', 'warning');\n        }\n        if ('companionCookiesRule' in opts && !('cookiesRule' in opts)) {\n            this.uppy.log('`companionCookiesRule` option has been removed in @uppy/aws-s3, use `cookiesRule` instead.', 'warning');\n        }\n        if ('endpoint' in opts) {\n            this.#client = new RequestClient(this.uppy, {\n                pluginId: this.id,\n                provider: 'AWS',\n                companionUrl: this.opts.endpoint,\n                companionHeaders: this.opts.headers,\n                companionCookiesRule: this.opts.cookiesRule,\n            });\n        }\n        else {\n            if ('headers' in opts) {\n                this.#setCompanionHeaders();\n            }\n            if ('cookiesRule' in opts) {\n                this.#client.opts.companionCookiesRule = opts.cookiesRule;\n            }\n        }\n    }\n    setOptions(newOptions) {\n        this.#companionCommunicationQueue.setOptions(newOptions);\n        super.setOptions(newOptions);\n        this.#setClient(newOptions);\n    }\n    /**\n     * Clean up all references for a file's upload: the MultipartUploader instance,\n     * any events related to the file, and the Companion WebSocket connection.\n     *\n     * Set `opts.abort` to tell S3 that the multipart upload is cancelled and must be removed.\n     * This should be done when the user cancels the upload, not when the upload is completed or errored.\n     */\n    resetUploaderReferences(fileID, opts) {\n        if (this.uploaders[fileID]) {\n            this.uploaders[fileID].abort({ really: opts?.abort || false });\n            this.uploaders[fileID] = null;\n        }\n        if (this.uploaderEvents[fileID]) {\n            this.uploaderEvents[fileID].remove();\n            this.uploaderEvents[fileID] = null;\n        }\n    }\n    #assertHost(method) {\n        if (!this.#client) {\n            throw new Error(`Expected a \\`endpoint\\` option containing a URL, or if you are not using Companion, a custom \\`${method}\\` implementation.`);\n        }\n    }\n    createMultipartUpload(file, signal) {\n        this.#assertHost('createMultipartUpload');\n        throwIfAborted(signal);\n        const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);\n        const metadata = getAllowedMetadata({ meta: file.meta, allowedMetaFields });\n        return this.#client\n            .post('s3/multipart', {\n            filename: file.name,\n            type: file.type,\n            metadata,\n        }, { signal })\n            .then(assertServerError);\n    }\n    listParts(file, { key, uploadId, signal }, oldSignal) {\n        signal ??= oldSignal;\n        this.#assertHost('listParts');\n        throwIfAborted(signal);\n        const filename = encodeURIComponent(key);\n        return this.#client\n            .get(`s3/multipart/${encodeURIComponent(uploadId)}?key=${filename}`, { signal })\n            .then(assertServerError);\n    }\n    completeMultipartUpload(file, { key, uploadId, parts, signal }, oldSignal) {\n        signal ??= oldSignal;\n        this.#assertHost('completeMultipartUpload');\n        throwIfAborted(signal);\n        const filename = encodeURIComponent(key);\n        const uploadIdEnc = encodeURIComponent(uploadId);\n        return this.#client\n            .post(`s3/multipart/${uploadIdEnc}/complete?key=${filename}`, { parts: parts.map(({ ETag, PartNumber }) => ({ ETag, PartNumber })) }, { signal })\n            .then(assertServerError);\n    }\n    #cachedTemporaryCredentials;\n    async #getTemporarySecurityCredentials(options) {\n        throwIfAborted(options?.signal);\n        if (this.#cachedTemporaryCredentials == null) {\n            const { getTemporarySecurityCredentials } = this.opts;\n            // We do not await it just yet, so concurrent calls do not try to override it:\n            if (getTemporarySecurityCredentials === true) {\n                this.#assertHost('getTemporarySecurityCredentials');\n                this.#cachedTemporaryCredentials = this.#client\n                    .get('s3/sts', options)\n                    .then(assertServerError);\n            }\n            else {\n                this.#cachedTemporaryCredentials =\n                    getTemporarySecurityCredentials(options);\n            }\n            this.#cachedTemporaryCredentials = await this.#cachedTemporaryCredentials;\n            setTimeout(() => {\n                // At half the time left before expiration, we clear the cache. That's\n                // an arbitrary tradeoff to limit the number of requests made to the\n                // remote while limiting the risk of using an expired token in case the\n                // clocks are not exactly synced.\n                // The HTTP cache should be configured to ensure a client doesn't request\n                // more tokens than it needs, but this timeout provides a second layer of\n                // security in case the HTTP cache is disabled or misconfigured.\n                this.#cachedTemporaryCredentials = null;\n            }, (getExpiry(this.#cachedTemporaryCredentials.credentials) || 0) * 500);\n        }\n        return this.#cachedTemporaryCredentials;\n    }\n    async createSignedURL(file, options) {\n        const data = await this.#getTemporarySecurityCredentials(options);\n        const expires = getExpiry(data.credentials) || 604_800; // 604 800 is the max value accepted by AWS.\n        const { uploadId, key, partNumber } = options;\n        // Return an object in the correct shape.\n        return {\n            method: 'PUT',\n            expires,\n            fields: {},\n            url: `${await createSignedURL({\n                accountKey: data.credentials.AccessKeyId,\n                accountSecret: data.credentials.SecretAccessKey,\n                sessionToken: data.credentials.SessionToken,\n                expires,\n                bucketName: data.bucket,\n                Region: data.region,\n                Key: key ?? `${crypto.randomUUID()}-${file.name}`,\n                uploadId,\n                partNumber,\n            })}`,\n            // Provide content type header required by S3\n            headers: {\n                'Content-Type': file.type,\n            },\n        };\n    }\n    signPart(file, { uploadId, key, partNumber, signal }) {\n        this.#assertHost('signPart');\n        throwIfAborted(signal);\n        if (uploadId == null || key == null || partNumber == null) {\n            throw new Error('Cannot sign without a key, an uploadId, and a partNumber');\n        }\n        const filename = encodeURIComponent(key);\n        return this.#client\n            .get(`s3/multipart/${encodeURIComponent(uploadId)}/${partNumber}?key=${filename}`, { signal })\n            .then(assertServerError);\n    }\n    abortMultipartUpload(file, { key, uploadId, signal }) {\n        this.#assertHost('abortMultipartUpload');\n        const filename = encodeURIComponent(key);\n        const uploadIdEnc = encodeURIComponent(uploadId);\n        return this.#client\n            .delete(`s3/multipart/${uploadIdEnc}?key=${filename}`, undefined, {\n            signal,\n        })\n            .then(assertServerError);\n    }\n    getUploadParameters(file, options) {\n        this.#assertHost('getUploadParameters');\n        const { meta } = file;\n        const { type, name: filename } = meta;\n        const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);\n        const metadata = getAllowedMetadata({\n            meta,\n            allowedMetaFields,\n            querify: true,\n        });\n        const query = new URLSearchParams({ filename, type, ...metadata });\n        return this.#client.get(`s3/params?${query}`, options);\n    }\n    static async uploadPartBytes({ signature: { url, expires, headers, method = 'PUT' }, body, size = body.size, onProgress, onComplete, signal, }) {\n        throwIfAborted(signal);\n        if (url == null) {\n            throw new Error('Cannot upload to an undefined URL');\n        }\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(method, url, true);\n            if (headers) {\n                Object.keys(headers).forEach((key) => {\n                    xhr.setRequestHeader(key, headers[key]);\n                });\n            }\n            xhr.responseType = 'text';\n            if (typeof expires === 'number') {\n                xhr.timeout = expires * 1000;\n            }\n            function onabort() {\n                xhr.abort();\n            }\n            function cleanup() {\n                signal?.removeEventListener('abort', onabort);\n            }\n            signal?.addEventListener('abort', onabort);\n            xhr.upload.addEventListener('progress', (ev) => {\n                onProgress(ev);\n            });\n            xhr.addEventListener('abort', () => {\n                cleanup();\n                reject(createAbortError());\n            });\n            xhr.addEventListener('timeout', () => {\n                cleanup();\n                const error = new Error('Request has expired');\n                error.source = { status: 403 };\n                reject(error);\n            });\n            xhr.addEventListener('load', () => {\n                cleanup();\n                if (xhr.status === 403 &&\n                    xhr.responseText.includes('<Message>Request has expired</Message>')) {\n                    const error = new Error('Request has expired');\n                    error.source = xhr;\n                    reject(error);\n                    return;\n                }\n                if (xhr.status < 200 || xhr.status >= 300) {\n                    const error = new Error('Non 2xx');\n                    error.source = xhr;\n                    reject(error);\n                    return;\n                }\n                onProgress?.({ loaded: size, lengthComputable: true });\n                // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#examples\n                const arr = xhr\n                    .getAllResponseHeaders()\n                    .trim()\n                    .split(/[\\r\\n]+/);\n                // @ts-expect-error null is allowed to avoid inherited properties\n                const headersMap = { __proto__: null };\n                for (const line of arr) {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    const value = parts.join(': ');\n                    headersMap[header] = value;\n                }\n                const { etag, location } = headersMap;\n                // More info bucket settings when this is not present:\n                // https://github.com/transloadit/uppy/issues/5388#issuecomment-2464885562\n                if (method.toUpperCase() === 'POST' && location == null) {\n                    // Not being able to read the Location header is not a fatal error.\n                    console.error('@uppy/aws-s3: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n                }\n                if (etag == null) {\n                    console.error('@uppy/aws-s3: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n                    return;\n                }\n                onComplete?.(etag);\n                resolve({\n                    ...headersMap,\n                    ETag: etag, // keep capitalised ETag for backwards compatiblity\n                });\n            });\n            xhr.addEventListener('error', (ev) => {\n                cleanup();\n                const error = new Error('Unknown error');\n                error.source = ev.target;\n                reject(error);\n            });\n            xhr.send(body);\n        });\n    }\n    #setS3MultipartState = (file, { key, uploadId }) => {\n        const cFile = this.uppy.getFile(file.id);\n        if (cFile == null) {\n            // file was removed from store\n            return;\n        }\n        this.uppy.setFileState(file.id, {\n            s3Multipart: {\n                ...cFile.s3Multipart,\n                key,\n                uploadId,\n            },\n        });\n    };\n    #getFile = (file) => {\n        return this.uppy.getFile(file.id) || file;\n    };\n    #uploadLocalFile(file) {\n        return new Promise((resolve, reject) => {\n            const onProgress = (bytesUploaded, bytesTotal) => {\n                const latestFile = this.uppy.getFile(file.id);\n                this.uppy.emit('upload-progress', latestFile, {\n                    uploadStarted: latestFile.progress.uploadStarted ?? 0,\n                    bytesUploaded,\n                    bytesTotal,\n                });\n            };\n            const onError = (err) => {\n                this.uppy.log(err);\n                this.uppy.emit('upload-error', file, err);\n                this.resetUploaderReferences(file.id);\n                reject(err);\n            };\n            const onSuccess = (result) => {\n                const uploadResp = {\n                    body: {\n                        ...result,\n                    },\n                    status: 200,\n                    uploadURL: result.location,\n                };\n                this.resetUploaderReferences(file.id);\n                this.uppy.emit('upload-success', this.#getFile(file), uploadResp);\n                if (result.location) {\n                    this.uppy.log(`Download ${file.name} from ${result.location}`);\n                }\n                resolve(undefined);\n            };\n            const upload = new MultipartUploader(file.data, {\n                // .bind to pass the file object to each handler.\n                companionComm: this.#companionCommunicationQueue,\n                log: (...args) => this.uppy.log(...args),\n                getChunkSize: this.opts.getChunkSize\n                    ? this.opts.getChunkSize.bind(this)\n                    : undefined,\n                onProgress,\n                onError,\n                onSuccess,\n                onPartComplete: (part) => {\n                    this.uppy.emit('s3-multipart:part-uploaded', this.#getFile(file), part);\n                },\n                file,\n                shouldUseMultipart: this.opts.shouldUseMultipart,\n                ...file.s3Multipart,\n            });\n            this.uploaders[file.id] = upload;\n            const eventManager = new EventManager(this.uppy);\n            this.uploaderEvents[file.id] = eventManager;\n            eventManager.onFileRemove(file.id, (removed) => {\n                upload.abort();\n                this.resetUploaderReferences(file.id, { abort: true });\n                resolve(`upload ${removed} was removed`);\n            });\n            eventManager.onCancelAll(file.id, () => {\n                upload.abort();\n                this.resetUploaderReferences(file.id, { abort: true });\n                resolve(`upload ${file.id} was canceled`);\n            });\n            eventManager.onFilePause(file.id, (isPaused) => {\n                if (isPaused) {\n                    upload.pause();\n                }\n                else {\n                    upload.start();\n                }\n            });\n            eventManager.onPauseAll(file.id, () => {\n                upload.pause();\n            });\n            eventManager.onResumeAll(file.id, () => {\n                upload.start();\n            });\n            upload.start();\n        });\n    }\n    #getCompanionClientArgs(file) {\n        return {\n            ...file.remote?.body,\n            protocol: 's3-multipart',\n            size: file.data.size,\n            metadata: file.meta,\n        };\n    }\n    #upload = async (fileIDs) => {\n        if (fileIDs.length === 0)\n            return undefined;\n        const files = this.uppy.getFilesByIds(fileIDs);\n        const filesFiltered = filterNonFailedFiles(files);\n        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);\n        this.uppy.emit('upload-start', filesToEmit);\n        const promises = filesFiltered.map((file) => {\n            if (file.isRemote) {\n                const getQueue = () => this.requests;\n                this.#setResumableUploadsCapability(false);\n                const controller = new AbortController();\n                const removedHandler = (removedFile) => {\n                    if (removedFile.id === file.id)\n                        controller.abort();\n                };\n                this.uppy.on('file-removed', removedHandler);\n                const uploadPromise = this.uppy\n                    .getRequestClientForFile(file)\n                    .uploadRemoteFile(file, this.#getCompanionClientArgs(file), {\n                    signal: controller.signal,\n                    getQueue,\n                });\n                this.requests.wrapSyncFunction(() => {\n                    this.uppy.off('file-removed', removedHandler);\n                }, { priority: -1 })();\n                return uploadPromise;\n            }\n            return this.#uploadLocalFile(file);\n        });\n        const upload = await Promise.allSettled(promises);\n        // After the upload is done, another upload may happen with only local files.\n        // We reset the capability so that the next upload can use resumable uploads.\n        this.#setResumableUploadsCapability(true);\n        return upload;\n    };\n    #setCompanionHeaders = () => {\n        this.#client?.setCompanionHeaders(this.opts.headers);\n    };\n    #setResumableUploadsCapability = (boolean) => {\n        const { capabilities } = this.uppy.getState();\n        this.uppy.setState({\n            capabilities: {\n                ...capabilities,\n                resumableUploads: boolean,\n            },\n        });\n    };\n    #resetResumableCapability = () => {\n        this.#setResumableUploadsCapability(true);\n    };\n    install() {\n        this.#setResumableUploadsCapability(true);\n        this.uppy.addPreProcessor(this.#setCompanionHeaders);\n        this.uppy.addUploader(this.#upload);\n        this.uppy.on('cancel-all', this.#resetResumableCapability);\n    }\n    uninstall() {\n        this.uppy.removePreProcessor(this.#setCompanionHeaders);\n        this.uppy.removeUploader(this.#upload);\n        this.uppy.off('cancel-all', this.#resetResumableCapability);\n    }\n}\n"],
  "mappings": "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",
  "names": ["original", "require_retry", "retry", "AbortController", "package_default", "AbortController", "key", "defaultOptions", "_setS3MultipartState", "_getFile", "location", "package_default"]
}
