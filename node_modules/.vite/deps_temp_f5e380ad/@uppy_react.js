import {
  require_shim
} from "./chunk-23HW6M6L.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import {
  A,
  H,
  K,
  T,
  UIPlugin_default,
  _,
  b,
  d,
  getFileNameAndExtension,
  getSafeFileId,
  getTextDirection_default,
  isDOMElement,
  k,
  l,
  nn,
  q,
  require_debounce,
  require_prettierBytes,
  x,
  y
} from "./chunk-NINPWAVX.js";
import "./chunk-AN6Z2SGJ.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames15() {
        var classes = "";
        for (var i3 = 0; i3 < arguments.length; i3++) {
          var arg = arguments[i3];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames15.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames15.default = classNames15;
        module.exports = classNames15;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames15;
        });
      } else {
        window.classNames = classNames15;
      }
    })();
  }
});

// node_modules/p-queue/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/p-queue/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i3 = 0, l3 = handlers.length, ee2 = new Array(l3); i3 < l3; i3++) {
        ee2[i3] = handlers[i3].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a2);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
            events.push(listeners[i3]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore4 = React.useSyncExternalStore;
        var useRef7 = React.useRef, useEffect10 = React.useEffect, useMemo7 = React.useMemo, useDebugValue = React.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef7(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo7(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore4(subscribe, getSelection, getServerSelection);
          useEffect10(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var f = 0;
var i = Array.isArray;
function u(e2, t2, n2, o2, i3, u3) {
  t2 || (t2 = {});
  var a2, c2, p2 = t2;
  if ("ref" in p2) for (c2 in p2 = {}, t2) "ref" == c2 ? a2 = t2[c2] : p2[c2] = t2[c2];
  var l3 = { type: e2, props: p2, key: n2, ref: a2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f, __i: -1, __u: 0, __source: i3, __self: u3 };
  if ("function" == typeof e2 && (a2 = e2.defaultProps)) for (c2 in a2) void 0 === p2[c2] && (p2[c2] = a2[c2]);
  return l.vnode && l.vnode(l3), l3;
}

// node_modules/@uppy/informer/package.json
var package_default = {
  name: "@uppy/informer",
  description: "A notification and error pop-up bar for Uppy.",
  version: "4.3.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "notification",
    "bar",
    "ui"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    preact: "^10.5.13"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  },
  devDependencies: {
    cssnano: "^7.0.7",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3"
  }
};

// node_modules/@uppy/informer/lib/FadeIn.js
var TRANSITION_MS = 300;
var FadeIn = class extends x {
  constructor() {
    super(...arguments);
    __publicField(this, "ref", b());
  }
  componentWillEnter(callback) {
    this.ref.current.style.opacity = "1";
    this.ref.current.style.transform = "none";
    setTimeout(callback, TRANSITION_MS);
  }
  componentWillLeave(callback) {
    this.ref.current.style.opacity = "0";
    this.ref.current.style.transform = "translateY(350%)";
    setTimeout(callback, TRANSITION_MS);
  }
  render() {
    const { children } = this.props;
    return u("div", { className: "uppy-Informer-animated", ref: this.ref, children });
  }
};

// node_modules/@uppy/informer/lib/TransitionGroup.js
function assign(obj, props) {
  return Object.assign(obj, props);
}
function getKey(vnode, fallback) {
  return (vnode == null ? void 0 : vnode.key) ?? fallback;
}
function linkRef(component, name) {
  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
  return cache[name] || // biome-ignore lint/suspicious/noAssignInExpressions: ...
  (cache[name] = (c2) => {
    component.refs[name] = c2;
  });
}
function getChildMapping(children) {
  const out = {};
  for (let i3 = 0; i3 < children.length; i3++) {
    if (children[i3] != null) {
      const key = getKey(children[i3], i3.toString(36));
      out[key] = children[i3];
    }
  }
  return out;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  const getValueForKey = (key) => Object.hasOwn(next, key) ? next[key] : prev[key];
  const nextKeysPending = {};
  let pendingKeys = [];
  for (const prevKey in prev) {
    if (Object.hasOwn(next, prevKey)) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  const childMapping = {};
  for (const nextKey in next) {
    if (Object.hasOwn(nextKeysPending, nextKey)) {
      for (let i3 = 0; i3 < nextKeysPending[nextKey].length; i3++) {
        const pendingNextKey = nextKeysPending[nextKey][i3];
        childMapping[nextKeysPending[nextKey][i3]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (let i3 = 0; i3 < pendingKeys.length; i3++) {
    childMapping[pendingKeys[i3]] = getValueForKey(pendingKeys[i3]);
  }
  return childMapping;
}
var identity = (i3) => i3;
var TransitionGroup = class extends x {
  constructor(props, context) {
    super(props, context);
    this.refs = {};
    this.state = {
      children: getChildMapping(H(H(this.props.children)) || [])
    };
    this.performAppear = this.performAppear.bind(this);
    this.performEnter = this.performEnter.bind(this);
    this.performLeave = this.performLeave.bind(this);
  }
  componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToAbortLeave = [];
    this.keysToEnter = [];
    this.keysToLeave = [];
  }
  componentDidMount() {
    const initialChildMapping = this.state.children;
    for (const key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  }
  componentWillReceiveProps(nextProps) {
    const nextChildMapping = getChildMapping(H(nextProps.children) || []);
    const prevChildMapping = this.state.children;
    this.setState((prevState) => ({
      children: mergeChildMappings(prevState.children, nextChildMapping)
    }));
    let key;
    for (key in nextChildMapping) {
      if (Object.hasOwn(nextChildMapping, key)) {
        const hasPrev = prevChildMapping && Object.hasOwn(prevChildMapping, key);
        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
          this.keysToAbortLeave.push(key);
        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
        }
      }
    }
    for (key in prevChildMapping) {
      if (Object.hasOwn(prevChildMapping, key)) {
        const hasNext = nextChildMapping && Object.hasOwn(nextChildMapping, key);
        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
          this.keysToLeave.push(key);
        }
      }
    }
  }
  componentDidUpdate() {
    const { keysToEnter } = this;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    const { keysToLeave } = this;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  }
  _finishAbort(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      this.keysToAbortLeave.splice(idx, 1);
    }
  }
  performAppear(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  }
  _handleDoneAppearing(key) {
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentDidAppear) {
      component.componentDidAppear();
    }
    delete this.currentlyTransitioningKeys[key];
    this._finishAbort(key);
    const currentChildMapping = getChildMapping(H(this.props.children) || []);
    if (!currentChildMapping || !Object.hasOwn(currentChildMapping, key)) {
      this.performLeave(key);
    }
  }
  performEnter(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  }
  _handleDoneEntering(key) {
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentDidEnter) {
      component.componentDidEnter();
    }
    delete this.currentlyTransitioningKeys[key];
    this._finishAbort(key);
    const currentChildMapping = getChildMapping(H(this.props.children) || []);
    if (!currentChildMapping || !Object.hasOwn(currentChildMapping, key)) {
      this.performLeave(key);
    }
  }
  performLeave(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      return;
    }
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      this._handleDoneLeaving(key);
    }
  }
  _handleDoneLeaving(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      return;
    }
    const component = this.refs[key];
    if (component == null ? void 0 : component.componentDidLeave) {
      component.componentDidLeave();
    }
    delete this.currentlyTransitioningKeys[key];
    const currentChildMapping = getChildMapping(H(this.props.children) || []);
    if (currentChildMapping && Object.hasOwn(currentChildMapping, key)) {
      this.performEnter(key);
    } else {
      const children = assign({}, this.state.children);
      delete children[key];
      this.setState({ children });
    }
  }
  render({ childFactory, transitionLeave, transitionName: transitionName2, transitionAppear, transitionEnter, transitionLeaveTimeout, transitionEnterTimeout, transitionAppearTimeout, component, ...props }, { children }) {
    const childrenToRender = Object.entries(children).map(([key, child]) => {
      if (!child)
        return void 0;
      const ref = linkRef(this, key);
      return K(childFactory(child), { ref, key });
    }).filter(Boolean);
    return _(component, props, childrenToRender);
  }
};
TransitionGroup.defaultProps = {
  component: "span",
  childFactory: identity
};
var TransitionGroup_default = TransitionGroup;

// node_modules/@uppy/informer/lib/Informer.js
var Informer = class extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, opts);
    __publicField(this, "render", (state) => {
      return u("div", { className: "uppy uppy-Informer", children: u(TransitionGroup_default, { children: state.info.map((info) => u(FadeIn, { children: u("p", { role: "alert", children: [info.message, " ", info.details && // biome-ignore lint/a11y/useKeyWithClickEvents: ...
      u("span", { "aria-label": info.details, "data-microtip-position": "top-left", "data-microtip-size": "medium", role: "tooltip", onClick: () => alert(`${info.message} 

 ${info.details}`), children: "?" })] }) }, info.message)) }) });
    });
    this.type = "progressindicator";
    this.id = this.opts.id || "Informer";
    this.title = "Informer";
  }
  install() {
    const { target } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
};
__publicField(Informer, "VERSION", package_default.version);

// node_modules/@uppy/provider-views/lib/ProviderView/AuthView.js
function GoogleIcon() {
  return u("svg", { width: "26", height: "26", viewBox: "0 0 26 26", xmlns: "http://www.w3.org/2000/svg", children: u("g", { fill: "none", "fill-rule": "evenodd", children: [u("circle", { fill: "#FFF", cx: "13", cy: "13", r: "13" }), u("path", { d: "M21.64 13.205c0-.639-.057-1.252-.164-1.841H13v3.481h4.844a4.14 4.14 0 01-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z", fill: "#4285F4", "fill-rule": "nonzero" }), u("path", { d: "M13 22c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H4.957v2.332A8.997 8.997 0 0013 22z", fill: "#34A853", "fill-rule": "nonzero" }), u("path", { d: "M7.964 14.71A5.41 5.41 0 017.682 13c0-.593.102-1.17.282-1.71V8.958H4.957A8.996 8.996 0 004 13c0 1.452.348 2.827.957 4.042l3.007-2.332z", fill: "#FBBC05", "fill-rule": "nonzero" }), u("path", { d: "M13 7.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C17.463 4.891 15.426 4 13 4a8.997 8.997 0 00-8.043 4.958l3.007 2.332C8.672 9.163 10.656 7.58 13 7.58z", fill: "#EA4335", "fill-rule": "nonzero" }), u("path", { d: "M4 4h18v18H4z" })] }) });
}
function DefaultForm({ pluginName, i18n, onAuth }) {
  const isGoogleDrive = pluginName === "Google Drive";
  const onSubmit = q((e2) => {
    e2.preventDefault();
    onAuth();
  }, [onAuth]);
  return u("form", { onSubmit, children: isGoogleDrive ? u("button", { type: "submit", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn uppy-Provider-btn-google", "data-uppy-super-focusable": true, children: [u(GoogleIcon, {}), i18n("signInWithGoogle")] }) : u("button", { type: "submit", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn", "data-uppy-super-focusable": true, children: i18n("authenticateWith", { pluginName }) }) });
}
var defaultRenderForm = ({ pluginName, i18n, onAuth }) => u(DefaultForm, { pluginName, i18n, onAuth });
function AuthView({ loading, pluginName, pluginIcon, i18n, handleAuth, renderForm = defaultRenderForm }) {
  return u("div", { className: "uppy-Provider-auth", children: [u("div", { className: "uppy-Provider-authIcon", children: pluginIcon() }), u("div", { className: "uppy-Provider-authTitle", children: i18n("authenticateWithTitle", {
    pluginName
  }) }), renderForm({ pluginName, i18n, loading, onAuth: handleAuth })] });
}

// node_modules/@uppy/utils/lib/remoteFileObjToLocal.js
function remoteFileObjToLocal(file) {
  return {
    ...file,
    type: file.mimeType,
    extension: file.name ? getFileNameAndExtension(file.name).extension : null
  };
}

// node_modules/@uppy/provider-views/lib/ProviderView/ProviderView.js
var import_classnames4 = __toESM(require_classnames(), 1);

// node_modules/@uppy/provider-views/package.json
var package_default2 = {
  name: "@uppy/provider-views",
  description: "View library for Uppy remote provider plugins.",
  version: "4.5.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build",
    test: "vitest run --environment=jsdom --silent='passed-only'"
  },
  keywords: [
    "file uploader",
    "uppy"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    classnames: "^2.2.6",
    nanoid: "^5.0.9",
    "p-queue": "^8.0.0",
    preact: "^10.5.13"
  },
  devDependencies: {
    "@types/gapi": "^0.0.47",
    "@types/google.accounts": "^0.0.14",
    "@types/google.picker": "^0.0.42",
    cssnano: "^7.0.7",
    jsdom: "^26.1.0",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3",
    vitest: "^3.2.4"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  }
};

// node_modules/@uppy/utils/lib/VirtualList.js
var STYLE_INNER = {
  position: "relative",
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: "100%",
  minHeight: "100%"
};
var STYLE_CONTENT = {
  position: "absolute",
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: "100%",
  overflow: "visible"
};
var VirtualList = class extends x {
  constructor(props) {
    super(props);
    __publicField(this, "handleScroll", () => {
      this.setState({ offset: this.base.scrollTop });
    });
    __publicField(this, "handleResize", () => {
      this.resize();
    });
    this.focusElement = null;
    this.state = {
      offset: 0,
      height: 0
    };
  }
  componentDidMount() {
    this.resize();
    window.addEventListener("resize", this.handleResize);
  }
  // TODO: refactor to stable lifecycle method
  componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  }
  componentDidUpdate() {
    var _a;
    if (((_a = this.focusElement) == null ? void 0 : _a.parentNode) && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }
    this.focusElement = null;
    this.resize();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleResize);
  }
  resize() {
    const { height } = this.state;
    if (height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  }
  render({ data, rowHeight, renderRow, overscanCount = 10, ...props }) {
    const { offset, height } = this.state;
    let start = Math.floor(offset / rowHeight);
    let visibleRowCount = Math.floor(height / rowHeight);
    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    }
    const end = start + visibleRowCount + 4;
    const selection = data.slice(start, end);
    const styleInner = { ...STYLE_INNER, height: data.length * rowHeight };
    const styleContent = { ...STYLE_CONTENT, top: start * rowHeight };
    return u("div", { onScroll: this.handleScroll, ...props, children: u("div", { role: "presentation", style: styleInner, children: u("div", { role: "presentation", style: styleContent, children: selection.map(renderRow) }) }) });
  }
};
var VirtualList_default = VirtualList;

// node_modules/@uppy/provider-views/lib/Item/index.js
var import_classnames = __toESM(require_classnames(), 1);

// node_modules/@uppy/provider-views/lib/Item/components/ItemIcon.js
function FileIcon() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: 11, height: 14.5, viewBox: "0 0 44 58", children: u("path", { d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z" }) });
}
function FolderIcon() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", style: { minWidth: 16, marginRight: 3 }, viewBox: "0 0 276.157 276.157", children: u("path", { d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z" }) });
}
function VideoIcon() {
  return u("svg", { "aria-hidden": "true", focusable: "false", style: { width: 16, marginRight: 4 }, viewBox: "0 0 58 58", children: [u("path", { d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z" }), u("path", { d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z" })] });
}
function ItemIcon({ itemIconString, alt = void 0 }) {
  if (itemIconString === null)
    return null;
  switch (itemIconString) {
    case "file":
      return u(FileIcon, {});
    case "folder":
      return u(FolderIcon, {});
    case "video":
      return u(VideoIcon, {});
    default: {
      return u("img", { src: itemIconString, alt, referrerPolicy: "no-referrer", loading: "lazy", width: 16, height: 16 });
    }
  }
}

// node_modules/@uppy/provider-views/lib/Item/components/GridItem.js
function GridItem({ file, toggleCheckbox, className, isDisabled, restrictionError, showTitles, children = null, i18n }) {
  return u("li", { className, title: isDisabled && restrictionError ? restrictionError : void 0, children: [u("input", { type: "checkbox", className: "uppy-u-reset uppy-ProviderBrowserItem-checkbox uppy-ProviderBrowserItem-checkbox--grid", onChange: toggleCheckbox, name: "listitem", id: file.id, checked: file.status === "checked", disabled: isDisabled, "data-uppy-super-focusable": true }), u("label", { htmlFor: file.id, "aria-label": file.data.name ?? i18n("unnamed"), className: "uppy-u-reset uppy-ProviderBrowserItem-inner", children: [u(ItemIcon, { itemIconString: file.data.thumbnail || file.data.icon }), showTitles && (file.data.name ?? i18n("unnamed")), children] })] });
}
var GridItem_default = GridItem;

// node_modules/@uppy/provider-views/lib/Item/components/ListItem.js
function ListItem({ file, openFolder, className, isDisabled, restrictionError, toggleCheckbox, showTitles, i18n }) {
  return u("li", { className, title: file.status !== "checked" && restrictionError ? restrictionError : void 0, children: [u("input", {
    type: "checkbox",
    className: "uppy-u-reset uppy-ProviderBrowserItem-checkbox",
    onChange: toggleCheckbox,
    // for the <label/>
    name: "listitem",
    id: file.id,
    checked: file.status === "checked",
    "aria-label": file.data.isFolder ? i18n("allFilesFromFolderNamed", {
      name: file.data.name ?? i18n("unnamed")
    }) : null,
    disabled: isDisabled,
    "data-uppy-super-focusable": true
  }), file.data.isFolder ? (
    // button to open a folder
    u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowserItem-inner", onClick: () => openFolder(file.id), "aria-label": i18n("openFolderNamed", {
      name: file.data.name ?? i18n("unnamed")
    }), children: [u("div", { className: "uppy-ProviderBrowserItem-iconWrap", children: u(ItemIcon, { itemIconString: file.data.icon }) }), showTitles && file.data.name ? u("span", { children: file.data.name }) : i18n("unnamed")] })
  ) : (
    // label for a checkbox
    u("label", { htmlFor: file.id, className: "uppy-u-reset uppy-ProviderBrowserItem-inner", children: [u("div", { className: "uppy-ProviderBrowserItem-iconWrap", children: u(ItemIcon, { itemIconString: file.data.icon }) }), showTitles && (file.data.name ?? i18n("unnamed"))] })
  )] });
}

// node_modules/@uppy/provider-views/lib/Item/index.js
function Item(props) {
  const { viewType, toggleCheckbox, showTitles, i18n, openFolder, file, utmSource } = props;
  const restrictionError = file.type === "folder" ? null : file.restrictionError;
  const isDisabled = !!restrictionError && file.status !== "checked";
  const ourProps = {
    file,
    openFolder,
    toggleCheckbox,
    utmSource,
    i18n,
    viewType,
    showTitles,
    className: (0, import_classnames.default)("uppy-ProviderBrowserItem", { "uppy-ProviderBrowserItem--disabled": isDisabled }, { "uppy-ProviderBrowserItem--noPreview": file.data.icon === "video" }, { "uppy-ProviderBrowserItem--is-checked": file.status === "checked" }, { "uppy-ProviderBrowserItem--is-partial": file.status === "partial" }),
    isDisabled,
    restrictionError
  };
  switch (viewType) {
    case "grid":
      return u(GridItem_default, { ...ourProps });
    case "list":
      return u(ListItem, { ...ourProps });
    case "unsplash":
      return u(GridItem_default, { ...ourProps, children: u("a", { href: `${file.data.author.url}?utm_source=${utmSource}&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer", className: "uppy-ProviderBrowserItem-author", tabIndex: -1, children: file.data.author.name }) });
    default:
      throw new Error(`There is no such type ${viewType}`);
  }
}

// node_modules/@uppy/provider-views/lib/Browser.js
function Browser(props) {
  const { displayedPartialTree, viewType, toggleCheckbox, handleScroll, showTitles, i18n, isLoading, openFolder, noResultsLabel, virtualList, utmSource } = props;
  const [isShiftKeyPressed, setIsShiftKeyPressed] = d(false);
  y(() => {
    const handleKeyUp = (e2) => {
      if (e2.key === "Shift")
        setIsShiftKeyPressed(false);
    };
    const handleKeyDown = (e2) => {
      if (e2.key === "Shift")
        setIsShiftKeyPressed(true);
    };
    document.addEventListener("keyup", handleKeyUp);
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keyup", handleKeyUp);
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  if (isLoading) {
    return u("div", { className: "uppy-Provider-loading", children: typeof isLoading === "string" ? isLoading : i18n("loading") });
  }
  if (displayedPartialTree.length === 0) {
    return u("div", { className: "uppy-Provider-empty", children: noResultsLabel });
  }
  const renderItem = (item) => u(Item, { viewType, toggleCheckbox: (event) => {
    var _a;
    event.stopPropagation();
    event.preventDefault();
    (_a = document.getSelection()) == null ? void 0 : _a.removeAllRanges();
    toggleCheckbox(item, isShiftKeyPressed);
  }, showTitles, i18n, openFolder, file: item, utmSource });
  if (virtualList) {
    return u("div", { className: "uppy-ProviderBrowser-body", children: u("ul", { className: "uppy-ProviderBrowser-list", children: u(VirtualList_default, { data: displayedPartialTree, renderRow: renderItem, rowHeight: 31 }) }) });
  }
  return u("div", { className: "uppy-ProviderBrowser-body", children: u("ul", {
    className: "uppy-ProviderBrowser-list",
    onScroll: handleScroll,
    // making <ul> not focusable for firefox
    tabIndex: -1,
    children: displayedPartialTree.map(renderItem)
  }) });
}
var Browser_default = Browser;

// node_modules/@uppy/provider-views/lib/FooterActions.js
var import_classnames2 = __toESM(require_classnames(), 1);

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/getNumberOfSelectedFiles.js
var getNumberOfSelectedFiles = (partialTree) => {
  const checkedLeaves = partialTree.filter((item) => {
    if (item.type === "file" && item.status === "checked") {
      return true;
    }
    if (item.type === "folder" && item.status === "checked") {
      const doesItHaveChildren = partialTree.some((i3) => i3.type !== "root" && i3.parentId === item.id);
      return !doesItHaveChildren;
    }
    return false;
  });
  return checkedLeaves.length;
};
var getNumberOfSelectedFiles_default = getNumberOfSelectedFiles;

// node_modules/@uppy/provider-views/lib/FooterActions.js
function FooterActions({ cancelSelection, donePicking, i18n, partialTree, validateAggregateRestrictions }) {
  const aggregateRestrictionError = T(() => {
    return validateAggregateRestrictions(partialTree);
  }, [partialTree, validateAggregateRestrictions]);
  const nOfSelectedFiles = T(() => {
    return getNumberOfSelectedFiles_default(partialTree);
  }, [partialTree]);
  if (nOfSelectedFiles === 0) {
    return null;
  }
  return u("div", { className: "uppy-ProviderBrowser-footer", children: [u("div", { className: "uppy-ProviderBrowser-footer-buttons", children: [u("button", { className: (0, import_classnames2.default)("uppy-u-reset uppy-c-btn uppy-c-btn-primary", {
    "uppy-c-btn--disabled": aggregateRestrictionError
  }), disabled: !!aggregateRestrictionError, onClick: donePicking, type: "button", children: i18n("selectX", {
    smart_count: nOfSelectedFiles
  }) }), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link", onClick: cancelSelection, type: "button", children: i18n("cancel") })] }), aggregateRestrictionError && u("div", { className: "uppy-ProviderBrowser-footer-error", children: aggregateRestrictionError })] });
}

// node_modules/@uppy/provider-views/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size = 21) => {
  let id = "";
  let i3 = size | 0;
  while (i3--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// node_modules/@uppy/provider-views/lib/SearchInput.js
function SearchInput({ searchString, setSearchString, submitSearchString, wrapperClassName, inputClassName, inputLabel, clearSearchLabel = "", showButton = false, buttonLabel = "", buttonCSSClassName = "" }) {
  const onInput = (e2) => {
    setSearchString(e2.target.value);
  };
  const submit = q((ev) => {
    ev.preventDefault();
    submitSearchString();
  }, [submitSearchString]);
  const [form] = d(() => {
    const formEl = document.createElement("form");
    formEl.setAttribute("tabindex", "-1");
    formEl.id = nanoid();
    return formEl;
  });
  y(() => {
    document.body.appendChild(form);
    form.addEventListener("submit", submit);
    return () => {
      form.removeEventListener("submit", submit);
      document.body.removeChild(form);
    };
  }, [form, submit]);
  return u("section", { className: wrapperClassName, children: [u("input", { className: `uppy-u-reset ${inputClassName}`, type: "search", "aria-label": inputLabel, placeholder: inputLabel, value: searchString, onInput, form: form.id, "data-uppy-super-focusable": true }), !showButton && // 🔍
  u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-ProviderBrowser-searchFilterIcon", width: "12", height: "12", viewBox: "0 0 12 12", children: u("path", { d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z" }) }), !showButton && searchString && // ❌
  u("button", { className: "uppy-u-reset uppy-ProviderBrowser-searchFilterReset", type: "button", "aria-label": clearSearchLabel, title: clearSearchLabel, onClick: () => setSearchString(""), children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", viewBox: "0 0 19 19", children: u("path", { d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z" }) }) }), showButton && u("button", { className: `uppy-u-reset uppy-c-btn uppy-c-btn-primary ${buttonCSSClassName}`, type: "submit", form: form.id, children: buttonLabel })] });
}
var SearchInput_default = SearchInput;

// node_modules/@uppy/provider-views/lib/utils/getTagFile.js
var getTagFile = (file, plugin, provider) => {
  var _a, _b;
  const tagFile = {
    id: file.id,
    source: plugin.id,
    name: file.name || file.id,
    type: file.mimeType,
    isRemote: true,
    data: file,
    preview: file.thumbnail || void 0,
    meta: {
      authorName: (_a = file.author) == null ? void 0 : _a.name,
      authorUrl: (_b = file.author) == null ? void 0 : _b.url,
      // We need to do this `|| null` check, because null value
      // for .relDirPath is `undefined` and for .relativePath is `null`.
      // I do think we should just use `null` everywhere.
      relativePath: file.relDirPath || null,
      absolutePath: file.absDirPath
    },
    body: {
      fileId: file.id
    },
    remote: {
      companionUrl: plugin.opts.companionUrl,
      url: `${provider.fileUrl(file.requestPath)}`,
      body: {
        fileId: file.id
      },
      providerName: provider.name,
      provider: provider.provider,
      requestClientId: provider.provider
    }
  };
  return tagFile;
};
var getTagFile_default = getTagFile;

// node_modules/@uppy/provider-views/lib/utils/addFiles.js
var addFiles = (companionFiles, plugin, provider) => {
  const tagFiles = companionFiles.map((f3) => getTagFile_default(f3, plugin, provider));
  const filesToAdd = [];
  const filesAlreadyAdded = [];
  tagFiles.forEach((tagFile) => {
    if (plugin.uppy.checkIfFileAlreadyExists(getSafeFileId(tagFile, plugin.uppy.getID()))) {
      filesAlreadyAdded.push(tagFile);
    } else {
      filesToAdd.push(tagFile);
    }
  });
  if (filesToAdd.length > 0) {
    plugin.uppy.info(plugin.uppy.i18n("addedNumFiles", { numFiles: filesToAdd.length }));
  }
  if (filesAlreadyAdded.length > 0) {
    plugin.uppy.info(`Not adding ${filesAlreadyAdded.length} files because they already exist`);
  }
  plugin.uppy.addFiles(filesToAdd);
};
var addFiles_default = addFiles;

// node_modules/@uppy/provider-views/lib/utils/getClickedRange.js
var getClickedRange = (clickedId, displayedPartialTree, isShiftKeyPressed, lastCheckbox) => {
  const lastCheckboxIndex = displayedPartialTree.findIndex((item) => item.id === lastCheckbox);
  if (lastCheckboxIndex !== -1 && isShiftKeyPressed) {
    const newCheckboxIndex = displayedPartialTree.findIndex((item) => item.id === clickedId);
    const clickedRange = displayedPartialTree.slice(Math.min(lastCheckboxIndex, newCheckboxIndex), Math.max(lastCheckboxIndex, newCheckboxIndex) + 1);
    return clickedRange.map((item) => item.id);
  }
  return [clickedId];
};
var getClickedRange_default = getClickedRange;

// node_modules/@uppy/provider-views/lib/utils/handleError.js
var handleError = (uppy) => (error) => {
  if (error.isAuthError) {
    return;
  }
  if (error.name === "AbortError") {
    uppy.log("Aborting request", "warning");
    return;
  }
  uppy.log(error, "error");
  if (error.name === "UserFacingApiError") {
    uppy.info({
      message: uppy.i18n("companionError"),
      details: uppy.i18n(error.message)
    }, "warning", 5e3);
  }
};
var handleError_default = handleError;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/getBreadcrumbs.js
var getBreadcrumbs = (partialTree, currentFolderId) => {
  let folder = partialTree.find((f3) => f3.id === currentFolderId);
  let breadcrumbs = [];
  while (true) {
    breadcrumbs = [folder, ...breadcrumbs];
    if (folder.type === "root")
      break;
    const currentParentId = folder.parentId;
    folder = partialTree.find((f3) => f3.id === currentParentId);
  }
  return breadcrumbs;
};
var getBreadcrumbs_default = getBreadcrumbs;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/getCheckedFilesWithPaths.js
var getPath = (partialTree, id, cache) => {
  const sId = id === null ? "null" : id;
  if (cache[sId])
    return cache[sId];
  const file = partialTree.find((f3) => f3.id === id);
  if (file.type === "root")
    return [];
  const meAndParentPath = [...getPath(partialTree, file.parentId, cache), file];
  cache[sId] = meAndParentPath;
  return meAndParentPath;
};
var getCheckedFilesWithPaths = (partialTree) => {
  const cache = /* @__PURE__ */ Object.create(null);
  const checkedFiles = partialTree.filter((item) => item.type === "file" && item.status === "checked");
  const companionFilesWithInjectedPaths = checkedFiles.map((file) => {
    const absFolders = getPath(partialTree, file.id, cache);
    const firstCheckedFolderIndex = absFolders.findIndex((i3) => i3.type === "folder" && i3.status === "checked");
    const relFolders = absFolders.slice(firstCheckedFolderIndex);
    const absDirPath = `/${absFolders.map((i3) => i3.data.name).join("/")}`;
    const relDirPath = relFolders.length === 1 ? (
      // Must return `undefined` (which later turns into `null` in `.getTagFile()`)
      // (https://github.com/transloadit/uppy/pull/4537#issuecomment-1629136652)
      void 0
    ) : relFolders.map((i3) => i3.data.name).join("/");
    return {
      ...file.data,
      absDirPath,
      relDirPath
    };
  });
  return companionFilesWithInjectedPaths;
};
var getCheckedFilesWithPaths_default = getCheckedFilesWithPaths;

// node_modules/p-queue/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      abortHandler = () => {
        reject(getAbortedReason(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && options.signal) {
      options.signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      id: options.id,
      run
    };
    if (this.size === 0 || __privateGet(this, _queue)[this.size - 1].priority >= options.priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound(__privateGet(this, _queue), element, (a2, b3) => b3.priority - a2.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = __privateGet(this, _queue).findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = __privateGet(this, _queue).splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// node_modules/p-queue/dist/index.js
var _carryoverConcurrencyCount, _isIntervalIgnored, _intervalCount, _intervalCap, _interval, _intervalEnd, _intervalId, _timeoutId, _queue2, _queueClass, _pending, _concurrency, _isPaused, _throwOnTimeout, _idAssigner, _PQueue_instances, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPaused_get, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, throwOnAbort_fn, onEvent_fn;
var PQueue = class extends import_index.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b;
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverConcurrencyCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _queue2);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    __privateAdd(this, _throwOnTimeout);
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    __privateAdd(this, _idAssigner, 1n);
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    __publicField(this, "timeout");
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((_a = options.intervalCap) == null ? void 0 : _a.toString()) ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((_b = options.interval) == null ? void 0 : _b.toString()) ?? ""}\` (${typeof options.interval})`);
    }
    __privateSet(this, _carryoverConcurrencyCount, options.carryoverConcurrencyCount);
    __privateSet(this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
    __privateSet(this, _intervalCap, options.intervalCap);
    __privateSet(this, _interval, options.interval);
    __privateSet(this, _queue2, new options.queueClass());
    __privateSet(this, _queueClass, options.queueClass);
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __privateSet(this, _throwOnTimeout, options.throwOnTimeout === true);
    __privateSet(this, _isPaused, options.autoStart === false);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 0, id: '🦀'});
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦄', {priority: 1});
  
      queue.setPriority('🦀', 2);
      ```
  
      In this case, the promise function with `id: '🦀'` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 1, id: '🦀'});
      queue.add(async () => '🦄');
      queue.add(async () => '🦄', {priority: 0});
  
      queue.setPriority('🦀', -1);
      ```
      Here, the promise function with `id: '🦀'` executes last.
      */
  setPriority(id, priority) {
    __privateGet(this, _queue2).setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ?? (options.id = (__privateWrapper(this, _idAssigner)._++).toString());
    options = {
      timeout: this.timeout,
      throwOnTimeout: __privateGet(this, _throwOnTimeout),
      ...options
    };
    return new Promise((resolve, reject) => {
      __privateGet(this, _queue2).enqueue(async () => {
        var _a;
        __privateWrapper(this, _pending)._++;
        __privateWrapper(this, _intervalCount)._++;
        try {
          (_a = options.signal) == null ? void 0 : _a.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, __privateMethod(this, _PQueue_instances, throwOnAbort_fn).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __privateMethod(this, _PQueue_instances, next_fn).call(this);
        }
      }, options);
      this.emit("add");
      __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue2).size < limit) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __privateGet(this, _queue2).filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
};
_carryoverConcurrencyCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_throwOnTimeout = new WeakMap();
_idAssigner = new WeakMap();
_PQueue_instances = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay = __privateGet(this, _intervalEnd) - now;
    if (delay < 0) {
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
    } else {
      if (__privateGet(this, _timeoutId) === void 0) {
        __privateSet(this, _timeoutId, setTimeout(() => {
          __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
        }, delay));
      }
      return true;
    }
  }
  return false;
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    if (__privateGet(this, _intervalId)) {
      clearInterval(__privateGet(this, _intervalId));
    }
    __privateSet(this, _intervalId, void 0);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _PQueue_instances, isIntervalPaused_get);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      return true;
    }
  }
  return false;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
throwOnAbort_fn = async function(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(signal.reason);
    }, { once: true });
  });
};
onEvent_fn = async function(event, filter) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter && !filter()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/shallowClone.js
var shallowClone = (partialTree) => {
  return partialTree.map((item) => ({ ...item }));
};
var shallowClone_default = shallowClone;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/afterFill.js
var recursivelyFetch = async (queue, poorTree, poorFolder, apiList, validateSingleFile) => {
  let items = [];
  let currentPath = poorFolder.cached ? poorFolder.nextPagePath : poorFolder.id;
  while (currentPath) {
    const response = await apiList(currentPath);
    items = items.concat(response.items);
    currentPath = response.nextPagePath;
  }
  const newFolders = items.filter((i3) => i3.isFolder === true);
  const newFiles = items.filter((i3) => i3.isFolder === false);
  const folders = newFolders.map((folder) => ({
    type: "folder",
    id: folder.requestPath,
    cached: false,
    nextPagePath: null,
    status: "checked",
    parentId: poorFolder.id,
    data: folder
  }));
  const files = newFiles.map((file) => {
    const restrictionError = validateSingleFile(file);
    return {
      type: "file",
      id: file.requestPath,
      restrictionError,
      status: restrictionError ? "unchecked" : "checked",
      parentId: poorFolder.id,
      data: file
    };
  });
  poorFolder.cached = true;
  poorFolder.nextPagePath = null;
  poorTree.push(...files, ...folders);
  folders.forEach(async (folder) => {
    queue.add(() => recursivelyFetch(queue, poorTree, folder, apiList, validateSingleFile));
  });
};
var afterFill = async (partialTree, apiList, validateSingleFile, reportProgress) => {
  const queue = new PQueue({ concurrency: 6 });
  const poorTree = shallowClone_default(partialTree);
  const poorFolders = poorTree.filter((item) => item.type === "folder" && item.status === "checked" && // either "not yet cached at all" or "some pages are left to fetch"
  (item.cached === false || item.nextPagePath));
  poorFolders.forEach((poorFolder) => {
    queue.add(() => recursivelyFetch(queue, poorTree, poorFolder, apiList, validateSingleFile));
  });
  queue.on("completed", () => {
    const nOfFilesChecked = poorTree.filter((i3) => i3.type === "file" && i3.status === "checked").length;
    reportProgress(nOfFilesChecked);
  });
  await queue.onIdle();
  return poorTree;
};
var afterFill_default = afterFill;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/afterOpenFolder.js
var afterOpenFolder = (oldPartialTree, discoveredItems, clickedFolder, currentPagePath, validateSingleFile) => {
  const discoveredFolders = discoveredItems.filter((i3) => i3.isFolder === true);
  const discoveredFiles = discoveredItems.filter((i3) => i3.isFolder === false);
  const isParentFolderChecked = clickedFolder.type === "folder" && clickedFolder.status === "checked";
  const folders = discoveredFolders.map((folder) => ({
    type: "folder",
    id: folder.requestPath,
    cached: false,
    nextPagePath: null,
    status: isParentFolderChecked ? "checked" : "unchecked",
    parentId: clickedFolder.id,
    data: folder
  }));
  const files = discoveredFiles.map((file) => {
    const restrictionError = validateSingleFile(file);
    return {
      type: "file",
      id: file.requestPath,
      restrictionError,
      status: isParentFolderChecked && !restrictionError ? "checked" : "unchecked",
      parentId: clickedFolder.id,
      data: file
    };
  });
  const updatedClickedFolder = {
    ...clickedFolder,
    cached: true,
    nextPagePath: currentPagePath
  };
  const partialTreeWithUpdatedClickedFolder = oldPartialTree.map((folder) => folder.id === updatedClickedFolder.id ? updatedClickedFolder : folder);
  const newPartialTree = [
    ...partialTreeWithUpdatedClickedFolder,
    ...folders,
    ...files
  ];
  return newPartialTree;
};
var afterOpenFolder_default = afterOpenFolder;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/afterScrollFolder.js
var afterScrollFolder = (oldPartialTree, currentFolderId, items, nextPagePath, validateSingleFile) => {
  const currentFolder = oldPartialTree.find((i3) => i3.id === currentFolderId);
  const newFolders = items.filter((i3) => i3.isFolder === true);
  const newFiles = items.filter((i3) => i3.isFolder === false);
  const scrolledFolder = { ...currentFolder, nextPagePath };
  const partialTreeWithUpdatedScrolledFolder = oldPartialTree.map((folder) => folder.id === scrolledFolder.id ? scrolledFolder : folder);
  const isParentFolderChecked = scrolledFolder.type === "folder" && scrolledFolder.status === "checked";
  const folders = newFolders.map((folder) => ({
    type: "folder",
    id: folder.requestPath,
    cached: false,
    nextPagePath: null,
    status: isParentFolderChecked ? "checked" : "unchecked",
    parentId: scrolledFolder.id,
    data: folder
  }));
  const files = newFiles.map((file) => {
    const restrictionError = validateSingleFile(file);
    return {
      type: "file",
      id: file.requestPath,
      restrictionError,
      status: isParentFolderChecked && !restrictionError ? "checked" : "unchecked",
      parentId: scrolledFolder.id,
      data: file
    };
  });
  const newPartialTree = [
    ...partialTreeWithUpdatedScrolledFolder,
    ...folders,
    ...files
  ];
  return newPartialTree;
};
var afterScrollFolder_default = afterScrollFolder;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/afterToggleCheckbox.js
var percolateDown = (tree, id, shouldMarkAsChecked) => {
  const children = tree.filter((item) => item.type !== "root" && item.parentId === id);
  children.forEach((item) => {
    item.status = shouldMarkAsChecked && !(item.type === "file" && item.restrictionError) ? "checked" : "unchecked";
    percolateDown(tree, item.id, shouldMarkAsChecked);
  });
};
var percolateUp = (tree, id) => {
  const folder = tree.find((item) => item.id === id);
  if (folder.type === "root")
    return;
  const validChildren = tree.filter((item) => (
    // is a child
    item.type !== "root" && item.parentId === folder.id && // does pass validations
    !(item.type === "file" && item.restrictionError)
  ));
  const areAllChildrenChecked = validChildren.every((item) => item.status === "checked");
  const areAllChildrenUnchecked = validChildren.every((item) => item.status === "unchecked");
  if (areAllChildrenChecked) {
    folder.status = "checked";
  } else if (areAllChildrenUnchecked) {
    folder.status = "unchecked";
  } else {
    folder.status = "partial";
  }
  percolateUp(tree, folder.parentId);
};
var afterToggleCheckbox = (oldTree, clickedRange) => {
  const tree = shallowClone_default(oldTree);
  if (clickedRange.length >= 2) {
    const newlyCheckedItems = tree.filter((item) => item.type !== "root" && clickedRange.includes(item.id));
    newlyCheckedItems.forEach((item) => {
      if (item.type === "file") {
        item.status = item.restrictionError ? "unchecked" : "checked";
      } else {
        item.status = "checked";
      }
    });
    newlyCheckedItems.forEach((item) => {
      percolateDown(tree, item.id, true);
    });
    percolateUp(tree, newlyCheckedItems[0].parentId);
  } else {
    const clickedItem = tree.find((item) => item.id === clickedRange[0]);
    clickedItem.status = clickedItem.status === "checked" ? "unchecked" : "checked";
    percolateDown(tree, clickedItem.id, clickedItem.status === "checked");
    percolateUp(tree, clickedItem.parentId);
  }
  return tree;
};
var afterToggleCheckbox_default = afterToggleCheckbox;

// node_modules/@uppy/provider-views/lib/utils/PartialTreeUtils/index.js
var PartialTreeUtils_default = {
  afterOpenFolder: afterOpenFolder_default,
  afterScrollFolder: afterScrollFolder_default,
  afterToggleCheckbox: afterToggleCheckbox_default,
  afterFill: afterFill_default
};

// node_modules/@uppy/provider-views/lib/utils/shouldHandleScroll.js
var shouldHandleScroll = (event) => {
  const { scrollHeight, scrollTop, offsetHeight } = event.target;
  const scrollPosition = scrollHeight - (scrollTop + offsetHeight);
  return scrollPosition < 50;
};
var shouldHandleScroll_default = shouldHandleScroll;

// node_modules/@uppy/provider-views/lib/ProviderView/Header.js
var import_classnames3 = __toESM(require_classnames(), 1);

// node_modules/@uppy/provider-views/lib/Breadcrumbs.js
function Breadcrumbs(props) {
  const { openFolder, title, breadcrumbsIcon, breadcrumbs, i18n } = props;
  return u("div", { className: "uppy-Provider-breadcrumbs", children: [u("div", { className: "uppy-Provider-breadcrumbsIcon", children: breadcrumbsIcon }), breadcrumbs.map((folder, index) => u(k, { children: [u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", onClick: () => openFolder(folder.id), children: folder.type === "root" ? title : folder.data.name ?? i18n("unnamed") }, folder.id), breadcrumbs.length === index + 1 ? "" : " / "] }))] });
}

// node_modules/@uppy/provider-views/lib/ProviderView/User.js
function User({ i18n, logout: logout2, username }) {
  return u(k, { children: [username && u("span", { className: "uppy-ProviderBrowser-user", children: username }, "username"), u("button", { type: "button", onClick: logout2, className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowser-userLogout", children: i18n("logOut") }, "logout")] });
}

// node_modules/@uppy/provider-views/lib/ProviderView/Header.js
function Header(props) {
  var _a;
  return u("div", { className: "uppy-ProviderBrowser-header", children: u("div", { className: (0, import_classnames3.default)("uppy-ProviderBrowser-headerBar", !props.showBreadcrumbs && "uppy-ProviderBrowser-headerBar--simple"), children: [props.showBreadcrumbs && u(Breadcrumbs, { openFolder: props.openFolder, breadcrumbs: props.breadcrumbs, breadcrumbsIcon: (_a = props.pluginIcon) == null ? void 0 : _a.call(props), title: props.title, i18n: props.i18n }), u(User, { logout: props.logout, username: props.username, i18n: props.i18n })] }) });
}

// node_modules/@uppy/provider-views/lib/ProviderView/ProviderView.js
function defaultPickerIcon() {
  return u("svg", { "aria-hidden": "true", focusable: "false", width: "30", height: "30", viewBox: "0 0 30 30", children: u("path", { d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z" }) });
}
var getDefaultState = (rootFolderId) => ({
  authenticated: void 0,
  // we don't know yet
  partialTree: [
    {
      type: "root",
      id: rootFolderId,
      cached: false,
      nextPagePath: null
    }
  ],
  currentFolderId: rootFolderId,
  searchString: "",
  didFirstRender: false,
  username: null,
  loading: false
});
var _abortController, _ProviderView_instances, withAbort_fn;
var ProviderView = class {
  constructor(plugin, opts) {
    __privateAdd(this, _ProviderView_instances);
    __publicField(this, "plugin");
    __publicField(this, "provider");
    __publicField(this, "opts");
    __publicField(this, "isHandlingScroll", false);
    __publicField(this, "lastCheckbox", null);
    __privateAdd(this, _abortController);
    __publicField(this, "validateSingleFile", (file) => {
      const companionFile = remoteFileObjToLocal(file);
      const result = this.plugin.uppy.validateSingleFile(companionFile);
      return result;
    });
    __publicField(this, "getDisplayedPartialTree", () => {
      const { partialTree, currentFolderId, searchString } = this.plugin.getPluginState();
      const inThisFolder = partialTree.filter((item) => item.type !== "root" && item.parentId === currentFolderId);
      const filtered = searchString === "" ? inThisFolder : inThisFolder.filter((item) => (item.data.name ?? this.plugin.uppy.i18n("unnamed")).toLowerCase().indexOf(searchString.toLowerCase()) !== -1);
      return filtered;
    });
    __publicField(this, "getBreadcrumbs", () => {
      const { partialTree, currentFolderId } = this.plugin.getPluginState();
      return getBreadcrumbs_default(partialTree, currentFolderId);
    });
    __publicField(this, "getSelectedAmount", () => {
      const { partialTree } = this.plugin.getPluginState();
      return getNumberOfSelectedFiles_default(partialTree);
    });
    __publicField(this, "validateAggregateRestrictions", (partialTree) => {
      const checkedFiles = partialTree.filter((item) => item.type === "file" && item.status === "checked");
      const uppyFiles = checkedFiles.map((file) => file.data);
      return this.plugin.uppy.validateAggregateRestrictions(uppyFiles);
    });
    this.plugin = plugin;
    this.provider = opts.provider;
    const defaultOptions8 = {
      viewType: "list",
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true,
      loadAllFiles: false,
      virtualList: false
    };
    this.opts = { ...defaultOptions8, ...opts };
    this.openFolder = this.openFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.resetPluginState = this.resetPluginState.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.render = this.render.bind(this);
    this.cancelSelection = this.cancelSelection.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.resetPluginState();
    this.plugin.uppy.on("dashboard:close-panel", this.resetPluginState);
    this.plugin.uppy.registerRequestClient(this.provider.provider, this.provider);
  }
  resetPluginState() {
    this.plugin.setPluginState(getDefaultState(this.plugin.rootFolderId));
  }
  tearDown() {
  }
  setLoading(loading) {
    this.plugin.setPluginState({ loading });
  }
  cancelSelection() {
    const { partialTree } = this.plugin.getPluginState();
    const newPartialTree = partialTree.map((item) => item.type === "root" ? item : { ...item, status: "unchecked" });
    this.plugin.setPluginState({ partialTree: newPartialTree });
  }
  async openFolder(folderId) {
    this.lastCheckbox = null;
    const { partialTree } = this.plugin.getPluginState();
    const clickedFolder = partialTree.find((folder) => folder.id === folderId);
    if (clickedFolder.cached) {
      this.plugin.setPluginState({
        currentFolderId: folderId,
        searchString: ""
      });
      return;
    }
    this.setLoading(true);
    await __privateMethod(this, _ProviderView_instances, withAbort_fn).call(this, async (signal) => {
      let currentPagePath = folderId;
      let currentItems = [];
      do {
        const { username, nextPagePath, items } = await this.provider.list(currentPagePath, { signal });
        this.plugin.setPluginState({ username });
        currentPagePath = nextPagePath;
        currentItems = currentItems.concat(items);
        this.setLoading(this.plugin.uppy.i18n("loadedXFiles", {
          numFiles: currentItems.length
        }));
      } while (this.opts.loadAllFiles && currentPagePath);
      const newPartialTree = PartialTreeUtils_default.afterOpenFolder(partialTree, currentItems, clickedFolder, currentPagePath, this.validateSingleFile);
      this.plugin.setPluginState({
        partialTree: newPartialTree,
        currentFolderId: folderId,
        searchString: ""
      });
    }).catch(handleError_default(this.plugin.uppy));
    this.setLoading(false);
  }
  /**
   * Removes session token on client side.
   */
  async logout() {
    await __privateMethod(this, _ProviderView_instances, withAbort_fn).call(this, async (signal) => {
      const res = await this.provider.logout({
        signal
      });
      if (res.ok) {
        if (!res.revoked) {
          const message = this.plugin.uppy.i18n("companionUnauthorizeHint", {
            provider: this.plugin.title,
            url: res.manual_revoke_url
          });
          this.plugin.uppy.info(message, "info", 7e3);
        }
        this.plugin.setPluginState({
          ...getDefaultState(this.plugin.rootFolderId),
          authenticated: false
        });
      }
    }).catch(handleError_default(this.plugin.uppy));
  }
  async handleAuth(authFormData) {
    await __privateMethod(this, _ProviderView_instances, withAbort_fn).call(this, async (signal) => {
      this.setLoading(true);
      await this.provider.login({ authFormData, signal });
      this.plugin.setPluginState({ authenticated: true });
      await Promise.all([
        this.provider.fetchPreAuthToken(),
        this.openFolder(this.plugin.rootFolderId)
      ]);
    }).catch(handleError_default(this.plugin.uppy));
    this.setLoading(false);
  }
  async handleScroll(event) {
    const { partialTree, currentFolderId } = this.plugin.getPluginState();
    const currentFolder = partialTree.find((i3) => i3.id === currentFolderId);
    if (shouldHandleScroll_default(event) && !this.isHandlingScroll && currentFolder.nextPagePath) {
      this.isHandlingScroll = true;
      await __privateMethod(this, _ProviderView_instances, withAbort_fn).call(this, async (signal) => {
        const { nextPagePath, items } = await this.provider.list(currentFolder.nextPagePath, { signal });
        const newPartialTree = PartialTreeUtils_default.afterScrollFolder(partialTree, currentFolderId, items, nextPagePath, this.validateSingleFile);
        this.plugin.setPluginState({ partialTree: newPartialTree });
      }).catch(handleError_default(this.plugin.uppy));
      this.isHandlingScroll = false;
    }
  }
  async donePicking() {
    const { partialTree } = this.plugin.getPluginState();
    this.setLoading(true);
    await __privateMethod(this, _ProviderView_instances, withAbort_fn).call(this, async (signal) => {
      const enrichedTree = await PartialTreeUtils_default.afterFill(partialTree, (path) => this.provider.list(path, { signal }), this.validateSingleFile, (n2) => {
        this.setLoading(this.plugin.uppy.i18n("addedNumFiles", { numFiles: n2 }));
      });
      const aggregateRestrictionError = this.validateAggregateRestrictions(enrichedTree);
      if (aggregateRestrictionError) {
        this.plugin.setPluginState({ partialTree: enrichedTree });
        return;
      }
      const companionFiles = getCheckedFilesWithPaths_default(enrichedTree);
      addFiles_default(companionFiles, this.plugin, this.provider);
      this.resetPluginState();
    }).catch(handleError_default(this.plugin.uppy));
    this.setLoading(false);
  }
  toggleCheckbox(ourItem, isShiftKeyPressed) {
    const { partialTree } = this.plugin.getPluginState();
    const clickedRange = getClickedRange_default(ourItem.id, this.getDisplayedPartialTree(), isShiftKeyPressed, this.lastCheckbox);
    const newPartialTree = PartialTreeUtils_default.afterToggleCheckbox(partialTree, clickedRange);
    this.plugin.setPluginState({ partialTree: newPartialTree });
    this.lastCheckbox = ourItem.id;
  }
  render(state, viewOptions = {}) {
    const { didFirstRender } = this.plugin.getPluginState();
    const { i18n } = this.plugin.uppy;
    if (!didFirstRender) {
      this.plugin.setPluginState({ didFirstRender: true });
      this.provider.fetchPreAuthToken();
      this.openFolder(this.plugin.rootFolderId);
    }
    const opts = { ...this.opts, ...viewOptions };
    const { authenticated, loading } = this.plugin.getPluginState();
    const pluginIcon = this.plugin.icon || defaultPickerIcon;
    if (authenticated === false) {
      return u(AuthView, { pluginName: this.plugin.title, pluginIcon, handleAuth: this.handleAuth, i18n: this.plugin.uppy.i18n, renderForm: opts.renderAuthForm, loading });
    }
    const { partialTree, username, searchString } = this.plugin.getPluginState();
    const breadcrumbs = this.getBreadcrumbs();
    return u("div", { className: (0, import_classnames4.default)("uppy-ProviderBrowser", `uppy-ProviderBrowser-viewType--${opts.viewType}`), children: [u(Header, { showBreadcrumbs: opts.showBreadcrumbs, openFolder: this.openFolder, breadcrumbs, pluginIcon, title: this.plugin.title, logout: this.logout, username, i18n }), opts.showFilter && u(SearchInput_default, { searchString, setSearchString: (s2) => {
      this.plugin.setPluginState({ searchString: s2 });
    }, submitSearchString: () => {
    }, inputLabel: i18n("filter"), clearSearchLabel: i18n("resetFilter"), wrapperClassName: "uppy-ProviderBrowser-searchFilter", inputClassName: "uppy-ProviderBrowser-searchFilterInput" }), u(Browser_default, { toggleCheckbox: this.toggleCheckbox, displayedPartialTree: this.getDisplayedPartialTree(), openFolder: this.openFolder, virtualList: opts.virtualList, noResultsLabel: i18n("noFilesFound"), handleScroll: this.handleScroll, viewType: opts.viewType, showTitles: opts.showTitles, i18n: this.plugin.uppy.i18n, isLoading: loading, utmSource: "Companion" }), u(FooterActions, { partialTree, donePicking: this.donePicking, cancelSelection: this.cancelSelection, i18n, validateAggregateRestrictions: this.validateAggregateRestrictions })] });
  }
};
_abortController = new WeakMap();
_ProviderView_instances = new WeakSet();
withAbort_fn = async function(op) {
  var _a;
  (_a = __privateGet(this, _abortController)) == null ? void 0 : _a.abort();
  const abortController = new AbortController();
  __privateSet(this, _abortController, abortController);
  const cancelRequest = () => {
    abortController.abort();
  };
  try {
    this.plugin.uppy.on("dashboard:close-panel", cancelRequest);
    this.plugin.uppy.on("cancel-all", cancelRequest);
    await op(abortController.signal);
  } finally {
    this.plugin.uppy.off("dashboard:close-panel", cancelRequest);
    this.plugin.uppy.off("cancel-all", cancelRequest);
    __privateSet(this, _abortController, void 0);
  }
};
__publicField(ProviderView, "VERSION", package_default2.version);

// node_modules/@uppy/provider-views/lib/SearchProviderView/SearchProviderView.js
var import_classnames5 = __toESM(require_classnames(), 1);
var defaultState = {
  loading: false,
  searchString: "",
  partialTree: [
    {
      type: "root",
      id: null,
      cached: false,
      nextPagePath: null
    }
  ],
  currentFolderId: null,
  isInputMode: true
};
var defaultOptions = {
  viewType: "grid",
  showTitles: true,
  showFilter: true,
  utmSource: "Companion"
};
var SearchProviderView = class {
  constructor(plugin, opts) {
    __publicField(this, "plugin");
    __publicField(this, "provider");
    __publicField(this, "opts");
    __publicField(this, "isHandlingScroll", false);
    __publicField(this, "lastCheckbox", null);
    __publicField(this, "validateSingleFile", (file) => {
      const companionFile = remoteFileObjToLocal(file);
      const result = this.plugin.uppy.validateSingleFile(companionFile);
      return result;
    });
    __publicField(this, "getDisplayedPartialTree", () => {
      const { partialTree } = this.plugin.getPluginState();
      return partialTree.filter((item) => item.type !== "root");
    });
    __publicField(this, "setSearchString", (searchString) => {
      this.plugin.setPluginState({ searchString });
      if (searchString === "") {
        this.plugin.setPluginState({ partialTree: [] });
      }
    });
    __publicField(this, "validateAggregateRestrictions", (partialTree) => {
      const checkedFiles = partialTree.filter((item) => item.type === "file" && item.status === "checked");
      const uppyFiles = checkedFiles.map((file) => file.data);
      return this.plugin.uppy.validateAggregateRestrictions(uppyFiles);
    });
    this.plugin = plugin;
    this.provider = opts.provider;
    this.opts = { ...defaultOptions, ...opts };
    this.setSearchString = this.setSearchString.bind(this);
    this.search = this.search.bind(this);
    this.resetPluginState = this.resetPluginState.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelSelection = this.cancelSelection.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.render = this.render.bind(this);
    this.resetPluginState();
    this.plugin.uppy.on("dashboard:close-panel", this.resetPluginState);
    this.plugin.uppy.registerRequestClient(this.provider.provider, this.provider);
  }
  tearDown() {
  }
  setLoading(loading) {
    this.plugin.setPluginState({ loading });
  }
  resetPluginState() {
    this.plugin.setPluginState(defaultState);
  }
  cancelSelection() {
    const { partialTree } = this.plugin.getPluginState();
    const newPartialTree = partialTree.map((item) => item.type === "root" ? item : { ...item, status: "unchecked" });
    this.plugin.setPluginState({ partialTree: newPartialTree });
  }
  async search() {
    const { searchString } = this.plugin.getPluginState();
    if (searchString === "")
      return;
    this.setLoading(true);
    try {
      const response = await this.provider.search(searchString);
      const newPartialTree = [
        {
          type: "root",
          id: null,
          cached: false,
          nextPagePath: response.nextPageQuery
        },
        ...response.items.map((item) => ({
          type: "file",
          id: item.requestPath,
          status: "unchecked",
          parentId: null,
          data: item
        }))
      ];
      this.plugin.setPluginState({
        partialTree: newPartialTree,
        isInputMode: false
      });
    } catch (error) {
      handleError_default(this.plugin.uppy)(error);
    }
    this.setLoading(false);
  }
  async handleScroll(event) {
    const { partialTree, searchString } = this.plugin.getPluginState();
    const root = partialTree.find((i3) => i3.type === "root");
    if (shouldHandleScroll_default(event) && !this.isHandlingScroll && root.nextPagePath) {
      this.isHandlingScroll = true;
      try {
        const response = await this.provider.search(searchString, root.nextPagePath);
        const newRoot = {
          ...root,
          nextPagePath: response.nextPageQuery
        };
        const oldItems = partialTree.filter((i3) => i3.type !== "root");
        const newPartialTree = [
          newRoot,
          ...oldItems,
          ...response.items.map((item) => ({
            type: "file",
            id: item.requestPath,
            status: "unchecked",
            parentId: null,
            data: item
          }))
        ];
        this.plugin.setPluginState({ partialTree: newPartialTree });
      } catch (error) {
        handleError_default(this.plugin.uppy)(error);
      }
      this.isHandlingScroll = false;
    }
  }
  async donePicking() {
    const { partialTree } = this.plugin.getPluginState();
    const companionFiles = getCheckedFilesWithPaths_default(partialTree);
    addFiles_default(companionFiles, this.plugin, this.provider);
    this.resetPluginState();
  }
  toggleCheckbox(ourItem, isShiftKeyPressed) {
    const { partialTree } = this.plugin.getPluginState();
    const clickedRange = getClickedRange_default(ourItem.id, this.getDisplayedPartialTree(), isShiftKeyPressed, this.lastCheckbox);
    const newPartialTree = PartialTreeUtils_default.afterToggleCheckbox(partialTree, clickedRange);
    this.plugin.setPluginState({ partialTree: newPartialTree });
    this.lastCheckbox = ourItem.id;
  }
  render(state, viewOptions = {}) {
    const { isInputMode, searchString, loading, partialTree } = this.plugin.getPluginState();
    const { i18n } = this.plugin.uppy;
    const opts = { ...this.opts, ...viewOptions };
    if (isInputMode) {
      return u(SearchInput_default, { searchString, setSearchString: this.setSearchString, submitSearchString: this.search, inputLabel: i18n("enterTextToSearch"), buttonLabel: i18n("searchImages"), wrapperClassName: "uppy-SearchProvider", inputClassName: "uppy-c-textInput uppy-SearchProvider-input", showButton: true, buttonCSSClassName: "uppy-SearchProvider-searchButton" });
    }
    return u("div", { className: (0, import_classnames5.default)("uppy-ProviderBrowser", `uppy-ProviderBrowser-viewType--${opts.viewType}`), children: [opts.showFilter && u(SearchInput_default, { searchString, setSearchString: this.setSearchString, submitSearchString: this.search, inputLabel: i18n("search"), clearSearchLabel: i18n("resetSearch"), wrapperClassName: "uppy-ProviderBrowser-searchFilter", inputClassName: "uppy-ProviderBrowser-searchFilterInput" }), u(Browser_default, { toggleCheckbox: this.toggleCheckbox, displayedPartialTree: this.getDisplayedPartialTree(), handleScroll: this.handleScroll, openFolder: async () => {
    }, noResultsLabel: i18n("noSearchResults"), viewType: opts.viewType, showTitles: opts.showTitles, isLoading: loading, i18n, virtualList: false, utmSource: this.opts.utmSource }), u(FooterActions, { partialTree, donePicking: this.donePicking, cancelSelection: this.cancelSelection, i18n, validateAggregateRestrictions: this.validateAggregateRestrictions })] });
  }
};
__publicField(SearchProviderView, "VERSION", package_default2.version);

// node_modules/@uppy/utils/lib/emaFilter.js
function emaFilter(newValue, previousSmoothedValue, halfLife, dt) {
  if (halfLife === 0 || newValue === previousSmoothedValue)
    return newValue;
  if (dt === 0)
    return previousSmoothedValue;
  return newValue + (previousSmoothedValue - newValue) * 2 ** (-dt / halfLife);
}

// node_modules/@uppy/status-bar/package.json
var package_default3 = {
  name: "@uppy/status-bar",
  description: "A progress bar for Uppy, with many bells and whistles.",
  version: "4.2.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress bar",
    "status bar",
    "progress",
    "upload",
    "eta",
    "speed"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@transloadit/prettier-bytes": "^0.3.4",
    "@uppy/utils": "^6.2.2",
    classnames: "^2.2.6",
    preact: "^10.5.13"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  },
  devDependencies: {
    cssnano: "^7.0.7",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3"
  }
};

// node_modules/@uppy/status-bar/lib/locale.js
var locale_default = {
  strings: {
    // Shown in the status bar while files are being uploaded.
    uploading: "Uploading",
    // Shown in the status bar once all files have been uploaded.
    complete: "Complete",
    // Shown in the status bar if an upload failed.
    uploadFailed: "Upload failed",
    // Shown in the status bar while the upload is paused.
    paused: "Paused",
    // Used as the label for the button that retries an upload.
    retry: "Retry",
    // Used as the label for the button that cancels an upload.
    cancel: "Cancel",
    // Used as the label for the button that pauses an upload.
    pause: "Pause",
    // Used as the label for the button that resumes an upload.
    resume: "Resume",
    // Used as the label for the button that resets the upload state after an upload
    done: "Done",
    // When `showProgressDetails` is set, shows the number of files that have been fully uploaded so far.
    filesUploadedOfTotal: {
      0: "%{complete} of %{smart_count} file uploaded",
      1: "%{complete} of %{smart_count} files uploaded"
    },
    // When `showProgressDetails` is set, shows the amount of bytes that have been uploaded so far.
    dataUploadedOfTotal: "%{complete} of %{total}",
    dataUploadedOfUnknown: "%{complete} of unknown",
    // When `showProgressDetails` is set, shows an estimation of how long the upload will take to complete.
    xTimeLeft: "%{time} left",
    // Used as the label for the button that starts an upload.
    uploadXFiles: {
      0: "Upload %{smart_count} file",
      1: "Upload %{smart_count} files"
    },
    // Used as the label for the button that starts an upload, if another upload has been started in the past
    // and new files were added later.
    uploadXNewFiles: {
      0: "Upload +%{smart_count} file",
      1: "Upload +%{smart_count} files"
    },
    upload: "Upload",
    retryUpload: "Retry upload",
    xMoreFilesAdded: {
      0: "%{smart_count} more file added",
      1: "%{smart_count} more files added"
    },
    showErrorDetails: "Show error details"
  }
};

// node_modules/@uppy/status-bar/lib/StatusBarStates.js
var StatusBarStates_default = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete"
};

// node_modules/@uppy/status-bar/lib/StatusBarUI.js
var import_classnames7 = __toESM(require_classnames(), 1);

// node_modules/@uppy/status-bar/lib/Components.js
var import_prettier_bytes = __toESM(require_prettierBytes(), 1);

// node_modules/@uppy/utils/lib/secondsToTime.js
function secondsToTime(rawSeconds) {
  const hours = Math.floor(rawSeconds / 3600) % 24;
  const minutes = Math.floor(rawSeconds / 60) % 60;
  const seconds = Math.floor(rawSeconds % 60);
  return { hours, minutes, seconds };
}

// node_modules/@uppy/utils/lib/prettyETA.js
function prettyETA(seconds) {
  const time = secondsToTime(seconds);
  const hoursStr = time.hours === 0 ? "" : `${time.hours}h`;
  const minutesStr = time.minutes === 0 ? "" : `${time.hours === 0 ? time.minutes : ` ${time.minutes.toString(10).padStart(2, "0")}`}m`;
  const secondsStr = time.hours !== 0 ? "" : `${time.minutes === 0 ? time.seconds : ` ${time.seconds.toString(10).padStart(2, "0")}`}s`;
  return `${hoursStr}${minutesStr}${secondsStr}`;
}

// node_modules/@uppy/status-bar/lib/Components.js
var import_classnames6 = __toESM(require_classnames(), 1);
var DOT = `·`;
var renderDot = () => ` ${DOT} `;
function UploadBtn(props) {
  const { newFiles, isUploadStarted, recoveredState, i18n, uploadState, isSomeGhost, startUpload } = props;
  const uploadBtnClassNames = (0, import_classnames6.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", {
    "uppy-c-btn-primary": uploadState === StatusBarStates_default.STATE_WAITING
  }, { "uppy-StatusBar-actionBtn--disabled": isSomeGhost });
  const uploadBtnText = newFiles && isUploadStarted && !recoveredState ? i18n("uploadXNewFiles", { smart_count: newFiles }) : i18n("uploadXFiles", { smart_count: newFiles });
  return u("button", { type: "button", className: uploadBtnClassNames, "aria-label": i18n("uploadXFiles", { smart_count: newFiles }), onClick: startUpload, disabled: isSomeGhost, "data-uppy-super-focusable": true, children: uploadBtnText });
}
function RetryBtn(props) {
  const { i18n, uppy } = props;
  return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry", "aria-label": i18n("retryUpload"), onClick: () => uppy.retryAll().catch(() => {
  }), "data-uppy-super-focusable": true, "data-cy": "retry", children: [u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "8", height: "10", viewBox: "0 0 8 10", children: u("path", { d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z" }) }), i18n("retry")] });
}
function CancelBtn(props) {
  const { i18n, uppy } = props;
  return u("button", { type: "button", className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", title: i18n("cancel"), "aria-label": i18n("cancel"), onClick: () => uppy.cancelAll(), "data-cy": "cancel", "data-uppy-super-focusable": true, children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16", children: u("g", { fill: "none", fillRule: "evenodd", children: [u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z" })] }) }) });
}
function PauseResumeButton(props) {
  const { isAllPaused, i18n, isAllComplete, resumableUploads, uppy } = props;
  const title = isAllPaused ? i18n("resume") : i18n("pause");
  function togglePauseResume() {
    if (isAllComplete)
      return;
    if (!resumableUploads) {
      uppy.cancelAll();
      return;
    }
    if (isAllPaused) {
      uppy.resumeAll();
      return;
    }
    uppy.pauseAll();
  }
  return u("button", { title, "aria-label": title, className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", type: "button", onClick: togglePauseResume, "data-cy": "togglePauseResume", "data-uppy-super-focusable": true, children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16", children: u("g", { fill: "none", fillRule: "evenodd", children: [u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: isAllPaused ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z" })] }) }) });
}
function DoneBtn(props) {
  const { i18n, doneButtonHandler } = props;
  return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done", onClick: doneButtonHandler, "data-uppy-super-focusable": true, children: i18n("done") });
}
function LoadingSpinner() {
  return u("svg", { className: "uppy-StatusBar-spinner", "aria-hidden": "true", focusable: "false", width: "14", height: "14", children: u("path", { d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0", fillRule: "evenodd" }) });
}
function ProgressBarProcessing(props) {
  const { progress } = props;
  const { value, mode, message } = progress;
  const dot = `·`;
  return u("div", { className: "uppy-StatusBar-content", children: [u(LoadingSpinner, {}), mode === "determinate" ? `${Math.round(value * 100)}% ${dot} ` : "", message] });
}
function ProgressDetails(props) {
  const { numUploads, complete, totalUploadedSize, totalSize, totalETA, i18n } = props;
  const ifShowFilesUploadedOfTotal = numUploads > 1;
  const totalUploadedSizeStr = (0, import_prettier_bytes.default)(totalUploadedSize);
  return u("div", { className: "uppy-StatusBar-statusSecondary", children: [ifShowFilesUploadedOfTotal && i18n("filesUploadedOfTotal", {
    complete,
    smart_count: numUploads
  }), u("span", { className: "uppy-StatusBar-additionalInfo", children: [ifShowFilesUploadedOfTotal && renderDot(), totalSize != null ? i18n("dataUploadedOfTotal", {
    complete: totalUploadedSizeStr,
    total: (0, import_prettier_bytes.default)(totalSize)
  }) : i18n("dataUploadedOfUnknown", { complete: totalUploadedSizeStr }), renderDot(), totalETA != null && i18n("xTimeLeft", {
    time: prettyETA(totalETA)
  })] })] });
}
function FileUploadCount(props) {
  const { i18n, complete, numUploads } = props;
  return u("div", { className: "uppy-StatusBar-statusSecondary", children: i18n("filesUploadedOfTotal", { complete, smart_count: numUploads }) });
}
function UploadNewlyAddedFiles(props) {
  const { i18n, newFiles, startUpload } = props;
  const uploadBtnClassNames = (0, import_classnames6.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded");
  return u("div", { className: "uppy-StatusBar-statusSecondary", children: [u("div", { className: "uppy-StatusBar-statusSecondaryHint", children: i18n("xMoreFilesAdded", { smart_count: newFiles }) }), u("button", { type: "button", className: uploadBtnClassNames, "aria-label": i18n("uploadXFiles", { smart_count: newFiles }), onClick: startUpload, children: i18n("upload") })] });
}
function ProgressBarUploading(props) {
  const { i18n, supportsUploadProgress, totalProgress, showProgressDetails, isUploadStarted, isAllComplete, isAllPaused, newFiles, numUploads, complete, totalUploadedSize, totalSize, totalETA, startUpload } = props;
  const showUploadNewlyAddedFiles = newFiles && isUploadStarted;
  if (!isUploadStarted || isAllComplete) {
    return null;
  }
  const title = isAllPaused ? i18n("paused") : i18n("uploading");
  function renderProgressDetails() {
    if (!isAllPaused && !showUploadNewlyAddedFiles && showProgressDetails) {
      if (supportsUploadProgress) {
        return u(ProgressDetails, { numUploads, complete, totalUploadedSize, totalSize, totalETA, i18n });
      }
      return u(FileUploadCount, { i18n, complete, numUploads });
    }
    return null;
  }
  return u("div", { className: "uppy-StatusBar-content", title, children: [!isAllPaused ? u(LoadingSpinner, {}) : null, u("div", { className: "uppy-StatusBar-status", children: [u("div", { className: "uppy-StatusBar-statusPrimary", children: supportsUploadProgress && totalProgress !== 0 ? `${title}: ${totalProgress}%` : title }), renderProgressDetails(), showUploadNewlyAddedFiles ? u(UploadNewlyAddedFiles, { i18n, newFiles, startUpload }) : null] })] });
}
function ProgressBarComplete(props) {
  const { i18n } = props;
  return u("div", {
    className: "uppy-StatusBar-content",
    // biome-ignore lint/a11y/useSemanticElements: ...
    role: "status",
    title: i18n("complete"),
    children: u("div", { className: "uppy-StatusBar-status", children: u("div", { className: "uppy-StatusBar-statusPrimary", children: [u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "15", height: "11", viewBox: "0 0 15 11", children: u("path", { d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z" }) }), i18n("complete")] }) })
  });
}
function ProgressBarError(props) {
  const { error, i18n, complete, numUploads } = props;
  function displayErrorAlert() {
    const errorMessage = `${i18n("uploadFailed")} 

 ${error}`;
    alert(errorMessage);
  }
  return u("div", { className: "uppy-StatusBar-content", title: i18n("uploadFailed"), children: [u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "11", height: "11", viewBox: "0 0 11 11", children: u("path", { d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z" }) }), u("div", { className: "uppy-StatusBar-status", children: [u("div", { className: "uppy-StatusBar-statusPrimary", children: [i18n("uploadFailed"), u("button", { className: "uppy-u-reset uppy-StatusBar-details", "aria-label": i18n("showErrorDetails"), "data-microtip-position": "top-right", "data-microtip-size": "medium", onClick: displayErrorAlert, type: "button", children: "?" })] }), u(FileUploadCount, { i18n, complete, numUploads })] })] });
}

// node_modules/@uppy/status-bar/lib/calculateProcessingProgress.js
function calculateProcessingProgress(files) {
  const values = [];
  let mode = "indeterminate";
  let message;
  for (const { progress } of Object.values(files)) {
    const { preprocess, postprocess } = progress;
    if (message == null && (preprocess || postprocess)) {
      ;
      ({ mode, message } = preprocess || postprocess);
    }
    if ((preprocess == null ? void 0 : preprocess.mode) === "determinate")
      values.push(preprocess.value);
    if ((postprocess == null ? void 0 : postprocess.mode) === "determinate")
      values.push(postprocess.value);
  }
  const value = values.reduce((total, progressValue) => {
    return total + progressValue / values.length;
  }, 0);
  return {
    mode,
    message,
    value
  };
}

// node_modules/@uppy/status-bar/lib/StatusBarUI.js
var { STATE_ERROR, STATE_WAITING, STATE_PREPROCESSING, STATE_UPLOADING, STATE_POSTPROCESSING, STATE_COMPLETE } = StatusBarStates_default;
function StatusBarUI({ newFiles, allowNewUpload, isUploadInProgress, isAllPaused, resumableUploads, error, hideUploadButton = void 0, hidePauseResumeButton = false, hideCancelButton = false, hideRetryButton = false, recoveredState, uploadState, totalProgress, files, supportsUploadProgress, hideAfterFinish = false, isSomeGhost, doneButtonHandler = void 0, isUploadStarted, i18n, startUpload, uppy, isAllComplete, showProgressDetails = void 0, numUploads, complete, totalSize, totalETA, totalUploadedSize }) {
  function getProgressValue() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const progress = calculateProcessingProgress(files);
        if (progress.mode === "determinate") {
          return progress.value * 100;
        }
        return totalProgress;
      }
      case STATE_ERROR: {
        return null;
      }
      case STATE_UPLOADING: {
        if (!supportsUploadProgress) {
          return null;
        }
        return totalProgress;
      }
      default:
        return totalProgress;
    }
  }
  function getIsIndeterminate() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const { mode } = calculateProcessingProgress(files);
        return mode === "indeterminate";
      }
      case STATE_UPLOADING: {
        if (!supportsUploadProgress) {
          return true;
        }
        return false;
      }
      default:
        return false;
    }
  }
  const progressValue = getProgressValue();
  const width = progressValue ?? 100;
  const showUploadBtn = !error && newFiles && (!isUploadInProgress && !isAllPaused || recoveredState) && allowNewUpload && !hideUploadButton;
  const showCancelBtn = !hideCancelButton && uploadState !== STATE_WAITING && uploadState !== STATE_COMPLETE;
  const showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === STATE_UPLOADING;
  const showRetryBtn = error && !isAllComplete && !hideRetryButton;
  const showDoneBtn = doneButtonHandler && uploadState === STATE_COMPLETE;
  const progressClassNames = (0, import_classnames7.default)("uppy-StatusBar-progress", {
    "is-indeterminate": getIsIndeterminate()
  });
  const statusBarClassNames = (0, import_classnames7.default)("uppy-StatusBar", `is-${uploadState}`, { "has-ghosts": isSomeGhost });
  const progressBarStateEl = (() => {
    switch (uploadState) {
      case STATE_PREPROCESSING:
      case STATE_POSTPROCESSING:
        return u(ProgressBarProcessing, { progress: calculateProcessingProgress(files) });
      case STATE_COMPLETE:
        return u(ProgressBarComplete, { i18n });
      case STATE_ERROR:
        return u(ProgressBarError, { error, i18n, numUploads, complete });
      case STATE_UPLOADING:
        return u(ProgressBarUploading, { i18n, supportsUploadProgress, totalProgress, showProgressDetails, isUploadStarted, isAllComplete, isAllPaused, newFiles, numUploads, complete, totalUploadedSize, totalSize, totalETA, startUpload });
      default:
        return null;
    }
  })();
  const atLeastOneAction = showUploadBtn || showRetryBtn || showPauseResumeBtn || showCancelBtn || showDoneBtn;
  const thereIsNothingInside = !atLeastOneAction && !progressBarStateEl;
  const isHidden = thereIsNothingInside || uploadState === STATE_COMPLETE && hideAfterFinish;
  if (isHidden) {
    return null;
  }
  return u("div", { className: statusBarClassNames, children: [u("div", { className: progressClassNames, style: { width: `${width}%` }, role: "progressbar", "aria-label": `${width}%`, "aria-valuetext": `${width}%`, "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": progressValue }), progressBarStateEl, u("div", { className: "uppy-StatusBar-actions", children: [showUploadBtn ? u(UploadBtn, { newFiles, isUploadStarted, recoveredState, i18n, isSomeGhost, startUpload, uploadState }) : null, showRetryBtn ? u(RetryBtn, { i18n, uppy }) : null, showPauseResumeBtn ? u(PauseResumeButton, { isAllPaused, i18n, isAllComplete, resumableUploads, uppy }) : null, showCancelBtn ? u(CancelBtn, { i18n, uppy }) : null, showDoneBtn ? u(DoneBtn, { i18n, doneButtonHandler }) : null] })] });
}

// node_modules/@uppy/status-bar/lib/StatusBar.js
var speedFilterHalfLife = 2e3;
var ETAFilterHalfLife = 2e3;
function getUploadingState(error, isAllComplete, recoveredState, files) {
  if (error) {
    return StatusBarStates_default.STATE_ERROR;
  }
  if (isAllComplete) {
    return StatusBarStates_default.STATE_COMPLETE;
  }
  if (recoveredState) {
    return StatusBarStates_default.STATE_WAITING;
  }
  let state = StatusBarStates_default.STATE_WAITING;
  const fileIDs = Object.keys(files);
  for (let i3 = 0; i3 < fileIDs.length; i3++) {
    const { progress } = files[fileIDs[i3]];
    if (progress.uploadStarted && !progress.uploadComplete) {
      return StatusBarStates_default.STATE_UPLOADING;
    }
    if (progress.preprocess) {
      state = StatusBarStates_default.STATE_PREPROCESSING;
    }
    if (progress.postprocess && state !== StatusBarStates_default.STATE_PREPROCESSING) {
      state = StatusBarStates_default.STATE_POSTPROCESSING;
    }
  }
  return state;
}
var defaultOptions2 = {
  hideUploadButton: false,
  hideRetryButton: false,
  hidePauseResumeButton: false,
  hideCancelButton: false,
  showProgressDetails: false,
  hideAfterFinish: true,
  doneButtonHandler: null
};
var _lastUpdateTime, _previousUploadedBytes, _previousSpeed, _previousETA, _StatusBar_instances, computeSmoothETA_fn, _onUploadStart;
var StatusBar = class extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, { ...defaultOptions2, ...opts });
    __privateAdd(this, _StatusBar_instances);
    __privateAdd(this, _lastUpdateTime);
    __privateAdd(this, _previousUploadedBytes);
    __privateAdd(this, _previousSpeed);
    __privateAdd(this, _previousETA);
    __publicField(this, "startUpload", () => {
      return this.uppy.upload().catch(() => {
      });
    });
    __privateAdd(this, _onUploadStart, () => {
      const { recoveredState } = this.uppy.getState();
      __privateSet(this, _previousSpeed, null);
      __privateSet(this, _previousETA, null);
      if (recoveredState) {
        __privateSet(this, _previousUploadedBytes, Object.values(recoveredState.files).reduce((pv, { progress }) => pv + progress.bytesUploaded, 0));
        this.uppy.emit("restore-confirmed");
        return;
      }
      __privateSet(this, _lastUpdateTime, performance.now());
      __privateSet(this, _previousUploadedBytes, 0);
    });
    this.id = this.opts.id || "StatusBar";
    this.title = "StatusBar";
    this.type = "progressindicator";
    this.defaultLocale = locale_default;
    this.i18nInit();
    this.render = this.render.bind(this);
    this.install = this.install.bind(this);
  }
  render(state) {
    const { capabilities, files, allowNewUpload, totalProgress, error, recoveredState } = state;
    const { newFiles, startedFiles, completeFiles, isUploadStarted, isAllComplete, isAllPaused, isUploadInProgress, isSomeGhost } = this.uppy.getObjectOfFilesPerState();
    const newFilesOrRecovered = recoveredState ? Object.values(files) : newFiles;
    const resumableUploads = !!capabilities.resumableUploads;
    const supportsUploadProgress = capabilities.uploadProgress !== false;
    let totalSize = null;
    let totalUploadedSize = 0;
    if (startedFiles.every((f3) => f3.progress.bytesTotal != null && f3.progress.bytesTotal !== 0)) {
      totalSize = 0;
      startedFiles.forEach((file) => {
        totalSize += file.progress.bytesTotal || 0;
        totalUploadedSize += file.progress.bytesUploaded || 0;
      });
    } else {
      startedFiles.forEach((file) => {
        totalUploadedSize += file.progress.bytesUploaded || 0;
      });
    }
    const totalETA = __privateMethod(this, _StatusBar_instances, computeSmoothETA_fn).call(this, {
      uploaded: totalUploadedSize,
      total: totalSize
    });
    return StatusBarUI({
      error,
      uploadState: getUploadingState(error, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload,
      totalProgress,
      totalSize,
      totalUploadedSize,
      isAllComplete: false,
      isAllPaused,
      isUploadStarted,
      isUploadInProgress,
      isSomeGhost,
      recoveredState,
      complete: completeFiles.length,
      newFiles: newFilesOrRecovered.length,
      numUploads: startedFiles.length,
      totalETA,
      files,
      i18n: this.i18n,
      uppy: this.uppy,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads,
      supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish
    });
  }
  onMount() {
    const element = this.el;
    const direction = getTextDirection_default(element);
    if (!direction) {
      element.dir = "ltr";
    }
  }
  install() {
    const { target } = this.opts;
    if (target) {
      this.mount(target, this);
    }
    this.uppy.on("upload", __privateGet(this, _onUploadStart));
    __privateSet(this, _lastUpdateTime, performance.now());
    __privateSet(this, _previousUploadedBytes, this.uppy.getFiles().reduce((pv, file) => pv + file.progress.bytesUploaded, 0));
  }
  uninstall() {
    this.unmount();
    this.uppy.off("upload", __privateGet(this, _onUploadStart));
  }
};
_lastUpdateTime = new WeakMap();
_previousUploadedBytes = new WeakMap();
_previousSpeed = new WeakMap();
_previousETA = new WeakMap();
_StatusBar_instances = new WeakSet();
computeSmoothETA_fn = function(totalBytes) {
  if (totalBytes.total == null || totalBytes.total === 0) {
    return null;
  }
  const remaining = totalBytes.total - totalBytes.uploaded;
  if (remaining <= 0) {
    return null;
  }
  __privateGet(this, _lastUpdateTime) ?? __privateSet(this, _lastUpdateTime, performance.now());
  const dt = performance.now() - __privateGet(this, _lastUpdateTime);
  if (dt === 0) {
    return Math.round((__privateGet(this, _previousETA) ?? 0) / 100) / 10;
  }
  const uploadedBytesSinceLastTick = totalBytes.uploaded - __privateGet(this, _previousUploadedBytes);
  __privateSet(this, _previousUploadedBytes, totalBytes.uploaded);
  if (uploadedBytesSinceLastTick <= 0) {
    return Math.round((__privateGet(this, _previousETA) ?? 0) / 100) / 10;
  }
  const currentSpeed = uploadedBytesSinceLastTick / dt;
  const filteredSpeed = __privateGet(this, _previousSpeed) == null ? currentSpeed : emaFilter(currentSpeed, __privateGet(this, _previousSpeed), speedFilterHalfLife, dt);
  __privateSet(this, _previousSpeed, filteredSpeed);
  const instantETA = remaining / filteredSpeed;
  const updatedPreviousETA = Math.max(__privateGet(this, _previousETA) - dt, 0);
  const filteredETA = __privateGet(this, _previousETA) == null ? instantETA : emaFilter(instantETA, updatedPreviousETA, ETAFilterHalfLife, dt);
  __privateSet(this, _previousETA, filteredETA);
  __privateSet(this, _lastUpdateTime, performance.now());
  return Math.round(filteredETA / 100) / 10;
};
_onUploadStart = new WeakMap();
__publicField(StatusBar, "VERSION", package_default3.version);

// node_modules/@uppy/utils/lib/dataURItoBlob.js
var DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
function dataURItoBlob(dataURI, opts, toFile) {
  const dataURIData = DATA_URL_PATTERN.exec(dataURI);
  const mimeType = opts.mimeType ?? (dataURIData == null ? void 0 : dataURIData[1]) ?? "plain/text";
  let data;
  if ((dataURIData == null ? void 0 : dataURIData[2]) != null) {
    const binary = atob(decodeURIComponent(dataURIData[3]));
    const bytes = new Uint8Array(binary.length);
    for (let i3 = 0; i3 < binary.length; i3++) {
      bytes[i3] = binary.charCodeAt(i3);
    }
    data = [bytes];
  } else if ((dataURIData == null ? void 0 : dataURIData[3]) != null) {
    data = [decodeURIComponent(dataURIData[3])];
  }
  if (toFile) {
    return new File(data, opts.name || "", { type: mimeType });
  }
  return new Blob(data, { type: mimeType });
}
var dataURItoBlob_default = dataURItoBlob;

// node_modules/@uppy/utils/lib/isObjectURL.js
function isObjectURL(url) {
  return url.startsWith("blob:");
}

// node_modules/@uppy/utils/lib/isPreviewSupported.js
function isPreviewSupported(fileType) {
  if (!fileType)
    return false;
  return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
}

// node_modules/exifr/dist/mini.esm.mjs
function e(e2, t2, s2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: s2, enumerable: true, configurable: true, writable: true }) : e2[t2] = s2, e2;
}
var t = "undefined" != typeof self ? self : global;
var s = "undefined" != typeof navigator;
var i2 = s && "undefined" == typeof HTMLImageElement;
var n = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node);
var r = t.Buffer;
var a = !!r;
var h = (e2) => void 0 !== e2;
function f2(e2) {
  return void 0 === e2 || (e2 instanceof Map ? 0 === e2.size : 0 === Object.values(e2).filter(h).length);
}
function l2(e2) {
  let t2 = new Error(e2);
  throw delete t2.stack, t2;
}
function o(e2) {
  let t2 = function(e3) {
    let t3 = 0;
    return e3.ifd0.enabled && (t3 += 1024), e3.exif.enabled && (t3 += 2048), e3.makerNote && (t3 += 2048), e3.userComment && (t3 += 1024), e3.gps.enabled && (t3 += 512), e3.interop.enabled && (t3 += 100), e3.ifd1.enabled && (t3 += 1024), t3 + 2048;
  }(e2);
  return e2.jfif.enabled && (t2 += 50), e2.xmp.enabled && (t2 += 2e4), e2.iptc.enabled && (t2 += 14e3), e2.icc.enabled && (t2 += 6e3), t2;
}
var u2 = (e2) => String.fromCharCode.apply(null, e2);
var d2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
var c = class _c {
  static from(e2, t2) {
    return e2 instanceof this && e2.le === t2 ? e2 : new _c(e2, void 0, void 0, t2);
  }
  constructor(e2, t2 = 0, s2, i3) {
    if ("boolean" == typeof i3 && (this.le = i3), Array.isArray(e2) && (e2 = new Uint8Array(e2)), 0 === e2) this.byteOffset = 0, this.byteLength = 0;
    else if (e2 instanceof ArrayBuffer) {
      void 0 === s2 && (s2 = e2.byteLength - t2);
      let i4 = new DataView(e2, t2, s2);
      this._swapDataView(i4);
    } else if (e2 instanceof Uint8Array || e2 instanceof DataView || e2 instanceof _c) {
      void 0 === s2 && (s2 = e2.byteLength - t2), (t2 += e2.byteOffset) + s2 > e2.byteOffset + e2.byteLength && l2("Creating view outside of available memory in ArrayBuffer");
      let i4 = new DataView(e2.buffer, t2, s2);
      this._swapDataView(i4);
    } else if ("number" == typeof e2) {
      let t3 = new DataView(new ArrayBuffer(e2));
      this._swapDataView(t3);
    } else l2("Invalid input argument for BufferView: " + e2);
  }
  _swapArrayBuffer(e2) {
    this._swapDataView(new DataView(e2));
  }
  _swapBuffer(e2) {
    this._swapDataView(new DataView(e2.buffer, e2.byteOffset, e2.byteLength));
  }
  _swapDataView(e2) {
    this.dataView = e2, this.buffer = e2.buffer, this.byteOffset = e2.byteOffset, this.byteLength = e2.byteLength;
  }
  _lengthToEnd(e2) {
    return this.byteLength - e2;
  }
  set(e2, t2, s2 = _c) {
    return e2 instanceof DataView || e2 instanceof _c ? e2 = new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2)), e2 instanceof Uint8Array || l2("BufferView.set(): Invalid data argument."), this.toUint8().set(e2, t2), new s2(this, t2, e2.byteLength);
  }
  subarray(e2, t2) {
    return t2 = t2 || this._lengthToEnd(e2), new _c(this, e2, t2);
  }
  toUint8() {
    return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
  }
  getUint8Array(e2, t2) {
    return new Uint8Array(this.buffer, this.byteOffset + e2, t2);
  }
  getString(e2 = 0, t2 = this.byteLength) {
    let s2 = this.getUint8Array(e2, t2);
    return i3 = s2, d2 ? d2.decode(i3) : a ? Buffer.from(i3).toString("utf8") : decodeURIComponent(escape(u2(i3)));
    var i3;
  }
  getLatin1String(e2 = 0, t2 = this.byteLength) {
    let s2 = this.getUint8Array(e2, t2);
    return u2(s2);
  }
  getUnicodeString(e2 = 0, t2 = this.byteLength) {
    const s2 = [];
    for (let i3 = 0; i3 < t2 && e2 + i3 < this.byteLength; i3 += 2) s2.push(this.getUint16(e2 + i3));
    return u2(s2);
  }
  getInt8(e2) {
    return this.dataView.getInt8(e2);
  }
  getUint8(e2) {
    return this.dataView.getUint8(e2);
  }
  getInt16(e2, t2 = this.le) {
    return this.dataView.getInt16(e2, t2);
  }
  getInt32(e2, t2 = this.le) {
    return this.dataView.getInt32(e2, t2);
  }
  getUint16(e2, t2 = this.le) {
    return this.dataView.getUint16(e2, t2);
  }
  getUint32(e2, t2 = this.le) {
    return this.dataView.getUint32(e2, t2);
  }
  getFloat32(e2, t2 = this.le) {
    return this.dataView.getFloat32(e2, t2);
  }
  getFloat64(e2, t2 = this.le) {
    return this.dataView.getFloat64(e2, t2);
  }
  getFloat(e2, t2 = this.le) {
    return this.dataView.getFloat32(e2, t2);
  }
  getDouble(e2, t2 = this.le) {
    return this.dataView.getFloat64(e2, t2);
  }
  getUintBytes(e2, t2, s2) {
    switch (t2) {
      case 1:
        return this.getUint8(e2, s2);
      case 2:
        return this.getUint16(e2, s2);
      case 4:
        return this.getUint32(e2, s2);
      case 8:
        return this.getUint64 && this.getUint64(e2, s2);
    }
  }
  getUint(e2, t2, s2) {
    switch (t2) {
      case 8:
        return this.getUint8(e2, s2);
      case 16:
        return this.getUint16(e2, s2);
      case 32:
        return this.getUint32(e2, s2);
      case 64:
        return this.getUint64 && this.getUint64(e2, s2);
    }
  }
  toString(e2) {
    return this.dataView.toString(e2, this.constructor.name);
  }
  ensureChunk() {
  }
};
function p(e2, t2) {
  l2(`${e2} '${t2}' was not loaded, try using full build of exifr.`);
}
var g = class extends Map {
  constructor(e2) {
    super(), this.kind = e2;
  }
  get(e2, t2) {
    return this.has(e2) || p(this.kind, e2), t2 && (e2 in t2 || function(e3, t3) {
      l2(`Unknown ${e3} '${t3}'.`);
    }(this.kind, e2), t2[e2].enabled || p(this.kind, e2)), super.get(e2);
  }
  keyList() {
    return Array.from(this.keys());
  }
};
var m = new g("file parser");
var y2 = new g("segment parser");
var b2 = new g("file reader");
var w = t.fetch;
function k2(e2, t2) {
  return (i3 = e2).startsWith("data:") || i3.length > 1e4 ? v(e2, t2, "base64") : n && e2.includes("://") ? O(e2, t2, "url", S) : n ? v(e2, t2, "fs") : s ? O(e2, t2, "url", S) : void l2("Invalid input argument");
  var i3;
}
async function O(e2, t2, s2, i3) {
  return b2.has(s2) ? v(e2, t2, s2) : i3 ? async function(e3, t3) {
    let s3 = await t3(e3);
    return new c(s3);
  }(e2, i3) : void l2(`Parser ${s2} is not loaded`);
}
async function v(e2, t2, s2) {
  let i3 = new (b2.get(s2))(e2, t2);
  return await i3.read(), i3;
}
var S = (e2) => w(e2).then((e3) => e3.arrayBuffer());
var A2 = (e2) => new Promise((t2, s2) => {
  let i3 = new FileReader();
  i3.onloadend = () => t2(i3.result || new ArrayBuffer()), i3.onerror = s2, i3.readAsArrayBuffer(e2);
});
var U = class extends Map {
  get tagKeys() {
    return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
  }
  get tagValues() {
    return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
  }
};
function x2(e2, t2, s2) {
  let i3 = new U();
  for (let [e3, t3] of s2) i3.set(e3, t3);
  if (Array.isArray(t2)) for (let s3 of t2) e2.set(s3, i3);
  else e2.set(t2, i3);
  return i3;
}
function C(e2, t2, s2) {
  let i3, n2 = e2.get(t2);
  for (i3 of s2) n2.set(i3[0], i3[1]);
}
var B = /* @__PURE__ */ new Map();
var V = /* @__PURE__ */ new Map();
var I = /* @__PURE__ */ new Map();
var L = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"];
var T2 = ["jfif", "xmp", "icc", "iptc", "ihdr"];
var z = ["tiff", ...T2];
var P = ["ifd0", "ifd1", "exif", "gps", "interop"];
var F = [...z, ...P];
var j = ["makerNote", "userComment"];
var E = ["translateKeys", "translateValues", "reviveValues", "multiSegment"];
var M = [...E, "sanitize", "mergeOutput", "silentErrors"];
var _2 = class {
  get translate() {
    return this.translateKeys || this.translateValues || this.reviveValues;
  }
};
var D = class extends _2 {
  get needed() {
    return this.enabled || this.deps.size > 0;
  }
  constructor(t2, s2, i3, n2) {
    if (super(), e(this, "enabled", false), e(this, "skip", /* @__PURE__ */ new Set()), e(this, "pick", /* @__PURE__ */ new Set()), e(this, "deps", /* @__PURE__ */ new Set()), e(this, "translateKeys", false), e(this, "translateValues", false), e(this, "reviveValues", false), this.key = t2, this.enabled = s2, this.parse = this.enabled, this.applyInheritables(n2), this.canBeFiltered = P.includes(t2), this.canBeFiltered && (this.dict = B.get(t2)), void 0 !== i3) if (Array.isArray(i3)) this.parse = this.enabled = true, this.canBeFiltered && i3.length > 0 && this.translateTagSet(i3, this.pick);
    else if ("object" == typeof i3) {
      if (this.enabled = true, this.parse = false !== i3.parse, this.canBeFiltered) {
        let { pick: e2, skip: t3 } = i3;
        e2 && e2.length > 0 && this.translateTagSet(e2, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
      }
      this.applyInheritables(i3);
    } else true === i3 || false === i3 ? this.parse = this.enabled = i3 : l2(`Invalid options argument: ${i3}`);
  }
  applyInheritables(e2) {
    let t2, s2;
    for (t2 of E) s2 = e2[t2], void 0 !== s2 && (this[t2] = s2);
  }
  translateTagSet(e2, t2) {
    if (this.dict) {
      let s2, i3, { tagKeys: n2, tagValues: r2 } = this.dict;
      for (s2 of e2) "string" == typeof s2 ? (i3 = r2.indexOf(s2), -1 === i3 && (i3 = n2.indexOf(Number(s2))), -1 !== i3 && t2.add(Number(n2[i3]))) : t2.add(s2);
    } else for (let s2 of e2) t2.add(s2);
  }
  finalizeFilters() {
    !this.enabled && this.deps.size > 0 ? (this.enabled = true, X(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && X(this.pick, this.deps);
  }
};
var N = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 };
var $ = /* @__PURE__ */ new Map();
var R = class extends _2 {
  static useCached(e2) {
    let t2 = $.get(e2);
    return void 0 !== t2 || (t2 = new this(e2), $.set(e2, t2)), t2;
  }
  constructor(e2) {
    super(), true === e2 ? this.setupFromTrue() : void 0 === e2 ? this.setupFromUndefined() : Array.isArray(e2) ? this.setupFromArray(e2) : "object" == typeof e2 ? this.setupFromObject(e2) : l2(`Invalid options argument ${e2}`), void 0 === this.firstChunkSize && (this.firstChunkSize = s ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
  }
  setupFromUndefined() {
    let e2;
    for (e2 of L) this[e2] = N[e2];
    for (e2 of M) this[e2] = N[e2];
    for (e2 of j) this[e2] = N[e2];
    for (e2 of F) this[e2] = new D(e2, N[e2], void 0, this);
  }
  setupFromTrue() {
    let e2;
    for (e2 of L) this[e2] = N[e2];
    for (e2 of M) this[e2] = N[e2];
    for (e2 of j) this[e2] = true;
    for (e2 of F) this[e2] = new D(e2, true, void 0, this);
  }
  setupFromArray(e2) {
    let t2;
    for (t2 of L) this[t2] = N[t2];
    for (t2 of M) this[t2] = N[t2];
    for (t2 of j) this[t2] = N[t2];
    for (t2 of F) this[t2] = new D(t2, false, void 0, this);
    this.setupGlobalFilters(e2, void 0, P);
  }
  setupFromObject(e2) {
    let t2;
    for (t2 of (P.ifd0 = P.ifd0 || P.image, P.ifd1 = P.ifd1 || P.thumbnail, Object.assign(this, e2), L)) this[t2] = W(e2[t2], N[t2]);
    for (t2 of M) this[t2] = W(e2[t2], N[t2]);
    for (t2 of j) this[t2] = W(e2[t2], N[t2]);
    for (t2 of z) this[t2] = new D(t2, N[t2], e2[t2], this);
    for (t2 of P) this[t2] = new D(t2, N[t2], e2[t2], this.tiff);
    this.setupGlobalFilters(e2.pick, e2.skip, P, F), true === e2.tiff ? this.batchEnableWithBool(P, true) : false === e2.tiff ? this.batchEnableWithUserValue(P, e2) : Array.isArray(e2.tiff) ? this.setupGlobalFilters(e2.tiff, void 0, P) : "object" == typeof e2.tiff && this.setupGlobalFilters(e2.tiff.pick, e2.tiff.skip, P);
  }
  batchEnableWithBool(e2, t2) {
    for (let s2 of e2) this[s2].enabled = t2;
  }
  batchEnableWithUserValue(e2, t2) {
    for (let s2 of e2) {
      let e3 = t2[s2];
      this[s2].enabled = false !== e3 && void 0 !== e3;
    }
  }
  setupGlobalFilters(e2, t2, s2, i3 = s2) {
    if (e2 && e2.length) {
      for (let e3 of i3) this[e3].enabled = false;
      let t3 = K2(e2, s2);
      for (let [e3, s3] of t3) X(this[e3].pick, s3), this[e3].enabled = true;
    } else if (t2 && t2.length) {
      let e3 = K2(t2, s2);
      for (let [t3, s3] of e3) X(this[t3].skip, s3);
    }
  }
  filterNestedSegmentTags() {
    let { ifd0: e2, exif: t2, xmp: s2, iptc: i3, icc: n2 } = this;
    this.makerNote ? t2.deps.add(37500) : t2.skip.add(37500), this.userComment ? t2.deps.add(37510) : t2.skip.add(37510), s2.enabled || e2.skip.add(700), i3.enabled || e2.skip.add(33723), n2.enabled || e2.skip.add(34675);
  }
  traverseTiffDependencyTree() {
    let { ifd0: e2, exif: t2, gps: s2, interop: i3 } = this;
    i3.needed && (t2.deps.add(40965), e2.deps.add(40965)), t2.needed && e2.deps.add(34665), s2.needed && e2.deps.add(34853), this.tiff.enabled = P.some((e3) => true === this[e3].enabled) || this.makerNote || this.userComment;
    for (let e3 of P) this[e3].finalizeFilters();
  }
  get onlyTiff() {
    return !T2.map((e2) => this[e2].enabled).some((e2) => true === e2) && this.tiff.enabled;
  }
  checkLoadedPlugins() {
    for (let e2 of z) this[e2].enabled && !y2.has(e2) && p("segment parser", e2);
  }
};
function K2(e2, t2) {
  let s2, i3, n2, r2, a2 = [];
  for (n2 of t2) {
    for (r2 of (s2 = B.get(n2), i3 = [], s2)) (e2.includes(r2[0]) || e2.includes(r2[1])) && i3.push(r2[0]);
    i3.length && a2.push([n2, i3]);
  }
  return a2;
}
function W(e2, t2) {
  return void 0 !== e2 ? e2 : void 0 !== t2 ? t2 : void 0;
}
function X(e2, t2) {
  for (let s2 of t2) e2.add(s2);
}
e(R, "default", N);
var H2 = class {
  constructor(t2) {
    e(this, "parsers", {}), e(this, "output", {}), e(this, "errors", []), e(this, "pushToErrors", (e2) => this.errors.push(e2)), this.options = R.useCached(t2);
  }
  async read(e2) {
    this.file = await function(e3, t2) {
      return "string" == typeof e3 ? k2(e3, t2) : s && !i2 && e3 instanceof HTMLImageElement ? k2(e3.src, t2) : e3 instanceof Uint8Array || e3 instanceof ArrayBuffer || e3 instanceof DataView ? new c(e3) : s && e3 instanceof Blob ? O(e3, t2, "blob", A2) : void l2("Invalid input argument");
    }(e2, this.options);
  }
  setup() {
    if (this.fileParser) return;
    let { file: e2 } = this, t2 = e2.getUint16(0);
    for (let [s2, i3] of m) if (i3.canHandle(e2, t2)) return this.fileParser = new i3(this.options, this.file, this.parsers), e2[s2] = true;
    this.file.close && this.file.close(), l2("Unknown file format");
  }
  async parse() {
    let { output: e2, errors: t2 } = this;
    return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t2.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t2.length > 0 && (e2.errors = t2), f2(s2 = e2) ? void 0 : s2;
    var s2;
  }
  async executeParsers() {
    let { output: e2 } = this;
    await this.fileParser.parse();
    let t2 = Object.values(this.parsers).map(async (t3) => {
      let s2 = await t3.parse();
      t3.assignToOutput(e2, s2);
    });
    this.options.silentErrors && (t2 = t2.map((e3) => e3.catch(this.pushToErrors))), await Promise.all(t2);
  }
  async extractThumbnail() {
    this.setup();
    let { options: e2, file: t2 } = this, s2 = y2.get("tiff", e2);
    var i3;
    if (t2.tiff ? i3 = { start: 0, type: "tiff" } : t2.jpeg && (i3 = await this.fileParser.getOrFindSegment("tiff")), void 0 === i3) return;
    let n2 = await this.fileParser.ensureSegmentChunk(i3), r2 = this.parsers.tiff = new s2(n2, e2, t2), a2 = await r2.extractThumbnail();
    return t2.close && t2.close(), a2;
  }
};
async function Y(e2, t2) {
  let s2 = new H2(t2);
  return await s2.read(e2), s2.parse();
}
var G = Object.freeze({ __proto__: null, parse: Y, Exifr: H2, fileParsers: m, segmentParsers: y2, fileReaders: b2, tagKeys: B, tagValues: V, tagRevivers: I, createDictionary: x2, extendDictionary: C, fetchUrlAsArrayBuffer: S, readBlobAsArrayBuffer: A2, chunkedProps: L, otherSegments: T2, segments: z, tiffBlocks: P, segmentsAndBlocks: F, tiffExtractables: j, inheritables: E, allFormatters: M, Options: R });
var J = class {
  static findPosition(e2, t2) {
    let s2 = e2.getUint16(t2 + 2) + 2, i3 = "function" == typeof this.headerLength ? this.headerLength(e2, t2, s2) : this.headerLength, n2 = t2 + i3, r2 = s2 - i3;
    return { offset: t2, length: s2, headerLength: i3, start: n2, size: r2, end: n2 + r2 };
  }
  static parse(e2, t2 = {}) {
    return new this(e2, new R({ [this.type]: t2 }), e2).parse();
  }
  normalizeInput(e2) {
    return e2 instanceof c ? e2 : new c(e2);
  }
  constructor(t2, s2 = {}, i3) {
    e(this, "errors", []), e(this, "raw", /* @__PURE__ */ new Map()), e(this, "handleError", (e2) => {
      if (!this.options.silentErrors) throw e2;
      this.errors.push(e2.message);
    }), this.chunk = this.normalizeInput(t2), this.file = i3, this.type = this.constructor.type, this.globalOptions = this.options = s2, this.localOptions = s2[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
  }
  translate() {
    this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
  }
  get output() {
    return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
  }
  translateBlock(e2, t2) {
    let s2 = I.get(t2), i3 = V.get(t2), n2 = B.get(t2), r2 = this.options[t2], a2 = r2.reviveValues && !!s2, h15 = r2.translateValues && !!i3, f3 = r2.translateKeys && !!n2, l3 = {};
    for (let [t3, r3] of e2) a2 && s2.has(t3) ? r3 = s2.get(t3)(r3) : h15 && i3.has(t3) && (r3 = this.translateValue(r3, i3.get(t3))), f3 && n2.has(t3) && (t3 = n2.get(t3) || t3), l3[t3] = r3;
    return l3;
  }
  translateValue(e2, t2) {
    return t2[e2] || t2.DEFAULT || e2;
  }
  assignToOutput(e2, t2) {
    this.assignObjectToOutput(e2, this.constructor.type, t2);
  }
  assignObjectToOutput(e2, t2, s2) {
    if (this.globalOptions.mergeOutput) return Object.assign(e2, s2);
    e2[t2] ? Object.assign(e2[t2], s2) : e2[t2] = s2;
  }
};
e(J, "headerLength", 4), e(J, "type", void 0), e(J, "multiSegment", false), e(J, "canHandle", () => false);
function q2(e2) {
  return 192 === e2 || 194 === e2 || 196 === e2 || 219 === e2 || 221 === e2 || 218 === e2 || 254 === e2;
}
function Q(e2) {
  return e2 >= 224 && e2 <= 239;
}
function Z(e2, t2, s2) {
  for (let [i3, n2] of y2) if (n2.canHandle(e2, t2, s2)) return i3;
}
var ee = class extends class {
  constructor(t2, s2, i3) {
    e(this, "errors", []), e(this, "ensureSegmentChunk", async (e2) => {
      let t3 = e2.start, s3 = e2.size || 65536;
      if (this.file.chunked) if (this.file.available(t3, s3)) e2.chunk = this.file.subarray(t3, s3);
      else try {
        e2.chunk = await this.file.readChunk(t3, s3);
      } catch (t4) {
        l2(`Couldn't read segment: ${JSON.stringify(e2)}. ${t4.message}`);
      }
      else this.file.byteLength > t3 + s3 ? e2.chunk = this.file.subarray(t3, s3) : void 0 === e2.size ? e2.chunk = this.file.subarray(t3) : l2("Segment unreachable: " + JSON.stringify(e2));
      return e2.chunk;
    }), this.extendOptions && this.extendOptions(t2), this.options = t2, this.file = s2, this.parsers = i3;
  }
  injectSegment(e2, t2) {
    this.options[e2].enabled && this.createParser(e2, t2);
  }
  createParser(e2, t2) {
    let s2 = new (y2.get(e2))(t2, this.options, this.file);
    return this.parsers[e2] = s2;
  }
  createParsers(e2) {
    for (let t2 of e2) {
      let { type: e3, chunk: s2 } = t2, i3 = this.options[e3];
      if (i3 && i3.enabled) {
        let t3 = this.parsers[e3];
        t3 && t3.append || t3 || this.createParser(e3, s2);
      }
    }
  }
  async readSegments(e2) {
    let t2 = e2.map(this.ensureSegmentChunk);
    await Promise.all(t2);
  }
} {
  constructor(...t2) {
    super(...t2), e(this, "appSegments", []), e(this, "jpegSegments", []), e(this, "unknownSegments", []);
  }
  static canHandle(e2, t2) {
    return 65496 === t2;
  }
  async parse() {
    await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
  }
  setupSegmentFinderArgs(e2) {
    true === e2 ? (this.findAll = true, this.wanted = new Set(y2.keyList())) : (e2 = void 0 === e2 ? y2.keyList().filter((e3) => this.options[e3].enabled) : e2.filter((e3) => this.options[e3].enabled && y2.has(e3)), this.findAll = false, this.remaining = new Set(e2), this.wanted = new Set(e2)), this.unfinishedMultiSegment = false;
  }
  async findAppSegments(e2 = 0, t2) {
    this.setupSegmentFinderArgs(t2);
    let { file: s2, findAll: i3, wanted: n2, remaining: r2 } = this;
    if (!i3 && this.file.chunked && (i3 = Array.from(n2).some((e3) => {
      let t3 = y2.get(e3), s3 = this.options[e3];
      return t3.multiSegment && s3.multiSegment;
    }), i3 && await this.file.readWhole()), e2 = this.findAppSegmentsInRange(e2, s2.byteLength), !this.options.onlyTiff && s2.chunked) {
      let t3 = false;
      for (; r2.size > 0 && !t3 && (s2.canReadNextChunk || this.unfinishedMultiSegment); ) {
        let { nextChunkOffset: i4 } = s2, n3 = this.appSegments.some((e3) => !this.file.available(e3.offset || e3.start, e3.length || e3.size));
        if (t3 = e2 > i4 && !n3 ? !await s2.readNextChunk(e2) : !await s2.readNextChunk(i4), void 0 === (e2 = this.findAppSegmentsInRange(e2, s2.byteLength))) return;
      }
    }
  }
  findAppSegmentsInRange(e2, t2) {
    t2 -= 2;
    let s2, i3, n2, r2, a2, h15, { file: f3, findAll: l3, wanted: o2, remaining: u3, options: d3 } = this;
    for (; e2 < t2; e2++) if (255 === f3.getUint8(e2)) {
      if (s2 = f3.getUint8(e2 + 1), Q(s2)) {
        if (i3 = f3.getUint16(e2 + 2), n2 = Z(f3, e2, i3), n2 && o2.has(n2) && (r2 = y2.get(n2), a2 = r2.findPosition(f3, e2), h15 = d3[n2], a2.type = n2, this.appSegments.push(a2), !l3 && (r2.multiSegment && h15.multiSegment ? (this.unfinishedMultiSegment = a2.chunkNumber < a2.chunkCount, this.unfinishedMultiSegment || u3.delete(n2)) : u3.delete(n2), 0 === u3.size))) break;
        d3.recordUnknownSegments && (a2 = J.findPosition(f3, e2), a2.marker = s2, this.unknownSegments.push(a2)), e2 += i3 + 1;
      } else if (q2(s2)) {
        if (i3 = f3.getUint16(e2 + 2), 218 === s2 && false !== d3.stopAfterSos) return;
        d3.recordJpegSegments && this.jpegSegments.push({ offset: e2, length: i3, marker: s2 }), e2 += i3 + 1;
      }
    }
    return e2;
  }
  mergeMultiSegments() {
    if (!this.appSegments.some((e3) => e3.multiSegment)) return;
    let e2 = function(e3, t2) {
      let s2, i3, n2, r2 = /* @__PURE__ */ new Map();
      for (let a2 = 0; a2 < e3.length; a2++) s2 = e3[a2], i3 = s2[t2], r2.has(i3) ? n2 = r2.get(i3) : r2.set(i3, n2 = []), n2.push(s2);
      return Array.from(r2);
    }(this.appSegments, "type");
    this.mergedAppSegments = e2.map(([e3, t2]) => {
      let s2 = y2.get(e3, this.options);
      if (s2.handleMultiSegments) {
        return { type: e3, chunk: s2.handleMultiSegments(t2) };
      }
      return t2[0];
    });
  }
  getSegment(e2) {
    return this.appSegments.find((t2) => t2.type === e2);
  }
  async getOrFindSegment(e2) {
    let t2 = this.getSegment(e2);
    return void 0 === t2 && (await this.findAppSegments(0, [e2]), t2 = this.getSegment(e2)), t2;
  }
};
e(ee, "type", "jpeg"), m.set("jpeg", ee);
var te = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
var se = class extends J {
  parseHeader() {
    var e2 = this.chunk.getUint16();
    18761 === e2 ? this.le = true : 19789 === e2 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
  }
  parseTags(e2, t2, s2 = /* @__PURE__ */ new Map()) {
    let { pick: i3, skip: n2 } = this.options[t2];
    i3 = new Set(i3);
    let r2 = i3.size > 0, a2 = 0 === n2.size, h15 = this.chunk.getUint16(e2);
    e2 += 2;
    for (let f3 = 0; f3 < h15; f3++) {
      let h16 = this.chunk.getUint16(e2);
      if (r2) {
        if (i3.has(h16) && (s2.set(h16, this.parseTag(e2, h16, t2)), i3.delete(h16), 0 === i3.size)) break;
      } else !a2 && n2.has(h16) || s2.set(h16, this.parseTag(e2, h16, t2));
      e2 += 12;
    }
    return s2;
  }
  parseTag(e2, t2, s2) {
    let { chunk: i3 } = this, n2 = i3.getUint16(e2 + 2), r2 = i3.getUint32(e2 + 4), a2 = te[n2];
    if (a2 * r2 <= 4 ? e2 += 8 : e2 = i3.getUint32(e2 + 8), (n2 < 1 || n2 > 13) && l2(`Invalid TIFF value type. block: ${s2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${n2}, offset ${e2}`), e2 > i3.byteLength && l2(`Invalid TIFF value offset. block: ${s2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${n2}, offset ${e2} is outside of chunk size ${i3.byteLength}`), 1 === n2) return i3.getUint8Array(e2, r2);
    if (2 === n2) return "" === (h15 = function(e3) {
      for (; e3.endsWith("\0"); ) e3 = e3.slice(0, -1);
      return e3;
    }(h15 = i3.getString(e2, r2)).trim()) ? void 0 : h15;
    var h15;
    if (7 === n2) return i3.getUint8Array(e2, r2);
    if (1 === r2) return this.parseTagValue(n2, e2);
    {
      let t3 = new (function(e3) {
        switch (e3) {
          case 1:
            return Uint8Array;
          case 3:
            return Uint16Array;
          case 4:
            return Uint32Array;
          case 5:
            return Array;
          case 6:
            return Int8Array;
          case 8:
            return Int16Array;
          case 9:
            return Int32Array;
          case 10:
            return Array;
          case 11:
            return Float32Array;
          case 12:
            return Float64Array;
          default:
            return Array;
        }
      }(n2))(r2), s3 = a2;
      for (let i4 = 0; i4 < r2; i4++) t3[i4] = this.parseTagValue(n2, e2), e2 += s3;
      return t3;
    }
  }
  parseTagValue(e2, t2) {
    let { chunk: s2 } = this;
    switch (e2) {
      case 1:
        return s2.getUint8(t2);
      case 3:
        return s2.getUint16(t2);
      case 4:
        return s2.getUint32(t2);
      case 5:
        return s2.getUint32(t2) / s2.getUint32(t2 + 4);
      case 6:
        return s2.getInt8(t2);
      case 8:
        return s2.getInt16(t2);
      case 9:
        return s2.getInt32(t2);
      case 10:
        return s2.getInt32(t2) / s2.getInt32(t2 + 4);
      case 11:
        return s2.getFloat(t2);
      case 12:
        return s2.getDouble(t2);
      case 13:
        return s2.getUint32(t2);
      default:
        l2(`Invalid tiff type ${e2}`);
    }
  }
};
var ie = class extends se {
  static canHandle(e2, t2) {
    return 225 === e2.getUint8(t2 + 1) && 1165519206 === e2.getUint32(t2 + 4) && 0 === e2.getUint16(t2 + 8);
  }
  async parse() {
    this.parseHeader();
    let { options: e2 } = this;
    return e2.ifd0.enabled && await this.parseIfd0Block(), e2.exif.enabled && await this.safeParse("parseExifBlock"), e2.gps.enabled && await this.safeParse("parseGpsBlock"), e2.interop.enabled && await this.safeParse("parseInteropBlock"), e2.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
  }
  safeParse(e2) {
    let t2 = this[e2]();
    return void 0 !== t2.catch && (t2 = t2.catch(this.handleError)), t2;
  }
  findIfd0Offset() {
    void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
  }
  findIfd1Offset() {
    if (void 0 === this.ifd1Offset) {
      this.findIfd0Offset();
      let e2 = this.chunk.getUint16(this.ifd0Offset), t2 = this.ifd0Offset + 2 + 12 * e2;
      this.ifd1Offset = this.chunk.getUint32(t2);
    }
  }
  parseBlock(e2, t2) {
    let s2 = /* @__PURE__ */ new Map();
    return this[t2] = s2, this.parseTags(e2, t2, s2), s2;
  }
  async parseIfd0Block() {
    if (this.ifd0) return;
    let { file: e2 } = this;
    this.findIfd0Offset(), this.ifd0Offset < 8 && l2("Malformed EXIF data"), !e2.chunked && this.ifd0Offset > e2.byteLength && l2(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e2.byteLength}`), e2.tiff && await e2.ensureChunk(this.ifd0Offset, o(this.options));
    let t2 = this.parseBlock(this.ifd0Offset, "ifd0");
    return 0 !== t2.size ? (this.exifOffset = t2.get(34665), this.interopOffset = t2.get(40965), this.gpsOffset = t2.get(34853), this.xmp = t2.get(700), this.iptc = t2.get(33723), this.icc = t2.get(34675), this.options.sanitize && (t2.delete(34665), t2.delete(40965), t2.delete(34853), t2.delete(700), t2.delete(33723), t2.delete(34675)), t2) : void 0;
  }
  async parseExifBlock() {
    if (this.exif) return;
    if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset) return;
    this.file.tiff && await this.file.ensureChunk(this.exifOffset, o(this.options));
    let e2 = this.parseBlock(this.exifOffset, "exif");
    return this.interopOffset || (this.interopOffset = e2.get(40965)), this.makerNote = e2.get(37500), this.userComment = e2.get(37510), this.options.sanitize && (e2.delete(40965), e2.delete(37500), e2.delete(37510)), this.unpack(e2, 41728), this.unpack(e2, 41729), e2;
  }
  unpack(e2, t2) {
    let s2 = e2.get(t2);
    s2 && 1 === s2.length && e2.set(t2, s2[0]);
  }
  async parseGpsBlock() {
    if (this.gps) return;
    if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset) return;
    let e2 = this.parseBlock(this.gpsOffset, "gps");
    return e2 && e2.has(2) && e2.has(4) && (e2.set("latitude", ne(...e2.get(2), e2.get(1))), e2.set("longitude", ne(...e2.get(4), e2.get(3)))), e2;
  }
  async parseInteropBlock() {
    if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, "interop");
  }
  async parseThumbnailBlock(e2 = false) {
    if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e2)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
  }
  async extractThumbnail() {
    if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1) return;
    let e2 = this.ifd1.get(513), t2 = this.ifd1.get(514);
    return this.chunk.getUint8Array(e2, t2);
  }
  get image() {
    return this.ifd0;
  }
  get thumbnail() {
    return this.ifd1;
  }
  createOutput() {
    let e2, t2, s2, i3 = {};
    for (t2 of P) if (e2 = this[t2], !f2(e2)) if (s2 = this.canTranslate ? this.translateBlock(e2, t2) : Object.fromEntries(e2), this.options.mergeOutput) {
      if ("ifd1" === t2) continue;
      Object.assign(i3, s2);
    } else i3[t2] = s2;
    return this.makerNote && (i3.makerNote = this.makerNote), this.userComment && (i3.userComment = this.userComment), i3;
  }
  assignToOutput(e2, t2) {
    if (this.globalOptions.mergeOutput) Object.assign(e2, t2);
    else for (let [s2, i3] of Object.entries(t2)) this.assignObjectToOutput(e2, s2, i3);
  }
};
function ne(e2, t2, s2, i3) {
  var n2 = e2 + t2 / 60 + s2 / 3600;
  return "S" !== i3 && "W" !== i3 || (n2 *= -1), n2;
}
e(ie, "type", "tiff"), e(ie, "headerLength", 10), y2.set("tiff", ie);
var re = Object.freeze({ __proto__: null, default: G, Exifr: H2, fileParsers: m, segmentParsers: y2, fileReaders: b2, tagKeys: B, tagValues: V, tagRevivers: I, createDictionary: x2, extendDictionary: C, fetchUrlAsArrayBuffer: S, readBlobAsArrayBuffer: A2, chunkedProps: L, otherSegments: T2, segments: z, tiffBlocks: P, segmentsAndBlocks: F, tiffExtractables: j, inheritables: E, allFormatters: M, Options: R, parse: Y });
var ae = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false };
var he = Object.assign({}, ae, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
var le = Object.assign({}, ae, { tiff: false, ifd1: true, mergeOutput: false });
var de = Object.assign({}, ae, { firstChunkSize: 4e4, ifd0: [274] });
async function ce(e2) {
  let t2 = new H2(de);
  await t2.read(e2);
  let s2 = await t2.parse();
  if (s2 && s2.ifd0) return s2.ifd0[274];
}
var pe = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
var ge = true;
var me = true;
if ("object" == typeof navigator) {
  let e2 = navigator.userAgent;
  if (e2.includes("iPad") || e2.includes("iPhone")) {
    let t2 = e2.match(/OS (\d+)_(\d+)/);
    if (t2) {
      let [, e3, s2] = t2, i3 = Number(e3) + 0.1 * Number(s2);
      ge = i3 < 13.4, me = false;
    }
  } else if (e2.includes("OS X 10")) {
    let [, t2] = e2.match(/OS X 10[_.](\d+)/);
    ge = me = Number(t2) < 15;
  }
  if (e2.includes("Chrome/")) {
    let [, t2] = e2.match(/Chrome\/(\d+)/);
    ge = me = Number(t2) < 81;
  } else if (e2.includes("Firefox/")) {
    let [, t2] = e2.match(/Firefox\/(\d+)/);
    ge = me = Number(t2) < 77;
  }
}
async function ye(e2) {
  let t2 = await ce(e2);
  return Object.assign({ canvas: ge, css: me }, pe[t2]);
}
var be = class extends c {
  constructor(...t2) {
    super(...t2), e(this, "ranges", new we()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
  }
  _tryExtend(e2, t2, s2) {
    if (0 === e2 && 0 === this.byteLength && s2) {
      let e3 = new DataView(s2.buffer || s2, s2.byteOffset, s2.byteLength);
      this._swapDataView(e3);
    } else {
      let s3 = e2 + t2;
      if (s3 > this.byteLength) {
        let { dataView: e3 } = this._extend(s3);
        this._swapDataView(e3);
      }
    }
  }
  _extend(e2) {
    let t2;
    t2 = a ? r.allocUnsafe(e2) : new Uint8Array(e2);
    let s2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
    return t2.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t2, dataView: s2 };
  }
  subarray(e2, t2, s2 = false) {
    return t2 = t2 || this._lengthToEnd(e2), s2 && this._tryExtend(e2, t2), this.ranges.add(e2, t2), super.subarray(e2, t2);
  }
  set(e2, t2, s2 = false) {
    s2 && this._tryExtend(t2, e2.byteLength, e2);
    let i3 = super.set(e2, t2);
    return this.ranges.add(t2, i3.byteLength), i3;
  }
  async ensureChunk(e2, t2) {
    this.chunked && (this.ranges.available(e2, t2) || await this.readChunk(e2, t2));
  }
  available(e2, t2) {
    return this.ranges.available(e2, t2);
  }
};
var we = class {
  constructor() {
    e(this, "list", []);
  }
  get length() {
    return this.list.length;
  }
  add(e2, t2, s2 = 0) {
    let i3 = e2 + t2, n2 = this.list.filter((t3) => ke(e2, t3.offset, i3) || ke(e2, t3.end, i3));
    if (n2.length > 0) {
      e2 = Math.min(e2, ...n2.map((e3) => e3.offset)), i3 = Math.max(i3, ...n2.map((e3) => e3.end)), t2 = i3 - e2;
      let s3 = n2.shift();
      s3.offset = e2, s3.length = t2, s3.end = i3, this.list = this.list.filter((e3) => !n2.includes(e3));
    } else this.list.push({ offset: e2, length: t2, end: i3 });
  }
  available(e2, t2) {
    let s2 = e2 + t2;
    return this.list.some((t3) => t3.offset <= e2 && s2 <= t3.end);
  }
};
function ke(e2, t2, s2) {
  return e2 <= t2 && t2 <= s2;
}
var Oe = class extends be {
  constructor(t2, s2) {
    super(0), e(this, "chunksRead", 0), this.input = t2, this.options = s2;
  }
  async readWhole() {
    this.chunked = false, await this.readChunk(this.nextChunkOffset);
  }
  async readChunked() {
    this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
  }
  async readNextChunk(e2 = this.nextChunkOffset) {
    if (this.fullyRead) return this.chunksRead++, false;
    let t2 = this.options.chunkSize, s2 = await this.readChunk(e2, t2);
    return !!s2 && s2.byteLength === t2;
  }
  async readChunk(e2, t2) {
    if (this.chunksRead++, 0 !== (t2 = this.safeWrapAddress(e2, t2))) return this._readChunk(e2, t2);
  }
  safeWrapAddress(e2, t2) {
    return void 0 !== this.size && e2 + t2 > this.size ? Math.max(0, this.size - e2) : t2;
  }
  get nextChunkOffset() {
    if (0 !== this.ranges.list.length) return this.ranges.list[0].length;
  }
  get canReadNextChunk() {
    return this.chunksRead < this.options.chunkLimit;
  }
  get fullyRead() {
    return void 0 !== this.size && this.nextChunkOffset === this.size;
  }
  read() {
    return this.options.chunked ? this.readChunked() : this.readWhole();
  }
  close() {
  }
};
b2.set("blob", class extends Oe {
  async readWhole() {
    this.chunked = false;
    let e2 = await A2(this.input);
    this._swapArrayBuffer(e2);
  }
  readChunked() {
    return this.chunked = true, this.size = this.input.size, super.readChunked();
  }
  async _readChunk(e2, t2) {
    let s2 = t2 ? e2 + t2 : void 0, i3 = this.input.slice(e2, s2), n2 = await A2(i3);
    return this.set(n2, e2, true);
  }
});

// node_modules/@uppy/thumbnail-generator/package.json
var package_default4 = {
  name: "@uppy/thumbnail-generator",
  description: "Uppy plugin that generates small previews of images to show on your upload UI.",
  version: "4.2.2",
  license: "MIT",
  main: "lib/index.js",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    typecheck: "tsc --build",
    test: "vitest run --environment=jsdom --silent='passed-only'"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "thumbnail",
    "preview",
    "resize"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    exifr: "^7.0.0"
  },
  devDependencies: {
    jsdom: "^26.1.0",
    "namespace-emitter": "2.0.1",
    typescript: "^5.8.3",
    vitest: "^3.2.4"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  }
};

// node_modules/@uppy/thumbnail-generator/lib/locale.js
var locale_default2 = {
  strings: {
    generatingThumbnails: "Generating thumbnails..."
  }
};

// node_modules/@uppy/thumbnail-generator/lib/index.js
function canvasToBlob(canvas, type, quality) {
  try {
    canvas.getContext("2d").getImageData(0, 0, 1, 1);
  } catch (err) {
    if (err.code === 18) {
      return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
    }
  }
  if (canvas.toBlob) {
    return new Promise((resolve) => {
      canvas.toBlob(resolve, type, quality);
    }).then((blob) => {
      if (blob === null) {
        throw new Error("cannot read image, probably an svg with external resources");
      }
      return blob;
    });
  }
  return Promise.resolve().then(() => {
    return dataURItoBlob_default(canvas.toDataURL(type, quality), {});
  }).then((blob) => {
    if (blob === null) {
      throw new Error("could not extract blob, probably an old browser");
    }
    return blob;
  });
}
function rotateImage(image, translate) {
  let w2 = image.width;
  let h15 = image.height;
  if (translate.deg === 90 || translate.deg === 270) {
    w2 = image.height;
    h15 = image.width;
  }
  const canvas = document.createElement("canvas");
  canvas.width = w2;
  canvas.height = h15;
  const context = canvas.getContext("2d");
  context.translate(w2 / 2, h15 / 2);
  if (translate.canvas) {
    context.rotate(translate.rad);
    context.scale(translate.scaleX, translate.scaleY);
  }
  context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
  return canvas;
}
function protect(image) {
  const ratio = image.width / image.height;
  const maxSquare = 5e6;
  const maxSize = 4096;
  let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
  let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));
  if (maxW > maxSize) {
    maxW = maxSize;
    maxH = Math.round(maxW / ratio);
  }
  if (maxH > maxSize) {
    maxH = maxSize;
    maxW = Math.round(ratio * maxH);
  }
  if (image.width > maxW) {
    const canvas = document.createElement("canvas");
    canvas.width = maxW;
    canvas.height = maxH;
    canvas.getContext("2d").drawImage(image, 0, 0, maxW, maxH);
    return canvas;
  }
  return image;
}
var defaultOptions3 = {
  thumbnailWidth: null,
  thumbnailHeight: null,
  thumbnailType: "image/jpeg",
  waitForThumbnailsBeforeUpload: false,
  lazy: false
};
var ThumbnailGenerator = class extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, { ...defaultOptions3, ...opts });
    __publicField(this, "queue");
    __publicField(this, "queueProcessing");
    __publicField(this, "defaultThumbnailDimension");
    __publicField(this, "thumbnailType");
    __publicField(this, "onFileAdded", (file) => {
      if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
        this.addToQueue(file.id);
      }
    });
    /**
     * Cancel a lazy request for a thumbnail if the thumbnail has not yet been generated.
     */
    __publicField(this, "onCancelRequest", (file) => {
      const index = this.queue.indexOf(file.id);
      if (index !== -1) {
        this.queue.splice(index, 1);
      }
    });
    /**
     * Clean up the thumbnail for a file. Cancel lazy requests and free the thumbnail URL.
     */
    __publicField(this, "onFileRemoved", (file) => {
      const index = this.queue.indexOf(file.id);
      if (index !== -1) {
        this.queue.splice(index, 1);
      }
      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    });
    __publicField(this, "onRestored", () => {
      const restoredFiles = this.uppy.getFiles().filter((file) => file.isRestored);
      restoredFiles.forEach((file) => {
        if (!file.preview || isObjectURL(file.preview)) {
          this.addToQueue(file.id);
        }
      });
    });
    __publicField(this, "onAllFilesRemoved", () => {
      this.queue = [];
    });
    __publicField(this, "waitUntilAllProcessed", (fileIDs) => {
      fileIDs.forEach((fileID) => {
        const file = this.uppy.getFile(fileID);
        this.uppy.emit("preprocess-progress", file, {
          mode: "indeterminate",
          message: this.i18n("generatingThumbnails")
        });
      });
      const emitPreprocessCompleteForAll = () => {
        fileIDs.forEach((fileID) => {
          const file = this.uppy.getFile(fileID);
          this.uppy.emit("preprocess-complete", file);
        });
      };
      return new Promise((resolve) => {
        if (this.queueProcessing) {
          this.uppy.once("thumbnail:all-generated", () => {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    });
    this.type = "modifier";
    this.id = this.opts.id || "ThumbnailGenerator";
    this.title = "Thumbnail Generator";
    this.queue = [];
    this.queueProcessing = false;
    this.defaultThumbnailDimension = 200;
    this.thumbnailType = this.opts.thumbnailType;
    this.defaultLocale = locale_default2;
    this.i18nInit();
    if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
    }
  }
  createThumbnail(file, targetWidth, targetHeight) {
    const originalUrl = URL.createObjectURL(file.data);
    const onload = new Promise((resolve, reject) => {
      const image = new Image();
      image.src = originalUrl;
      image.addEventListener("load", () => {
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener("error", (event) => {
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error("Could not create thumbnail"));
      });
    });
    const orientationPromise = ye(file.data).catch(() => 1);
    return Promise.all([onload, orientationPromise]).then(([image, orientation]) => {
      const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
      const rotatedImage = rotateImage(image, orientation);
      const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
      return canvasToBlob(resizedImage, this.thumbnailType, 80);
    }).then((blob) => {
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  getProportionalDimensions(img, width, height, deg) {
    let aspect = img.width / img.height;
    if (deg === 90 || deg === 270) {
      aspect = img.height / img.width;
    }
    if (width != null) {
      return {
        width,
        height: Math.round(width / aspect)
      };
    }
    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height
      };
    }
    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  resizeImage(image, targetWidth, targetHeight) {
    let img = protect(image);
    let steps = Math.ceil(Math.log2(img.width / targetWidth));
    if (steps < 1) {
      steps = 1;
    }
    let sW = targetWidth * 2 ** (steps - 1);
    let sH = targetHeight * 2 ** (steps - 1);
    const x3 = 2;
    while (steps--) {
      const canvas = document.createElement("canvas");
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext("2d").drawImage(img, 0, 0, sW, sH);
      img = canvas;
      sW = Math.round(sW / x3);
      sH = Math.round(sH / x3);
    }
    return img;
  }
  /**
   * Set the preview URL for a file.
   */
  setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, { preview });
  }
  addToQueue(fileID) {
    this.queue.push(fileID);
    if (this.queueProcessing === false) {
      this.processQueue();
    }
  }
  processQueue() {
    this.queueProcessing = true;
    if (this.queue.length > 0) {
      const current = this.uppy.getFile(this.queue.shift());
      if (!current) {
        this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error");
        return Promise.resolve();
      }
      return this.requestThumbnail(current).catch(() => {
      }).then(() => this.processQueue());
    }
    this.queueProcessing = false;
    this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue");
    this.uppy.emit("thumbnail:all-generated");
    return Promise.resolve();
  }
  requestThumbnail(file) {
    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((preview) => {
        this.setPreviewURL(file.id, preview);
        this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
        this.uppy.emit("thumbnail:generated", this.uppy.getFile(file.id), preview);
      }).catch((err) => {
        this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, "warning");
        this.uppy.log(err, "warning");
        this.uppy.emit("thumbnail:error", this.uppy.getFile(file.id), err);
      });
    }
    return Promise.resolve();
  }
  install() {
    this.uppy.on("file-removed", this.onFileRemoved);
    this.uppy.on("cancel-all", this.onAllFilesRemoved);
    if (this.opts.lazy) {
      this.uppy.on("thumbnail:request", this.onFileAdded);
      this.uppy.on("thumbnail:cancel", this.onCancelRequest);
    } else {
      this.uppy.on("thumbnail:request", this.onFileAdded);
      this.uppy.on("file-added", this.onFileAdded);
      this.uppy.on("restored", this.onRestored);
    }
    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  }
  uninstall() {
    this.uppy.off("file-removed", this.onFileRemoved);
    this.uppy.off("cancel-all", this.onAllFilesRemoved);
    if (this.opts.lazy) {
      this.uppy.off("thumbnail:request", this.onFileAdded);
      this.uppy.off("thumbnail:cancel", this.onCancelRequest);
    } else {
      this.uppy.off("thumbnail:request", this.onFileAdded);
      this.uppy.off("file-added", this.onFileAdded);
      this.uppy.off("restored", this.onRestored);
    }
    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  }
};
__publicField(ThumbnailGenerator, "VERSION", package_default4.version);

// node_modules/@uppy/utils/lib/findAllDOMElements.js
function findAllDOMElements(element) {
  if (typeof element === "string") {
    const elements = document.querySelectorAll(element);
    return elements.length === 0 ? null : Array.from(elements);
  }
  if (typeof element === "object" && isDOMElement(element)) {
    return [element];
  }
  return null;
}
var findAllDOMElements_default = findAllDOMElements;

// node_modules/@uppy/utils/lib/toArray.js
var toArray_default = Array.from;

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/fallbackApi.js
function fallbackApi(dataTransfer) {
  const files = toArray_default(dataTransfer.files);
  return Promise.resolve(files);
}

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js
function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, { onSuccess }) {
  directoryReader.readEntries(
    (entries) => {
      const newEntries = [...oldEntries, ...entries];
      if (entries.length) {
        queueMicrotask(() => {
          getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, { onSuccess });
        });
      } else {
        onSuccess(newEntries);
      }
    },
    // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
    (error) => {
      logDropError(error);
      onSuccess(oldEntries);
    }
  );
}

// node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js
function getAsFileSystemHandleFromEntry(entry, logDropError) {
  if (entry == null)
    return entry;
  return {
    kind: entry.isFile ? "file" : entry.isDirectory ? "directory" : void 0,
    name: entry.name,
    getFile() {
      return new Promise((resolve, reject) => entry.file(resolve, reject));
    },
    async *values() {
      const directoryReader = entry.createReader();
      const entries = await new Promise((resolve) => {
        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
          onSuccess: (dirEntries) => resolve(dirEntries.map((file) => getAsFileSystemHandleFromEntry(file, logDropError)))
        });
      });
      yield* entries;
    },
    isSameEntry: void 0
  };
}
async function* createPromiseToAddFileOrParseDirectory(entry, relativePath, lastResortFile = void 0) {
  const getNextRelativePath = () => `${relativePath}/${entry.name}`;
  if (entry.kind === "file") {
    const file = await entry.getFile();
    if (file != null) {
      ;
      file.relativePath = relativePath ? getNextRelativePath() : null;
      yield file;
    } else if (lastResortFile != null)
      yield lastResortFile;
  } else if (entry.kind === "directory") {
    for await (const handle of entry.values()) {
      yield* createPromiseToAddFileOrParseDirectory(handle, relativePath ? getNextRelativePath() : entry.name);
    }
  } else if (lastResortFile != null)
    yield lastResortFile;
}
async function* getFilesFromDataTransfer(dataTransfer, logDropError) {
  const fileSystemHandles = await Promise.all(Array.from(dataTransfer.items, async (item) => {
    let fileSystemHandle;
    const getAsEntry = () => typeof item.getAsEntry === "function" ? item.getAsEntry() : item.webkitGetAsEntry();
    fileSystemHandle ?? (fileSystemHandle = getAsFileSystemHandleFromEntry(getAsEntry(), logDropError));
    return {
      fileSystemHandle,
      lastResortFile: item.getAsFile()
      // can be used as a fallback in case other methods fail
    };
  }));
  for (const { lastResortFile, fileSystemHandle } of fileSystemHandles) {
    if (fileSystemHandle != null) {
      try {
        yield* createPromiseToAddFileOrParseDirectory(fileSystemHandle, "", lastResortFile);
      } catch (err) {
        if (lastResortFile != null) {
          yield lastResortFile;
        } else {
          logDropError(err);
        }
      }
    } else if (lastResortFile != null)
      yield lastResortFile;
  }
}

// node_modules/@uppy/utils/lib/getDroppedFiles/index.js
async function getDroppedFiles(dataTransfer, options) {
  const logDropError = (options == null ? void 0 : options.logDropError) ?? Function.prototype;
  try {
    const accumulator = [];
    for await (const file of getFilesFromDataTransfer(dataTransfer, logDropError)) {
      accumulator.push(file);
    }
    return accumulator;
  } catch {
    return fallbackApi(dataTransfer);
  }
}

// node_modules/@uppy/dashboard/node_modules/nanoid/non-secure/index.js
var urlAlphabet2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid2 = (size = 21) => {
  let id = "";
  let i3 = size | 0;
  while (i3--) {
    id += urlAlphabet2[Math.random() * 64 | 0];
  }
  return id;
};

// node_modules/@uppy/dashboard/package.json
var package_default5 = {
  name: "@uppy/dashboard",
  description: "Universal UI plugin for Uppy.",
  version: "4.4.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build",
    test: "vitest run --silent='passed-only'",
    "test:e2e": "vitest watch --project browser --browser.headless false"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dashboard",
    "ui"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@transloadit/prettier-bytes": "^0.3.4",
    "@uppy/informer": "^4.3.2",
    "@uppy/provider-views": "^4.5.2",
    "@uppy/status-bar": "^4.2.2",
    "@uppy/thumbnail-generator": "^4.2.2",
    "@uppy/utils": "^6.2.2",
    classnames: "^2.2.6",
    lodash: "^4.17.21",
    nanoid: "^5.0.9",
    preact: "^10.5.13",
    "shallow-equal": "^3.0.0"
  },
  devDependencies: {
    "@uppy/core": "^4.5.2",
    "@uppy/google-drive": "^4.4.2",
    "@uppy/status-bar": "^4.2.2",
    "@uppy/url": "^4.3.2",
    "@uppy/webcam": "^4.3.2",
    "@vitest/browser": "^3.2.4",
    cssnano: "^7.0.7",
    jsdom: "^26.1.0",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    "resize-observer-polyfill": "^1.5.0",
    sass: "^1.89.2",
    typescript: "^5.8.3",
    vitest: "^3.2.4"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  }
};

// node_modules/@uppy/utils/lib/isDragDropSupported.js
function isDragDropSupported() {
  const div = document.body;
  if (!("draggable" in div) || !("ondragstart" in div && "ondrop" in div)) {
    return false;
  }
  if (!("FormData" in window)) {
    return false;
  }
  if (!("FileReader" in window)) {
    return false;
  }
  return true;
}

// node_modules/@uppy/dashboard/lib/components/Dashboard.js
var import_classnames14 = __toESM(require_classnames(), 1);

// node_modules/@uppy/dashboard/lib/components/AddFiles.js
var AddFiles = class extends x {
  constructor() {
    super(...arguments);
    __publicField(this, "fileInput", null);
    __publicField(this, "folderInput", null);
    __publicField(this, "mobilePhotoFileInput", null);
    __publicField(this, "mobileVideoFileInput", null);
    __publicField(this, "triggerFileInputClick", () => {
      var _a;
      (_a = this.fileInput) == null ? void 0 : _a.click();
    });
    __publicField(this, "triggerFolderInputClick", () => {
      var _a;
      (_a = this.folderInput) == null ? void 0 : _a.click();
    });
    __publicField(this, "triggerVideoCameraInputClick", () => {
      var _a;
      (_a = this.mobileVideoFileInput) == null ? void 0 : _a.click();
    });
    __publicField(this, "triggerPhotoCameraInputClick", () => {
      var _a;
      (_a = this.mobilePhotoFileInput) == null ? void 0 : _a.click();
    });
    __publicField(this, "onFileInputChange", (event) => {
      this.props.handleInputChange(event);
      event.currentTarget.value = "";
    });
    __publicField(this, "renderHiddenInput", (isFolder, refCallback) => {
      var _a;
      return u("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        // @ts-expect-error default types don't yet know about the `webkitdirectory` property
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: this.props.maxNumberOfFiles !== 1,
        onChange: this.onFileInputChange,
        accept: (_a = this.props.allowedFileTypes) == null ? void 0 : _a.join(", "),
        ref: refCallback
      });
    });
    __publicField(this, "renderHiddenCameraInput", (type, nativeCameraFacingMode, refCallback) => {
      const typeToAccept = { photo: "image/*", video: "video/*" };
      const accept = typeToAccept[type];
      return u("input", { className: "uppy-Dashboard-input", hidden: true, "aria-hidden": "true", tabIndex: -1, type: "file", name: `camera-${type}`, onChange: this.onFileInputChange, capture: nativeCameraFacingMode === "" ? "environment" : nativeCameraFacingMode, accept, ref: refCallback });
    });
    __publicField(this, "renderMyDeviceAcquirer", () => {
      return u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MyDevice", children: u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": true, onClick: this.triggerFileInputClick, children: [u("div", { className: "uppy-DashboardTab-inner", children: u("svg", { className: "uppy-DashboardTab-iconMyDevice", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { d: "M8.45 22.087l-1.305-6.674h17.678l-1.572 6.674H8.45zm4.975-12.412l1.083 1.765a.823.823 0 00.715.386h7.951V13.5H8.587V9.675h4.838zM26.043 13.5h-1.195v-2.598c0-.463-.336-.75-.798-.75h-8.356l-1.082-1.766A.823.823 0 0013.897 8H7.728c-.462 0-.815.256-.815.718V13.5h-.956a.97.97 0 00-.746.37.972.972 0 00-.19.81l1.724 8.565c.095.44.484.755.933.755H24c.44 0 .824-.3.929-.727l2.043-8.568a.972.972 0 00-.176-.825.967.967 0 00-.753-.38z", fill: "currentcolor", "fill-rule": "evenodd" }) }) }), u("div", { className: "uppy-DashboardTab-name", children: this.props.i18n("myDevice") })] }) });
    });
    __publicField(this, "renderPhotoCamera", () => {
      return u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobilePhotoCamera", children: u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": true, onClick: this.triggerPhotoCameraInputClick, children: [u("div", { className: "uppy-DashboardTab-inner", children: u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", fill: "#02B383", "fill-rule": "nonzero" }) }) }), u("div", { className: "uppy-DashboardTab-name", children: this.props.i18n("takePictureBtn") })] }) });
    });
    __publicField(this, "renderVideoCamera", () => {
      return u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobileVideoCamera", children: u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": true, onClick: this.triggerVideoCameraInputClick, children: [u("div", { className: "uppy-DashboardTab-inner", children: u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { fill: "#FF675E", fillRule: "nonzero", d: "m21.254 14.277 2.941-2.588c.797-.313 1.243.818 1.09 1.554-.01 2.094.02 4.189-.017 6.282-.126.915-1.145 1.08-1.58.34l-2.434-2.142c-.192.287-.504 1.305-.738.468-.104-1.293-.028-2.596-.05-3.894.047-.312.381.823.426 1.069.063-.384.206-.744.362-1.09zm-12.939-3.73c3.858.013 7.717-.025 11.574.02.912.129 1.492 1.237 1.351 2.217-.019 2.412.04 4.83-.03 7.239-.17 1.025-1.166 1.59-2.029 1.429-3.705-.012-7.41.025-11.114-.019-.913-.129-1.492-1.237-1.352-2.217.018-2.404-.036-4.813.029-7.214.136-.82.83-1.473 1.571-1.454z " }) }) }), u("div", { className: "uppy-DashboardTab-name", children: this.props.i18n("recordVideoBtn") })] }) });
    });
    __publicField(this, "renderBrowseButton", (text, onClickFn) => {
      const numberOfAcquirers = this.props.acquirers.length;
      return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-browse", onClick: onClickFn, "data-uppy-super-focusable": numberOfAcquirers === 0, children: text });
    });
    __publicField(this, "renderDropPasteBrowseTagline", (numberOfAcquirers) => {
      const browseFiles = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick);
      const browseFolders = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick);
      const lowerFMSelectionType = this.props.fileManagerSelectionType;
      const camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1);
      return u("div", { class: "uppy-Dashboard-AddFiles-title", children: this.props.disableLocalFiles ? this.props.i18n("importFiles") : numberOfAcquirers > 0 ? this.props.i18nArray(`dropPasteImport${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }) : this.props.i18nArray(`dropPaste${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }) });
    });
    __publicField(this, "renderAcquirer", (acquirer) => {
      var _a;
      return u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": acquirer.id, children: u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-cy": acquirer.id, "aria-controls": `uppy-DashboardContent-panel--${acquirer.id}`, "aria-selected": ((_a = this.props.activePickerPanel) == null ? void 0 : _a.id) === acquirer.id, "data-uppy-super-focusable": true, onClick: () => this.props.showPanel(acquirer.id), children: [u("div", { className: "uppy-DashboardTab-inner", children: acquirer.icon() }), u("div", { className: "uppy-DashboardTab-name", children: acquirer.name })] }) });
    });
    __publicField(this, "renderAcquirers", (acquirers) => {
      const acquirersWithoutLastTwo = [...acquirers];
      const lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return u(k, { children: [acquirersWithoutLastTwo.map((acquirer) => this.renderAcquirer(acquirer)), u("span", { role: "presentation", style: { "white-space": "nowrap" }, children: lastTwoAcquirers.map((acquirer) => this.renderAcquirer(acquirer)) })] });
    });
    __publicField(this, "renderSourcesList", (acquirers, disableLocalFiles) => {
      const { showNativePhotoCameraButton, showNativeVideoCameraButton } = this.props;
      let list = [];
      const myDeviceKey = "myDevice";
      if (!disableLocalFiles)
        list.push({
          key: myDeviceKey,
          elements: this.renderMyDeviceAcquirer()
        });
      if (showNativePhotoCameraButton)
        list.push({
          key: "nativePhotoCameraButton",
          elements: this.renderPhotoCamera()
        });
      if (showNativeVideoCameraButton)
        list.push({
          key: "nativePhotoCameraButton",
          elements: this.renderVideoCamera()
        });
      list.push(...acquirers.map((acquirer) => ({
        key: acquirer.id,
        elements: this.renderAcquirer(acquirer)
      })));
      const hasOnlyMyDevice = list.length === 1 && list[0].key === myDeviceKey;
      if (hasOnlyMyDevice)
        list = [];
      const listWithoutLastTwo = [...list];
      const lastTwo = listWithoutLastTwo.splice(list.length - 2, list.length);
      return u(k, { children: [this.renderDropPasteBrowseTagline(list.length), u("div", { className: "uppy-Dashboard-AddFiles-list", role: "tablist", children: [listWithoutLastTwo.map(({ key, elements }) => u(k, { children: elements }, key)), u("span", { role: "presentation", style: { "white-space": "nowrap" }, children: lastTwo.map(({ key, elements }) => u(k, { children: elements }, key)) })] })] });
    });
  }
  [Symbol.for("uppy test: disable unused locale key warning")]() {
    this.props.i18nArray("dropPasteBoth");
    this.props.i18nArray("dropPasteFiles");
    this.props.i18nArray("dropPasteFolders");
    this.props.i18nArray("dropPasteImportBoth");
    this.props.i18nArray("dropPasteImportFiles");
    this.props.i18nArray("dropPasteImportFolders");
  }
  renderPoweredByUppy() {
    const { i18nArray } = this.props;
    const uppyBranding = u("span", { children: [u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-poweredByIcon", width: "11", height: "11", viewBox: "0 0 11 11", children: u("path", { d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z", fillRule: "evenodd" }) }), u("span", { className: "uppy-Dashboard-poweredByUppy", children: "Uppy" })] });
    const linkText = i18nArray("poweredBy", { uppy: uppyBranding });
    return u("a", { tabIndex: -1, href: "https://uppy.io", rel: "noreferrer noopener", target: "_blank", className: "uppy-Dashboard-poweredBy", children: linkText });
  }
  render() {
    const { showNativePhotoCameraButton, showNativeVideoCameraButton, nativeCameraFacingMode } = this.props;
    return u("div", { className: "uppy-Dashboard-AddFiles", children: [this.renderHiddenInput(false, (ref) => {
      this.fileInput = ref;
    }), this.renderHiddenInput(true, (ref) => {
      this.folderInput = ref;
    }), showNativePhotoCameraButton && this.renderHiddenCameraInput("photo", nativeCameraFacingMode, (ref) => {
      this.mobilePhotoFileInput = ref;
    }), showNativeVideoCameraButton && this.renderHiddenCameraInput("video", nativeCameraFacingMode, (ref) => {
      this.mobileVideoFileInput = ref;
    }), this.renderSourcesList(this.props.acquirers, this.props.disableLocalFiles), u("div", { className: "uppy-Dashboard-AddFiles-info", children: [this.props.note && u("div", { className: "uppy-Dashboard-note", children: this.props.note }), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy()] })] });
  }
};
var AddFiles_default = AddFiles;

// node_modules/@uppy/dashboard/lib/components/AddFilesPanel.js
var import_classnames8 = __toESM(require_classnames(), 1);
var AddFilesPanel = (props) => {
  return u("div", { className: (0, import_classnames8.default)("uppy-Dashboard-AddFilesPanel", props.className), "data-uppy-panelType": "AddFiles", "aria-hidden": !props.showAddFilesPanel, children: [u("div", { className: "uppy-DashboardContent-bar", children: [u("div", {
    className: "uppy-DashboardContent-title",
    // biome-ignore lint/a11y/useSemanticElements: ...
    role: "heading",
    "aria-level": 1,
    children: props.i18n("addingMoreFiles")
  }), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => props.toggleAddFilesPanel(false), children: props.i18n("back") })] }), u(AddFiles_default, { ...props })] });
};
var AddFilesPanel_default = AddFilesPanel;

// node_modules/@uppy/dashboard/lib/components/EditorPanel.js
var import_classnames9 = __toESM(require_classnames(), 1);
function EditorPanel(props) {
  const file = props.files[props.fileCardFor];
  const handleCancel = () => {
    props.uppy.emit("file-editor:cancel", file);
    props.closeFileEditor();
  };
  return u("div", { className: (0, import_classnames9.default)("uppy-DashboardContent-panel", props.className), role: "tabpanel", "data-uppy-panelType": "FileEditor", id: "uppy-DashboardContent-panel--editor", children: [u("div", { className: "uppy-DashboardContent-bar", children: [u("div", {
    className: "uppy-DashboardContent-title",
    // biome-ignore lint/a11y/useSemanticElements: ...
    role: "heading",
    "aria-level": 1,
    children: props.i18nArray("editing", {
      file: u("span", { className: "uppy-DashboardContent-titleFile", children: file.meta ? file.meta.name : file.name })
    })
  }), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: handleCancel, children: props.i18n("cancel") }), u("button", { className: "uppy-DashboardContent-save", type: "button", onClick: props.saveFileEditor, children: props.i18n("save") })] }), u("div", { className: "uppy-DashboardContent-panelBody", children: props.editors.map((target) => {
    return props.uppy.getPlugin(target.id).render(props.state);
  }) })] });
}
var EditorPanel_default = EditorPanel;

// node_modules/@uppy/dashboard/lib/components/FileCard/index.js
var import_classnames10 = __toESM(require_classnames(), 1);

// node_modules/@uppy/dashboard/lib/utils/getFileTypeIcon.js
function iconImage() {
  return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25", children: u("g", { fill: "#686DE0", fillRule: "evenodd", children: [u("path", { d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z", fillRule: "nonzero" }), u("path", { d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z", fillRule: "nonzero" }), u("circle", { cx: "7.5", cy: "9.5", r: "1.5" })] }) });
}
function iconAudio() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25", children: u("path", { d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z", fill: "#049BCF", fillRule: "nonzero" }) });
}
function iconVideo() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25", children: u("path", { d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z", fill: "#19AF67", fillRule: "nonzero" }) });
}
function iconPDF() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25", children: u("path", { d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z", fill: "#E2514A", fillRule: "nonzero" }) });
}
function iconArchive() {
  return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25", children: u("path", { d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z", fill: "#00C469", fillRule: "nonzero" }) });
}
function iconFile() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25", children: u("g", { fill: "#A7AFB7", fillRule: "nonzero", children: [u("path", { d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z" }), u("path", { d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z" })] }) });
}
function iconText() {
  return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25", children: u("path", { d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z", fill: "#5A5E69", fillRule: "nonzero" }) });
}
function getIconByMime(fileType) {
  const defaultChoice = {
    color: "#838999",
    icon: iconFile()
  };
  if (!fileType)
    return defaultChoice;
  const fileTypeGeneral = fileType.split("/")[0];
  const fileTypeSpecific = fileType.split("/")[1];
  if (fileTypeGeneral === "text") {
    return {
      color: "#5a5e69",
      icon: iconText()
    };
  }
  if (fileTypeGeneral === "image") {
    return {
      color: "#686de0",
      icon: iconImage()
    };
  }
  if (fileTypeGeneral === "audio") {
    return {
      color: "#068dbb",
      icon: iconAudio()
    };
  }
  if (fileTypeGeneral === "video") {
    return {
      color: "#19af67",
      icon: iconVideo()
    };
  }
  if (fileTypeGeneral === "application" && fileTypeSpecific === "pdf") {
    return {
      color: "#e25149",
      icon: iconPDF()
    };
  }
  const archiveTypes = [
    "zip",
    "x-7z-compressed",
    "x-zip-compressed",
    "x-rar-compressed",
    "x-tar",
    "x-gzip",
    "x-apple-diskimage"
  ];
  if (fileTypeGeneral === "application" && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: "#00C469",
      icon: iconArchive()
    };
  }
  return defaultChoice;
}

// node_modules/@uppy/dashboard/lib/utils/ignoreEvent.js
function ignoreEvent(ev) {
  const { tagName } = ev.target;
  if (tagName === "INPUT" || tagName === "TEXTAREA") {
    ev.stopPropagation();
    return;
  }
  ev.preventDefault();
  ev.stopPropagation();
}
var ignoreEvent_default = ignoreEvent;

// node_modules/@uppy/dashboard/lib/components/FilePreview.js
function FilePreview(props) {
  const { file } = props;
  if (file.preview) {
    return u("img", { draggable: false, className: "uppy-Dashboard-Item-previewImg", alt: file.name, src: file.preview });
  }
  const { color, icon } = getIconByMime(file.type);
  return u("div", { className: "uppy-Dashboard-Item-previewIconWrap", children: [u("span", { className: "uppy-Dashboard-Item-previewIcon", style: { color }, children: icon }), u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-Dashboard-Item-previewIconBg", width: "58", height: "76", viewBox: "0 0 58 76", children: u("rect", { fill: "#FFF", width: "58", height: "76", rx: "3", fillRule: "evenodd" }) })] });
}

// node_modules/@uppy/dashboard/lib/components/FileCard/RenderMetaFields.js
function RenderMetaFields(props) {
  const { computedMetaFields, requiredMetaFields, updateMeta, form, formState } = props;
  const fieldCSSClasses = {
    text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input"
  };
  return computedMetaFields.map((field) => {
    const id = `uppy-Dashboard-FileCard-input-${field.id}`;
    const required = requiredMetaFields.includes(field.id);
    return u("fieldset", { className: "uppy-Dashboard-FileCard-fieldset", children: [u("label", { className: "uppy-Dashboard-FileCard-label", htmlFor: id, children: field.name }), field.render !== void 0 ? field.render({
      value: formState[field.id],
      onChange: (newVal) => updateMeta(newVal, field.id),
      fieldCSSClasses,
      required,
      form: form.id
    }, _) : u("input", { className: fieldCSSClasses.text, id, form: form.id, type: field.type || "text", required, value: formState[field.id], placeholder: field.placeholder, onInput: (ev) => updateMeta(ev.target.value, field.id), "data-uppy-super-focusable": true })] }, field.id);
  });
}

// node_modules/@uppy/dashboard/lib/components/FileCard/index.js
function FileCard(props) {
  const { files, fileCardFor, toggleFileCard, saveFileCard, metaFields, requiredMetaFields, openFileEditor, i18n, i18nArray, className, canEditFile } = props;
  const getMetaFields = () => {
    return typeof metaFields === "function" ? metaFields(files[fileCardFor]) : metaFields;
  };
  const file = files[fileCardFor];
  const computedMetaFields = getMetaFields() ?? [];
  const showEditButton = canEditFile(file);
  const storedMetaData = {};
  computedMetaFields.forEach((field) => {
    storedMetaData[field.id] = file.meta[field.id] ?? "";
  });
  const [formState, setFormState] = d(storedMetaData);
  const handleSave = q((ev) => {
    ev.preventDefault();
    saveFileCard(formState, fileCardFor);
  }, [saveFileCard, formState, fileCardFor]);
  const updateMeta = (newVal, name) => {
    setFormState({
      ...formState,
      [name]: newVal
    });
  };
  const handleCancel = () => {
    toggleFileCard(false);
  };
  const [form] = d(() => {
    const formEl = document.createElement("form");
    formEl.setAttribute("tabindex", "-1");
    formEl.id = nanoid2();
    return formEl;
  });
  y(() => {
    document.body.appendChild(form);
    form.addEventListener("submit", handleSave);
    return () => {
      form.removeEventListener("submit", handleSave);
      document.body.removeChild(form);
    };
  }, [form, handleSave]);
  return (
    // biome-ignore lint/a11y/noStaticElementInteractions: ...
    u("div", { className: (0, import_classnames10.default)("uppy-Dashboard-FileCard", className), "data-uppy-panelType": "FileCard", onDragOver: ignoreEvent_default, onDragLeave: ignoreEvent_default, onDrop: ignoreEvent_default, onPaste: ignoreEvent_default, children: [u("div", { className: "uppy-DashboardContent-bar", children: [u("div", {
      className: "uppy-DashboardContent-title",
      // biome-ignore lint/a11y/useSemanticElements: ...
      role: "heading",
      "aria-level": 1,
      children: i18nArray("editing", {
        file: u("span", { className: "uppy-DashboardContent-titleFile", children: file.meta ? file.meta.name : file.name })
      })
    }), u("button", { className: "uppy-DashboardContent-back", type: "button", form: form.id, title: i18n("finishEditingFile"), onClick: handleCancel, children: i18n("cancel") })] }), u("div", { className: "uppy-Dashboard-FileCard-inner", children: [u("div", { className: "uppy-Dashboard-FileCard-preview", style: { backgroundColor: getIconByMime(file.type).color }, children: [u(FilePreview, { file }), showEditButton && u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit", onClick: (event) => {
      handleSave(event);
      openFileEditor(file);
    }, children: i18n("editImage") })] }), u("div", { className: "uppy-Dashboard-FileCard-info", children: u(RenderMetaFields, { computedMetaFields, requiredMetaFields, updateMeta, form, formState }) }), u("div", { className: "uppy-Dashboard-FileCard-actions", children: [u("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      // If `form` attribute is supported, we want a submit button to trigger the form validation.
      // Otherwise, fallback to a classic button with a onClick event handler.
      type: "submit",
      form: form.id,
      children: i18n("saveChanges")
    }), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn", type: "button", onClick: handleCancel, form: form.id, children: i18n("cancel") })] })] })] })
  );
}

// node_modules/@uppy/dashboard/lib/components/FileItem/index.js
var import_classnames11 = __toESM(require_classnames(), 1);

// node_modules/shallow-equal/dist/index.modern.mjs
function shallowEqualObjects(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  const aKeys = Object.keys(objA);
  const bKeys = Object.keys(objB);
  const len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    const key = aKeys[i3];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/@uppy/dashboard/lib/utils/copyToClipboard.js
function copyToClipboard(textToCopy, fallbackString = "Copy the URL below") {
  return new Promise((resolve) => {
    const textArea = document.createElement("textarea");
    textArea.setAttribute("style", {
      position: "fixed",
      top: 0,
      left: 0,
      width: "2em",
      height: "2em",
      padding: 0,
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent"
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();
    const magicCopyFailed = () => {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };
    try {
      const successful = document.execCommand("copy");
      if (!successful) {
        return magicCopyFailed();
      }
      document.body.removeChild(textArea);
      return resolve();
    } catch (_err) {
      document.body.removeChild(textArea);
      return magicCopyFailed();
    }
  });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/Buttons/index.js
function EditButton({ file, uploadInProgressOrComplete, metaFields, canEditFile, i18n, onClick }) {
  if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit", type: "button", "aria-label": i18n("editFileWithFilename", { file: file.meta.name }), title: i18n("editFileWithFilename", { file: file.meta.name }), onClick: () => onClick(), children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 14", children: u("g", { fillRule: "evenodd", children: [u("path", { d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z", fillRule: "nonzero" }), u("rect", { x: "1", y: "12.293", width: "11", height: "1", rx: ".5" }), u("path", { fillRule: "nonzero", d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z" })] }) }) });
  }
  return null;
}
function RemoveButton({ i18n, onClick, file }) {
  return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove", type: "button", "aria-label": i18n("removeFile", { file: file.meta.name }), title: i18n("removeFile", { file: file.meta.name }), onClick: () => onClick(), children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "18", height: "18", viewBox: "0 0 18 18", children: [u("path", { d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z" }), u("path", { fill: "#FFF", d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z" })] }) });
}
function CopyLinkButton({ file, uppy, i18n }) {
  const copyLinkToClipboard = (event) => {
    copyToClipboard(file.uploadURL, i18n("copyLinkToClipboardFallback")).then(() => {
      uppy.log("Link copied to clipboard.");
      uppy.info(i18n("copyLinkToClipboardSuccess"), "info", 3e3);
    }).catch(uppy.log).then(() => event.target.focus({ preventScroll: true }));
  };
  return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink", type: "button", "aria-label": i18n("copyLink"), title: i18n("copyLink"), onClick: (event) => copyLinkToClipboard(event), children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 12", children: u("path", { d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z" }) }) });
}
function Buttons(props) {
  const { uppy, file, uploadInProgressOrComplete, canEditFile, metaFields, showLinkToFileUploadResult, showRemoveButton, i18n, toggleFileCard, openFileEditor } = props;
  const editAction = () => {
    if (metaFields && metaFields.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };
  return u("div", { className: "uppy-Dashboard-Item-actionWrapper", children: [u(EditButton, { i18n, file, uploadInProgressOrComplete, canEditFile, metaFields, onClick: editAction }), showLinkToFileUploadResult && file.uploadURL ? u(CopyLinkButton, { file, uppy, i18n }) : null, showRemoveButton ? u(RemoveButton, { i18n, file, onClick: () => uppy.removeFile(file.id) }) : null] });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/FileInfo/index.js
var import_prettier_bytes2 = __toESM(require_prettierBytes(), 1);

// node_modules/@uppy/utils/lib/truncateString.js
var separator = "...";
function truncateString(string, maxLength) {
  if (maxLength === 0)
    return "";
  if (string.length <= maxLength)
    return string;
  if (maxLength <= separator.length + 1)
    return `${string.slice(0, maxLength - 1)}…`;
  const charsToShow = maxLength - separator.length;
  const frontChars = Math.ceil(charsToShow / 2);
  const backChars = Math.floor(charsToShow / 2);
  return string.slice(0, frontChars) + separator + string.slice(-backChars);
}

// node_modules/@uppy/dashboard/lib/components/FileItem/MetaErrorMessage.js
var metaFieldIdToName = (metaFieldId, metaFields) => {
  const fields = typeof metaFields === "function" ? metaFields() : metaFields;
  const field = fields.filter((f3) => f3.id === metaFieldId);
  return field[0].name;
};
function MetaErrorMessage(props) {
  const { file, toggleFileCard, i18n, metaFields } = props;
  const { missingRequiredMetaFields } = file;
  if (!(missingRequiredMetaFields == null ? void 0 : missingRequiredMetaFields.length)) {
    return null;
  }
  const metaFieldsString = missingRequiredMetaFields.map((missingMetaField) => metaFieldIdToName(missingMetaField, metaFields)).join(", ");
  return u("div", { className: "uppy-Dashboard-Item-errorMessage", children: [i18n("missingRequiredMetaFields", {
    smart_count: missingRequiredMetaFields.length,
    fields: metaFieldsString
  }), " ", u("button", { type: "button", class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn", onClick: () => toggleFileCard(true, file.id), children: i18n("editFile") })] });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/FileInfo/index.js
var renderFileName = (props) => {
  const { author, name } = props.file.meta;
  function getMaxNameLength() {
    if (props.isSingleFile && props.containerHeight >= 350) {
      return 90;
    }
    if (props.containerWidth <= 352) {
      return 35;
    }
    if (props.containerWidth <= 576) {
      return 60;
    }
    return author ? 20 : 30;
  }
  return u("div", { className: "uppy-Dashboard-Item-name", title: name, children: truncateString(name, getMaxNameLength()) });
};
var renderAuthor = (props) => {
  var _a;
  const { author } = props.file.meta;
  const providerName = (_a = props.file.remote) == null ? void 0 : _a.providerName;
  const dot = `·`;
  if (!author) {
    return null;
  }
  return u("div", { className: "uppy-Dashboard-Item-author", children: [u("a", { href: `${author.url}?utm_source=Companion&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer", children: truncateString(author.name, 13) }), providerName ? u(k, { children: [` ${dot} `, providerName, ` ${dot} `] }) : null] });
};
var renderFileSize = (props) => props.file.size && u("div", { className: "uppy-Dashboard-Item-statusSize", children: (0, import_prettier_bytes2.default)(props.file.size) });
var ReSelectButton = (props) => props.file.isGhost && u("span", { children: [" • ", u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect", type: "button", onClick: () => props.toggleAddFilesPanel(true), children: props.i18n("reSelect") })] });
var ErrorButton = ({ file, onClick }) => {
  if (file.error) {
    return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-errorDetails", "aria-label": file.error, "data-microtip-position": "bottom", "data-microtip-size": "medium", onClick, type: "button", children: "?" });
  }
  return null;
};
function FileInfo(props) {
  const { file, i18n, toggleFileCard, metaFields, toggleAddFilesPanel, isSingleFile, containerHeight, containerWidth } = props;
  return u("div", { className: "uppy-Dashboard-Item-fileInfo", "data-uppy-file-source": file.source, children: [u("div", { className: "uppy-Dashboard-Item-fileName", children: [renderFileName({
    file,
    isSingleFile,
    containerHeight,
    containerWidth
  }), u(ErrorButton, { file, onClick: () => alert(file.error) })] }), u("div", { className: "uppy-Dashboard-Item-status", children: [renderAuthor({ file }), renderFileSize({ file }), ReSelectButton({ file, toggleAddFilesPanel, i18n })] }), u(MetaErrorMessage, { file, i18n, toggleFileCard, metaFields })] });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/FilePreviewAndLink/index.js
function FilePreviewAndLink(props) {
  const { file, i18n, toggleFileCard, metaFields, showLinkToFileUploadResult } = props;
  const white = "rgba(255, 255, 255, 0.5)";
  const previewBackgroundColor = file.preview ? white : getIconByMime(file.type).color;
  return u("div", { className: "uppy-Dashboard-Item-previewInnerWrap", style: { backgroundColor: previewBackgroundColor }, children: [showLinkToFileUploadResult && file.uploadURL && u("a", { className: "uppy-Dashboard-Item-previewLink", href: file.uploadURL, rel: "noreferrer noopener", target: "_blank", "aria-label": file.meta.name, children: u("span", { hidden: true, children: file.meta.name }) }), u(FilePreview, { file }), u(MetaErrorMessage, { file, i18n, toggleFileCard, metaFields })] });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/FileProgress/index.js
function onPauseResumeCancelRetry(props) {
  if (props.isUploaded)
    return;
  if (props.error && !props.hideRetryButton) {
    props.uppy.retryUpload(props.file.id);
    return;
  }
  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.uppy.pauseResume(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.uppy.removeFile(props.file.id);
  }
}
function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n("uploadComplete");
  }
  if (props.error) {
    return props.i18n("retryUpload");
  }
  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n("resumeUpload");
    }
    return props.i18n("pauseUpload");
  }
  if (props.individualCancellation) {
    return props.i18n("cancelUpload");
  }
  return "";
}
function ProgressIndicatorButton(props) {
  return u("div", { className: "uppy-Dashboard-Item-progress", children: u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-progressIndicator", type: "button", "aria-label": progressIndicatorTitle(props), title: progressIndicatorTitle(props), onClick: () => onPauseResumeCancelRetry(props), children: props.children }) });
}
function ProgressCircleContainer({ children }) {
  return u("svg", { "aria-hidden": "true", focusable: "false", width: "70", height: "70", viewBox: "0 0 36 36", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle", children });
}
function ProgressCircle({ progress }) {
  const circleLength = 2 * Math.PI * 15;
  return u("g", { children: [u("circle", { className: "uppy-Dashboard-Item-progressIcon--bg", r: "15", cx: "18", cy: "18", "stroke-width": "2", fill: "none" }), u("circle", { className: "uppy-Dashboard-Item-progressIcon--progress", r: "15", cx: "18", cy: "18", transform: "rotate(-90, 18, 18)", fill: "none", "stroke-width": "2", "stroke-dasharray": circleLength, "stroke-dashoffset": circleLength - circleLength / 100 * progress })] });
}
function FileProgress(props) {
  if (!props.file.progress.uploadStarted) {
    return null;
  }
  if (props.file.progress.percentage === void 0) {
    return null;
  }
  if (props.isUploaded) {
    return u("div", { className: "uppy-Dashboard-Item-progress", children: u("div", { className: "uppy-Dashboard-Item-progressIndicator", children: u(ProgressCircleContainer, { children: [u("circle", { r: "15", cx: "18", cy: "18", fill: "#1bb240" }), u("polygon", { className: "uppy-Dashboard-Item-progressIcon--check", transform: "translate(2, 3)", points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634" })] }) }) });
  }
  if (props.recoveredState) {
    return null;
  }
  if (props.error && !props.hideRetryButton) {
    return u(ProgressIndicatorButton, { ...props, children: u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry", width: "28", height: "31", viewBox: "0 0 16 19", children: [u("path", { d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z" }), u("path", { d: "M7.9 3H10v2H7.9z" }), u("path", { d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z" }), u("path", { d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z" })] }) });
  }
  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return u(ProgressIndicatorButton, { ...props, children: u(ProgressCircleContainer, { children: [u(ProgressCircle, { progress: props.file.progress.percentage }), props.file.isPaused ? u("polygon", { className: "uppy-Dashboard-Item-progressIcon--play", transform: "translate(3, 3)", points: "12 20 12 10 20 15" }) : u("g", { className: "uppy-Dashboard-Item-progressIcon--pause", transform: "translate(14.5, 13)", children: [u("rect", { x: "0", y: "0", width: "2", height: "10", rx: "0" }), u("rect", { x: "5", y: "0", width: "2", height: "10", rx: "0" })] })] }) });
  }
  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return u(ProgressIndicatorButton, { ...props, children: u(ProgressCircleContainer, { children: [u(ProgressCircle, { progress: props.file.progress.percentage }), u("polygon", { className: "cancel", transform: "translate(2, 2)", points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12" })] }) });
  }
  return u("div", { className: "uppy-Dashboard-Item-progress", children: u("div", { className: "uppy-Dashboard-Item-progressIndicator", children: u(ProgressCircleContainer, { children: u(ProgressCircle, { progress: props.file.progress.percentage }) }) }) });
}

// node_modules/@uppy/dashboard/lib/components/FileItem/index.js
var FileItem = class extends x {
  componentDidMount() {
    const { file } = this.props;
    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }
  shouldComponentUpdate(nextProps) {
    return !shallowEqualObjects(this.props, nextProps);
  }
  // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files
  componentDidUpdate() {
    const { file } = this.props;
    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }
  componentWillUnmount() {
    const { file } = this.props;
    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  }
  render() {
    const { file } = this.props;
    const isProcessing = file.progress.preprocess || file.progress.postprocess;
    const isUploaded = !!file.progress.uploadComplete && !isProcessing && !file.error;
    const uploadInProgressOrComplete = !!file.progress.uploadStarted || !!isProcessing;
    const uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    const error = file.error || false;
    const { isGhost } = file;
    let showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;
    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }
    const dashboardItemClass = (0, import_classnames11.default)({
      "uppy-Dashboard-Item": true,
      "is-inprogress": uploadInProgress && !this.props.recoveredState,
      "is-processing": isProcessing,
      "is-complete": isUploaded,
      "is-error": !!error,
      "is-resumable": this.props.resumableUploads,
      "is-noIndividualCancellation": !this.props.individualCancellation,
      "is-ghost": isGhost
    });
    return u("div", { className: dashboardItemClass, id: `uppy_${file.id}`, role: this.props.role, children: [u("div", { className: "uppy-Dashboard-Item-preview", children: [u(FilePreviewAndLink, { file, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, i18n: this.props.i18n, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields }), u(FileProgress, { uppy: this.props.uppy, file, error, isUploaded, hideRetryButton: this.props.hideRetryButton, hideCancelButton: this.props.hideCancelButton, hidePauseResumeButton: this.props.hidePauseResumeButton, recoveredState: this.props.recoveredState, resumableUploads: this.props.resumableUploads, individualCancellation: this.props.individualCancellation, i18n: this.props.i18n })] }), u("div", { className: "uppy-Dashboard-Item-fileInfoAndButtons", children: [u(FileInfo, { file, containerWidth: this.props.containerWidth, containerHeight: this.props.containerHeight, i18n: this.props.i18n, toggleAddFilesPanel: this.props.toggleAddFilesPanel, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields, isSingleFile: this.props.isSingleFile }), u(Buttons, { file, metaFields: this.props.metaFields, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, showRemoveButton, canEditFile: this.props.canEditFile, uploadInProgressOrComplete, toggleFileCard: this.props.toggleFileCard, openFileEditor: this.props.openFileEditor, uppy: this.props.uppy, i18n: this.props.i18n })] })] });
  }
};

// node_modules/@uppy/dashboard/lib/components/FileList.js
function chunks(list, size) {
  const chunked = [];
  let currentChunk = [];
  list.forEach((item) => {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length)
    chunked.push(currentChunk);
  return chunked;
}
function FileList({ id, i18n, uppy, files, resumableUploads, hideRetryButton, hidePauseResumeButton, hideCancelButton, showLinkToFileUploadResult, showRemoveButtonAfterComplete, metaFields, isSingleFile, toggleFileCard, handleRequestThumbnail, handleCancelThumbnail, recoveredState, individualCancellation, itemsPerRow, openFileEditor, canEditFile, toggleAddFilesPanel, containerWidth, containerHeight }) {
  const rowHeight = itemsPerRow === 1 ? (
    // Mobile
    71
  ) : (
    // 190px height + 2 * 5px margin
    200
  );
  const rows = T(() => {
    const sortByGhostComesFirst = (file1, file2) => Number(files[file2].isGhost) - Number(files[file1].isGhost);
    const fileIds = Object.keys(files);
    if (recoveredState)
      fileIds.sort(sortByGhostComesFirst);
    return chunks(fileIds, itemsPerRow);
  }, [files, itemsPerRow, recoveredState]);
  const renderRow = (row) => u("div", {
    class: "uppy-Dashboard-filesInner",
    // The `role="presentation` attribute ensures that the list items are properly
    // associated with the `VirtualList` element.
    role: "presentation",
    children: row.map((fileID) => u(FileItem, {
      uppy,
      // FIXME This is confusing, it's actually the Dashboard's plugin ID
      id,
      // TODO move this to context
      i18n,
      // features
      resumableUploads,
      individualCancellation,
      // visual options
      hideRetryButton,
      hidePauseResumeButton,
      hideCancelButton,
      showLinkToFileUploadResult,
      showRemoveButtonAfterComplete,
      metaFields,
      recoveredState,
      isSingleFile,
      containerWidth,
      containerHeight,
      // callbacks
      toggleFileCard,
      handleRequestThumbnail,
      handleCancelThumbnail,
      role: "listitem",
      openFileEditor,
      canEditFile,
      toggleAddFilesPanel,
      file: files[fileID]
    }, fileID))
  }, row[0]);
  if (isSingleFile) {
    return u("div", { class: "uppy-Dashboard-files", children: renderRow(rows[0]) });
  }
  return u(VirtualList_default, { class: "uppy-Dashboard-files", role: "list", data: rows, renderRow, rowHeight });
}

// node_modules/@uppy/dashboard/lib/components/PickerPanelContent.js
var import_classnames12 = __toESM(require_classnames(), 1);
function PickerPanelContent({ activePickerPanel, className, hideAllPanels, i18n, state, uppy }) {
  const ref = A(null);
  return u("div", { className: (0, import_classnames12.default)("uppy-DashboardContent-panel", className), role: "tabpanel", "data-uppy-panelType": "PickerPanel", id: `uppy-DashboardContent-panel--${activePickerPanel.id}`, onDragOver: ignoreEvent_default, onDragLeave: ignoreEvent_default, onDrop: ignoreEvent_default, onPaste: ignoreEvent_default, children: [u("div", { className: "uppy-DashboardContent-bar", children: [u("div", {
    className: "uppy-DashboardContent-title",
    // biome-ignore lint/a11y/useSemanticElements: ...
    role: "heading",
    "aria-level": 1,
    children: i18n("importFrom", { name: activePickerPanel.name })
  }), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: hideAllPanels, children: i18n("cancel") })] }), u("div", { ref, className: "uppy-DashboardContent-panelBody", children: uppy.getPlugin(activePickerPanel.id).render(state, ref.current) })] });
}
var PickerPanelContent_default = PickerPanelContent;

// node_modules/@uppy/dashboard/lib/components/PickerPanelTopBar.js
var uploadStates = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete",
  STATE_PAUSED: "paused"
};
function getUploadingState2(isAllErrored, isAllComplete, isAllPaused, files = {}) {
  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }
  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }
  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }
  let state = uploadStates.STATE_WAITING;
  const fileIDs = Object.keys(files);
  for (let i3 = 0; i3 < fileIDs.length; i3++) {
    const { progress } = files[fileIDs[i3]];
    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    }
    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    }
    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }
  return state;
}
function UploadStatus({ files, i18n, isAllComplete, isAllErrored, isAllPaused, inProgressNotPausedFiles, newFiles, processingFiles }) {
  const uploadingState = getUploadingState2(isAllErrored, isAllComplete, isAllPaused, files);
  switch (uploadingState) {
    case "uploading":
      return i18n("uploadingXFiles", {
        smart_count: inProgressNotPausedFiles.length
      });
    case "preprocessing":
    case "postprocessing":
      return i18n("processingXFiles", { smart_count: processingFiles.length });
    case "paused":
      return i18n("uploadPaused");
    case "waiting":
      return i18n("xFilesSelected", { smart_count: newFiles.length });
    case "complete":
      return i18n("uploadComplete");
    case "error":
      return i18n("error");
    default:
  }
}
function PanelTopBar(props) {
  const { i18n, isAllComplete, hideCancelButton, maxNumberOfFiles, toggleAddFilesPanel, uppy } = props;
  let { allowNewUpload } = props;
  if (allowNewUpload && maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }
  return u("div", { className: "uppy-DashboardContent-bar", children: [!isAllComplete && !hideCancelButton ? u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => uppy.cancelAll(), children: i18n("cancel") }) : u("div", {}), u("div", { className: "uppy-DashboardContent-title", children: u(UploadStatus, { ...props }) }), allowNewUpload ? u("button", { className: "uppy-DashboardContent-addMore", type: "button", "aria-label": i18n("addMoreFiles"), title: i18n("addMoreFiles"), onClick: () => toggleAddFilesPanel(true), children: [u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "15", height: "15", viewBox: "0 0 15 15", children: u("path", { d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z" }) }), u("span", { className: "uppy-DashboardContent-addMoreCaption", children: i18n("addMore") })] }) : u("div", {})] });
}
var PickerPanelTopBar_default = PanelTopBar;

// node_modules/@uppy/dashboard/lib/components/Slide.js
var import_classnames13 = __toESM(require_classnames(), 1);
var transitionName = "uppy-transition-slideDownUp";
var duration = 250;
function Slide({ children }) {
  const [cachedChildren, setCachedChildren] = d(null);
  const [className, setClassName] = d("");
  const enterTimeoutRef = A();
  const leaveTimeoutRef = A();
  const animationFrameRef = A();
  const handleEnterTransition = () => {
    setClassName(`${transitionName}-enter`);
    cancelAnimationFrame(animationFrameRef.current);
    clearTimeout(leaveTimeoutRef.current);
    leaveTimeoutRef.current = void 0;
    animationFrameRef.current = requestAnimationFrame(() => {
      setClassName(`${transitionName}-enter ${transitionName}-enter-active`);
      enterTimeoutRef.current = setTimeout(() => {
        setClassName("");
      }, duration);
    });
  };
  const handleLeaveTransition = () => {
    setClassName(`${transitionName}-leave`);
    cancelAnimationFrame(animationFrameRef.current);
    clearTimeout(enterTimeoutRef.current);
    enterTimeoutRef.current = void 0;
    animationFrameRef.current = requestAnimationFrame(() => {
      setClassName(`${transitionName}-leave ${transitionName}-leave-active`);
      leaveTimeoutRef.current = setTimeout(() => {
        setCachedChildren(null);
        setClassName("");
      }, duration);
    });
  };
  y(() => {
    const child = H(children)[0];
    if (cachedChildren === child)
      return;
    if (child && !cachedChildren) {
      handleEnterTransition();
    } else if (cachedChildren && !child && !leaveTimeoutRef.current) {
      handleLeaveTransition();
    }
    setCachedChildren(child);
  }, [children, cachedChildren]);
  y(() => {
    return () => {
      clearTimeout(enterTimeoutRef.current);
      clearTimeout(leaveTimeoutRef.current);
      cancelAnimationFrame(animationFrameRef.current);
    };
  }, []);
  if (!cachedChildren)
    return null;
  return K(cachedChildren, {
    className: (0, import_classnames13.default)(className, cachedChildren.props.className)
  });
}
var Slide_default = Slide;

// node_modules/@uppy/dashboard/lib/components/Dashboard.js
var WIDTH_XL = 900;
var WIDTH_LG = 700;
var WIDTH_MD = 576;
var HEIGHT_MD = 330;
function Dashboard(props) {
  const isNoFiles = props.totalFileCount === 0;
  const isSingleFile = props.totalFileCount === 1;
  const isSizeMD = props.containerWidth > WIDTH_MD;
  const isSizeHeightMD = props.containerHeight > HEIGHT_MD;
  const dashboardClassName = (0, import_classnames14.default)({
    "uppy-Dashboard": true,
    "uppy-Dashboard--isDisabled": props.disabled,
    "uppy-Dashboard--animateOpenClose": props.animateOpenClose,
    "uppy-Dashboard--isClosing": props.isClosing,
    "uppy-Dashboard--isDraggingOver": props.isDraggingOver,
    "uppy-Dashboard--modal": !props.inline,
    "uppy-size--md": props.containerWidth > WIDTH_MD,
    "uppy-size--lg": props.containerWidth > WIDTH_LG,
    "uppy-size--xl": props.containerWidth > WIDTH_XL,
    "uppy-size--height-md": props.containerHeight > HEIGHT_MD,
    // We might want to enable this in the future
    // 'uppy-size--height-lg': props.containerHeight > HEIGHT_LG,
    // 'uppy-size--height-xl': props.containerHeight > HEIGHT_XL,
    "uppy-Dashboard--isAddFilesPanelVisible": props.showAddFilesPanel,
    "uppy-Dashboard--isInnerWrapVisible": props.areInsidesReadyToBeVisible,
    // Only enable “centered single file” mode when Dashboard is tall enough
    "uppy-Dashboard--singleFile": props.singleFileFullScreen && isSingleFile && isSizeHeightMD
  });
  let itemsPerRow = 1;
  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }
  const showFileList = props.showSelectedFiles && !isNoFiles;
  const numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  const numberOfGhosts = props.files ? Object.keys(props.files).filter((fileID) => props.files[fileID].isGhost).length : 0;
  const renderRestoredText = () => {
    if (numberOfGhosts > 0) {
      return props.i18n("recoveredXFiles", {
        smart_count: numberOfGhosts
      });
    }
    return props.i18n("recoveredAllFiles");
  };
  const dashboard = (
    // biome-ignore lint/a11y/useAriaPropsSupportedByRole: ...
    u("div", { className: dashboardClassName, "data-uppy-theme": props.theme, "data-uppy-num-acquirers": props.acquirers.length, "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(), "aria-hidden": props.inline ? "false" : props.isHidden, "aria-disabled": props.disabled, "aria-label": !props.inline ? props.i18n("dashboardWindowTitle") : props.i18n("dashboardTitle"), onPaste: props.handlePaste, onDragOver: props.handleDragOver, onDragLeave: props.handleDragLeave, onDrop: props.handleDrop, children: [u("div", { "aria-hidden": "true", className: "uppy-Dashboard-overlay", tabIndex: -1, onClick: props.handleClickOutside }), u("div", { className: "uppy-Dashboard-inner", role: props.inline ? void 0 : "dialog", style: {
      width: props.inline && props.width ? props.width : "",
      height: props.inline && props.height ? props.height : ""
    }, children: [!props.inline ? u("button", { className: "uppy-u-reset uppy-Dashboard-close", type: "button", "aria-label": props.i18n("closeModal"), title: props.i18n("closeModal"), onClick: props.closeModal, children: u("span", { "aria-hidden": "true", children: "×" }) }) : null, u("div", { className: "uppy-Dashboard-innerWrap", children: [u("div", { className: "uppy-Dashboard-dropFilesHereHint", children: props.i18n("dropHint") }), showFileList && u(PickerPanelTopBar_default, { ...props }), numberOfFilesForRecovery && u("div", { className: "uppy-Dashboard-serviceMsg", children: [u("svg", { className: "uppy-Dashboard-serviceMsg-icon", "aria-hidden": "true", focusable: "false", width: "21", height: "16", viewBox: "0 0 24 19", children: u("g", { transform: "translate(0 -1)", fill: "none", fillRule: "evenodd", children: [u("path", { d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z", fill: "#FFD300" }), u("path", { fill: "#000", d: "M11 6h2l-.3 8h-1.4z" }), u("circle", { fill: "#000", cx: "12", cy: "17", r: "1" })] }) }), u("strong", { className: "uppy-Dashboard-serviceMsg-title", children: props.i18n("sessionRestored") }), u("div", { className: "uppy-Dashboard-serviceMsg-text", children: renderRestoredText() })] }), showFileList ? u(FileList, { id: props.id, i18n: props.i18n, uppy: props.uppy, files: props.files, resumableUploads: props.resumableUploads, hideRetryButton: props.hideRetryButton, hidePauseResumeButton: props.hidePauseResumeButton, hideCancelButton: props.hideCancelButton, showLinkToFileUploadResult: props.showLinkToFileUploadResult, showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete, metaFields: props.metaFields, toggleFileCard: props.toggleFileCard, handleRequestThumbnail: props.handleRequestThumbnail, handleCancelThumbnail: props.handleCancelThumbnail, recoveredState: props.recoveredState, individualCancellation: props.individualCancellation, openFileEditor: props.openFileEditor, canEditFile: props.canEditFile, toggleAddFilesPanel: props.toggleAddFilesPanel, isSingleFile, itemsPerRow, containerWidth: props.containerWidth, containerHeight: props.containerHeight }) : u(AddFiles_default, { i18n: props.i18n, i18nArray: props.i18nArray, acquirers: props.acquirers, handleInputChange: props.handleInputChange, maxNumberOfFiles: props.maxNumberOfFiles, allowedFileTypes: props.allowedFileTypes, showNativePhotoCameraButton: props.showNativePhotoCameraButton, showNativeVideoCameraButton: props.showNativeVideoCameraButton, nativeCameraFacingMode: props.nativeCameraFacingMode, showPanel: props.showPanel, activePickerPanel: props.activePickerPanel, disableLocalFiles: props.disableLocalFiles, fileManagerSelectionType: props.fileManagerSelectionType, note: props.note, proudlyDisplayPoweredByUppy: props.proudlyDisplayPoweredByUppy }), u(Slide_default, { children: props.showAddFilesPanel ? u(AddFilesPanel_default, { ...props, isSizeMD }, "AddFiles") : null }), u(Slide_default, { children: props.fileCardFor ? u(FileCard, { ...props }, "FileCard") : null }), u(Slide_default, { children: props.activePickerPanel ? u(PickerPanelContent_default, { ...props }, "Picker") : null }), u(Slide_default, { children: props.showFileEditor ? u(EditorPanel_default, { ...props }, "Editor") : null }), u("div", { className: "uppy-Dashboard-progressindicators", children: props.progressindicators.map((target) => {
      return props.uppy.getPlugin(target.id).render(props.state);
    }) })] })] })] })
  );
  return dashboard;
}

// node_modules/@uppy/dashboard/lib/locale.js
var locale_default3 = {
  strings: {
    // When `inline: false`, used as the screen reader label for the button that closes the modal.
    closeModal: "Close Modal",
    // Used as the screen reader label for the plus (+) button that shows the “Add more files” screen
    addMoreFiles: "Add more files",
    addingMoreFiles: "Adding more files",
    // Used as the header for import panels, e.g., “Import from Google Drive”.
    importFrom: "Import from %{name}",
    // When `inline: false`, used as the screen reader label for the dashboard modal.
    dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)",
    // When `inline: true`, used as the screen reader label for the dashboard area.
    dashboardTitle: "Uppy Dashboard",
    // Shown in the Informer when a link to a file was copied to the clipboard.
    copyLinkToClipboardSuccess: "Link copied to clipboard.",
    // Used when a link cannot be copied automatically — the user has to select the text from the
    // input element below this string.
    copyLinkToClipboardFallback: "Copy the URL below",
    // Used as the hover title and screen reader label for buttons that copy a file link.
    copyLink: "Copy link",
    back: "Back",
    // Used as the screen reader label for buttons that remove a file.
    removeFile: "Remove file",
    // Used as the screen reader label for buttons that open the metadata editor panel for a file.
    editFile: "Edit file",
    editImage: "Edit image",
    // Shown in the panel header for the metadata editor. Rendered as “Editing image.png”.
    editing: "Editing %{file}",
    // Shown on the main upload screen when an upload error occurs
    error: "Error",
    // Used as the screen reader label for the button that saves metadata edits and returns to the
    // file list view.
    finishEditingFile: "Finish editing file",
    saveChanges: "Save changes",
    // Used as the label for the tab button that opens the system file selection dialog.
    myDevice: "My Device",
    dropHint: "Drop your files here",
    // Used as the hover text and screen reader label for file progress indicators when
    // they have been fully uploaded.
    uploadComplete: "Upload complete",
    uploadPaused: "Upload paused",
    // Used as the hover text and screen reader label for the buttons to resume paused uploads.
    resumeUpload: "Resume upload",
    // Used as the hover text and screen reader label for the buttons to pause uploads.
    pauseUpload: "Pause upload",
    // Used as the hover text and screen reader label for the buttons to retry failed uploads.
    retryUpload: "Retry upload",
    // Used as the hover text and screen reader label for the buttons to cancel uploads.
    cancelUpload: "Cancel upload",
    // Used in a title, how many files are currently selected
    xFilesSelected: {
      0: "%{smart_count} file selected",
      1: "%{smart_count} files selected"
    },
    uploadingXFiles: {
      0: "Uploading %{smart_count} file",
      1: "Uploading %{smart_count} files"
    },
    processingXFiles: {
      0: "Processing %{smart_count} file",
      1: "Processing %{smart_count} files"
    },
    // The "powered by Uppy" link at the bottom of the Dashboard.
    poweredBy: "Powered by %{uppy}",
    addMore: "Add more",
    editFileWithFilename: "Edit file %{file}",
    save: "Save",
    cancel: "Cancel",
    dropPasteFiles: "Drop files here or %{browseFiles}",
    dropPasteFolders: "Drop files here or %{browseFolders}",
    dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}",
    dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:",
    dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:",
    dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:",
    importFiles: "Import files from:",
    browseFiles: "browse files",
    browseFolders: "browse folders",
    recoveredXFiles: {
      0: "We could not fully recover 1 file. Please re-select it and resume the upload.",
      1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload."
    },
    recoveredAllFiles: "We restored all files. You can now resume the upload.",
    sessionRestored: "Session restored",
    reSelect: "Re-select",
    missingRequiredMetaFields: {
      0: "Missing required meta field: %{fields}.",
      1: "Missing required meta fields: %{fields}."
    },
    // Used for native device camera buttons on mobile
    takePictureBtn: "Take Picture",
    recordVideoBtn: "Record Video"
  }
};

// node_modules/@uppy/utils/lib/FOCUSABLE_ELEMENTS.js
var FOCUSABLE_ELEMENTS_default = [
  'a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  "input:not([disabled]):not([inert]):not([aria-hidden])",
  "select:not([disabled]):not([inert]):not([aria-hidden])",
  "textarea:not([disabled]):not([inert]):not([aria-hidden])",
  "button:not([disabled]):not([inert]):not([aria-hidden])",
  'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])',
  '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'
];

// node_modules/@uppy/dashboard/lib/utils/createSuperFocus.js
var import_debounce = __toESM(require_debounce(), 1);

// node_modules/@uppy/dashboard/lib/utils/getActiveOverlayEl.js
function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    const overlayEl = dashboardEl.querySelector(`[data-uppy-paneltype="${activeOverlayType}"]`);
    if (overlayEl)
      return overlayEl;
  }
  return dashboardEl;
}

// node_modules/@uppy/dashboard/lib/utils/createSuperFocus.js
function createSuperFocus() {
  let lastFocusWasOnSuperFocusableEl = false;
  const superFocus = (dashboardEl, activeOverlayType) => {
    const overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    const isFocusInOverlay2 = overlayEl.contains(document.activeElement);
    if (isFocusInOverlay2 && lastFocusWasOnSuperFocusableEl)
      return;
    const superFocusableEl = overlayEl.querySelector("[data-uppy-super-focusable]");
    if (isFocusInOverlay2 && !superFocusableEl)
      return;
    if (superFocusableEl) {
      superFocusableEl.focus({ preventScroll: true });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      const firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS_default);
      firstEl == null ? void 0 : firstEl.focus({ preventScroll: true });
      lastFocusWasOnSuperFocusableEl = false;
    }
  };
  return (0, import_debounce.default)(superFocus, 260);
}

// node_modules/@uppy/dashboard/lib/utils/trapFocus.js
function focusOnFirstNode(event, nodes) {
  const node = nodes[0];
  if (node) {
    node.focus();
    event.preventDefault();
  }
}
function focusOnLastNode(event, nodes) {
  const node = nodes[nodes.length - 1];
  if (node) {
    node.focus();
    event.preventDefault();
  }
}
function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}
function trapFocus(event, activeOverlayType, dashboardEl) {
  const activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  const focusableNodes = toArray_default(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS_default));
  const focusedItemIndex = focusableNodes.indexOf(document.activeElement);
  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes);
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes);
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}
function forInline(event, activeOverlayType, dashboardEl) {
  if (activeOverlayType === null) {
  } else {
    trapFocus(event, activeOverlayType, dashboardEl);
  }
}

// node_modules/@uppy/dashboard/lib/Dashboard.js
var TAB_KEY = 9;
var ESC_KEY = 27;
function createPromise() {
  const o2 = {};
  o2.promise = new Promise((resolve, reject) => {
    o2.resolve = resolve;
    o2.reject = reject;
  });
  return o2;
}
var defaultOptions4 = {
  target: "body",
  metaFields: [],
  thumbnailWidth: 280,
  thumbnailType: "image/jpeg",
  waitForThumbnailsBeforeUpload: false,
  defaultPickerIcon,
  showLinkToFileUploadResult: false,
  showProgressDetails: false,
  hideUploadButton: false,
  hideCancelButton: false,
  hideRetryButton: false,
  hidePauseResumeButton: false,
  hideProgressAfterFinish: false,
  note: null,
  singleFileFullScreen: true,
  disableStatusBar: false,
  disableInformer: false,
  disableThumbnailGenerator: false,
  fileManagerSelectionType: "files",
  proudlyDisplayPoweredByUppy: true,
  showSelectedFiles: true,
  showRemoveButtonAfterComplete: false,
  showNativePhotoCameraButton: false,
  showNativeVideoCameraButton: false,
  theme: "light",
  autoOpen: null,
  disabled: false,
  disableLocalFiles: false,
  nativeCameraFacingMode: "",
  onDragLeave: () => {
  },
  onDragOver: () => {
  },
  onDrop: () => {
  },
  plugins: [],
  // Dynamic default options, they have to be defined in the constructor (because
  // they require access to the `this` keyword), but we still want them to
  // appear in the default options so TS knows they'll be defined.
  doneButtonHandler: void 0,
  onRequestCloseModal: null,
  // defaultModalOptions
  inline: false,
  animateOpenClose: true,
  browserBackButtonClose: false,
  closeAfterFinish: false,
  closeModalOnClickOutside: false,
  disablePageScrollWhenModalOpen: true,
  trigger: null,
  // defaultInlineOptions
  width: 750,
  height: 550
};
var _disabledNodes, _generateLargeThumbnailIfSingleFile, _openFileEditorWhenFilesAdded, _attachRenderFunctionToTarget, _isTargetSupported, _getAcquirers, _getProgressIndicators, _getEditors, _addSpecifiedPluginsFromOptions, _autoDiscoverPlugins, _addSupportedPluginIfNoTarget, _Dashboard_instances, getStatusBarOpts_fn, getThumbnailGeneratorOpts_fn, getInformerOpts_fn, getStatusBarId_fn, getThumbnailGeneratorId_fn, getInformerId_fn;
var Dashboard2 = class extends UIPlugin_default {
  constructor(uppy, opts) {
    var _a;
    const autoOpen = (opts == null ? void 0 : opts.autoOpen) ?? null;
    super(uppy, { ...defaultOptions4, ...opts, autoOpen });
    __privateAdd(this, _Dashboard_instances);
    __privateAdd(this, _disabledNodes);
    __publicField(this, "modalName", `uppy-Dashboard-${nanoid2()}`);
    __publicField(this, "superFocus", createSuperFocus());
    __publicField(this, "ifFocusedOnUppyRecently", false);
    __publicField(this, "dashboardIsDisabled");
    __publicField(this, "savedScrollPosition");
    __publicField(this, "savedActiveElement");
    __publicField(this, "resizeObserver");
    __publicField(this, "darkModeMediaQuery");
    // Timeouts
    __publicField(this, "makeDashboardInsidesVisibleAnywayTimeout");
    __publicField(this, "removeTarget", (plugin) => {
      const pluginState = this.getPluginState();
      const newTargets = pluginState.targets.filter((target) => target.id !== plugin.id);
      this.setPluginState({
        targets: newTargets
      });
    });
    __publicField(this, "addTarget", (plugin) => {
      const callerPluginId = plugin.id || plugin.constructor.name;
      const callerPluginName = plugin.title || callerPluginId;
      const callerPluginType = plugin.type;
      if (callerPluginType !== "acquirer" && callerPluginType !== "progressindicator" && callerPluginType !== "editor") {
        const msg = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor";
        this.uppy.log(msg, "error");
        return null;
      }
      const target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };
      const state = this.getPluginState();
      const newTargets = state.targets.slice();
      newTargets.push(target);
      this.setPluginState({
        targets: newTargets
      });
      return this.el;
    });
    __publicField(this, "hideAllPanels", () => {
      var _a;
      const state = this.getPluginState();
      const update = {
        activePickerPanel: void 0,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };
      if (state.activePickerPanel === update.activePickerPanel && state.showAddFilesPanel === update.showAddFilesPanel && state.showFileEditor === update.showFileEditor && state.activeOverlayType === update.activeOverlayType) {
        return;
      }
      this.setPluginState(update);
      this.uppy.emit("dashboard:close-panel", (_a = state.activePickerPanel) == null ? void 0 : _a.id);
    });
    __publicField(this, "showPanel", (id) => {
      const { targets } = this.getPluginState();
      const activePickerPanel = targets.find((target) => {
        return target.type === "acquirer" && target.id === id;
      });
      this.setPluginState({
        activePickerPanel,
        activeOverlayType: "PickerPanel"
      });
      this.uppy.emit("dashboard:show-panel", id);
    });
    __publicField(this, "canEditFile", (file) => {
      const { targets } = this.getPluginState();
      const editors = __privateGet(this, _getEditors).call(this, targets);
      return editors.some((target) => this.uppy.getPlugin(target.id).canEditFile(file));
    });
    __publicField(this, "openFileEditor", (file) => {
      const { targets } = this.getPluginState();
      const editors = __privateGet(this, _getEditors).call(this, targets);
      this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: "FileEditor"
      });
      editors.forEach((editor) => {
        ;
        this.uppy.getPlugin(editor.id).selectFile(file);
      });
    });
    __publicField(this, "closeFileEditor", () => {
      const { metaFields } = this.getPluginState();
      const isMetaEditorEnabled = metaFields && metaFields.length > 0;
      if (isMetaEditorEnabled) {
        this.setPluginState({
          showFileEditor: false,
          activeOverlayType: "FileCard"
        });
      } else {
        this.setPluginState({
          showFileEditor: false,
          fileCardFor: null,
          activeOverlayType: "AddFiles"
        });
      }
    });
    __publicField(this, "saveFileEditor", () => {
      const { targets } = this.getPluginState();
      const editors = __privateGet(this, _getEditors).call(this, targets);
      editors.forEach((editor) => {
        ;
        this.uppy.getPlugin(editor.id).save();
      });
      this.closeFileEditor();
    });
    __publicField(this, "openModal", () => {
      const { promise, resolve } = createPromise();
      this.savedScrollPosition = window.pageYOffset;
      this.savedActiveElement = document.activeElement;
      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add("uppy-Dashboard-isFixed");
      }
      if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
        const handler = () => {
          this.setPluginState({
            isHidden: false
          });
          this.el.removeEventListener("animationend", handler, false);
          resolve();
        };
        this.el.addEventListener("animationend", handler, false);
      } else {
        this.setPluginState({
          isHidden: false
        });
        resolve();
      }
      if (this.opts.browserBackButtonClose) {
        this.updateBrowserHistory();
      }
      document.addEventListener("keydown", this.handleKeyDownInModal);
      this.uppy.emit("dashboard:modal-open");
      return promise;
    });
    __publicField(this, "closeModal", (opts) => {
      var _a;
      const manualClose = (opts == null ? void 0 : opts.manualClose) ?? true;
      const { isHidden, isClosing } = this.getPluginState();
      if (isHidden || isClosing) {
        return void 0;
      }
      const { promise, resolve } = createPromise();
      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove("uppy-Dashboard-isFixed");
      }
      if (this.opts.animateOpenClose) {
        this.setPluginState({
          isClosing: true
        });
        const handler = () => {
          this.setPluginState({
            isHidden: true,
            isClosing: false
          });
          this.superFocus.cancel();
          this.savedActiveElement.focus();
          this.el.removeEventListener("animationend", handler, false);
          resolve();
        };
        this.el.addEventListener("animationend", handler, false);
      } else {
        this.setPluginState({
          isHidden: true
        });
        this.superFocus.cancel();
        this.savedActiveElement.focus();
        resolve();
      }
      document.removeEventListener("keydown", this.handleKeyDownInModal);
      if (manualClose) {
        if (this.opts.browserBackButtonClose) {
          if ((_a = history.state) == null ? void 0 : _a[this.modalName]) {
            history.back();
          }
        }
      }
      this.uppy.emit("dashboard:modal-closed");
      return promise;
    });
    __publicField(this, "isModalOpen", () => {
      return !this.getPluginState().isHidden || false;
    });
    __publicField(this, "requestCloseModal", () => {
      if (this.opts.onRequestCloseModal) {
        return this.opts.onRequestCloseModal();
      }
      return this.closeModal();
    });
    __publicField(this, "setDarkModeCapability", (isDarkModeOn) => {
      const { capabilities } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          darkMode: isDarkModeOn
        }
      });
    });
    __publicField(this, "handleSystemDarkModeChange", (event) => {
      const isDarkModeOnNow = event.matches;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnNow ? "on" : "off"}`);
      this.setDarkModeCapability(isDarkModeOnNow);
    });
    __publicField(this, "toggleFileCard", (show, fileID) => {
      const file = this.uppy.getFile(fileID);
      if (show) {
        this.uppy.emit("dashboard:file-edit-start", file);
      } else {
        this.uppy.emit("dashboard:file-edit-complete", file);
      }
      this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? "FileCard" : null
      });
    });
    __publicField(this, "toggleAddFilesPanel", (show) => {
      this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? "AddFiles" : null
      });
    });
    __publicField(this, "addFiles", (files) => {
      const descriptors = files.map((file) => ({
        source: this.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: file.relativePath || file.webkitRelativePath || null
        }
      }));
      try {
        this.uppy.addFiles(descriptors);
      } catch (err) {
        this.uppy.log(err);
      }
    });
    // ___Why make insides of Dashboard invisible until first ResizeObserver event is emitted?
    //    ResizeOberserver doesn't emit the first resize event fast enough, users can see the jump from one .uppy-size-- to
    //    another (e.g. in Safari)
    // ___Why not apply visibility property to .uppy-Dashboard-inner?
    //    Because ideally, acc to specs, ResizeObserver should see invisible elements as of width 0. So even though applying
    //    invisibility to .uppy-Dashboard-inner works now, it may not work in the future.
    __publicField(this, "startListeningToResize", () => {
      this.resizeObserver = new ResizeObserver((entries) => {
        const uppyDashboardInnerEl = entries[0];
        const { width, height } = uppyDashboardInnerEl.contentRect;
        this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });
      this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner"));
      this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => {
        const pluginState = this.getPluginState();
        const isModalAndClosed = !this.opts.inline && pluginState.isHidden;
        if (
          // We might want to enable this in the future
          // if ResizeObserver hasn't yet fired,
          !pluginState.areInsidesReadyToBeVisible && // and it's not due to the modal being closed
          !isModalAndClosed
        ) {
          this.uppy.log("[Dashboard] resize event didn’t fire on time: defaulted to mobile layout", "warning");
          this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1e3);
    });
    __publicField(this, "stopListeningToResize", () => {
      this.resizeObserver.disconnect();
      clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
    });
    // Records whether we have been interacting with uppy right now,
    // which is then used to determine whether state updates should trigger a refocusing.
    __publicField(this, "recordIfFocusedOnUppyRecently", (event) => {
      if (this.el.contains(event.target)) {
        this.ifFocusedOnUppyRecently = true;
      } else {
        this.ifFocusedOnUppyRecently = false;
        this.superFocus.cancel();
      }
    });
    __publicField(this, "disableInteractiveElements", (disable) => {
      const NODES_TO_DISABLE = [
        "a[href]",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
        "button:not([disabled])",
        '[role="button"]:not([disabled])'
      ];
      const nodesToDisable = __privateGet(this, _disabledNodes) ?? toArray_default(this.el.querySelectorAll(NODES_TO_DISABLE)).filter((node) => !node.classList.contains("uppy-Dashboard-close"));
      for (const node of nodesToDisable) {
        if (node.tagName === "A") {
          node.setAttribute("aria-disabled", disable);
        } else {
          node.disabled = disable;
        }
      }
      if (disable) {
        __privateSet(this, _disabledNodes, nodesToDisable);
      } else {
        __privateSet(this, _disabledNodes, null);
      }
      this.dashboardIsDisabled = disable;
    });
    __publicField(this, "updateBrowserHistory", () => {
      var _a;
      if (!((_a = history.state) == null ? void 0 : _a[this.modalName])) {
        history.pushState({
          ...history.state,
          [this.modalName]: true
        }, "");
      }
      window.addEventListener("popstate", this.handlePopState, false);
    });
    __publicField(this, "handlePopState", (event) => {
      var _a;
      if (this.isModalOpen() && (!event.state || !event.state[this.modalName])) {
        this.closeModal({ manualClose: false });
      }
      if (!this.isModalOpen() && ((_a = event.state) == null ? void 0 : _a[this.modalName])) {
        history.back();
      }
    });
    __publicField(this, "handleKeyDownInModal", (event) => {
      if (event.keyCode === ESC_KEY)
        this.requestCloseModal();
      if (event.keyCode === TAB_KEY)
        trapFocus(event, this.getPluginState().activeOverlayType, this.el);
    });
    __publicField(this, "handleClickOutside", () => {
      if (this.opts.closeModalOnClickOutside)
        this.requestCloseModal();
    });
    __publicField(this, "handlePaste", (event) => {
      this.uppy.iteratePlugins((plugin) => {
        var _a;
        if (plugin.type === "acquirer") {
          ;
          (_a = plugin.handleRootPaste) == null ? void 0 : _a.call(plugin, event);
        }
      });
      const files = toArray_default(event.clipboardData.files);
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files pasted");
        this.addFiles(files);
      }
    });
    __publicField(this, "handleInputChange", (event) => {
      event.preventDefault();
      const files = toArray_default(event.currentTarget.files || []);
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files selected through input");
        this.addFiles(files);
      }
    });
    __publicField(this, "handleDragOver", (event) => {
      event.preventDefault();
      event.stopPropagation();
      const canSomePluginHandleRootDrop = () => {
        let somePluginCanHandleRootDrop2 = true;
        this.uppy.iteratePlugins((plugin) => {
          var _a;
          if ((_a = plugin.canHandleRootDrop) == null ? void 0 : _a.call(plugin, event)) {
            somePluginCanHandleRootDrop2 = true;
          }
        });
        return somePluginCanHandleRootDrop2;
      };
      const doesEventHaveFiles = () => {
        const { types } = event.dataTransfer;
        return types.some((type) => type === "Files");
      };
      const somePluginCanHandleRootDrop = canSomePluginHandleRootDrop();
      const hasFiles = doesEventHaveFiles();
      if (!somePluginCanHandleRootDrop && !hasFiles || this.opts.disabled || // opts.disableLocalFiles should only be taken into account if no plugins
      // can handle the datatransfer
      this.opts.disableLocalFiles && (hasFiles || !somePluginCanHandleRootDrop) || !this.uppy.getState().allowNewUpload) {
        event.dataTransfer.dropEffect = "none";
        return;
      }
      event.dataTransfer.dropEffect = "copy";
      this.setPluginState({ isDraggingOver: true });
      this.opts.onDragOver(event);
    });
    __publicField(this, "handleDragLeave", (event) => {
      event.preventDefault();
      event.stopPropagation();
      this.setPluginState({ isDraggingOver: false });
      this.opts.onDragLeave(event);
    });
    __publicField(this, "handleDrop", async (event) => {
      event.preventDefault();
      event.stopPropagation();
      this.setPluginState({ isDraggingOver: false });
      this.uppy.iteratePlugins((plugin) => {
        var _a;
        if (plugin.type === "acquirer") {
          ;
          (_a = plugin.handleRootDrop) == null ? void 0 : _a.call(plugin, event);
        }
      });
      let executedDropErrorOnce = false;
      const logDropError = (error) => {
        this.uppy.log(error, "error");
        if (!executedDropErrorOnce) {
          this.uppy.info(error.message, "error");
          executedDropErrorOnce = true;
        }
      };
      this.uppy.log("[Dashboard] Processing dropped files");
      const files = await getDroppedFiles(event.dataTransfer, { logDropError });
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files dropped");
        this.addFiles(files);
      }
      this.opts.onDrop(event);
    });
    __publicField(this, "handleRequestThumbnail", (file) => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit("thumbnail:request", file);
      }
    });
    /**
     * We cancel thumbnail requests when a file item component unmounts to avoid
     * clogging up the queue when the user scrolls past many elements.
     */
    __publicField(this, "handleCancelThumbnail", (file) => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit("thumbnail:cancel", file);
      }
    });
    __publicField(this, "handleKeyDownInInline", (event) => {
      if (event.keyCode === TAB_KEY)
        forInline(event, this.getPluginState().activeOverlayType, this.el);
    });
    // ___Why do we listen to the 'paste' event on a document instead of onPaste={props.handlePaste} prop,
    //    or this.el.addEventListener('paste')?
    //    Because (at least) Chrome doesn't handle paste if focus is on some button, e.g. 'My Device'.
    //    => Therefore, the best option is to listen to all 'paste' events, and only react to them when we are focused on our
    //       particular Uppy instance.
    // ___Why do we still need onPaste={props.handlePaste} for the DashboardUi?
    //    Because if we click on the 'Drop files here' caption e.g., `document.activeElement` will be 'body'. Which means our
    //    standard determination of whether we're pasting into our Uppy instance won't work.
    //    => Therefore, we need a traditional onPaste={props.handlePaste} handler too.
    __publicField(this, "handlePasteOnBody", (event) => {
      const isFocusInOverlay2 = this.el.contains(document.activeElement);
      if (isFocusInOverlay2) {
        this.handlePaste(event);
      }
    });
    __publicField(this, "handleComplete", ({ failed }) => {
      if (this.opts.closeAfterFinish && !(failed == null ? void 0 : failed.length)) {
        this.requestCloseModal();
      }
    });
    __publicField(this, "handleCancelRestore", () => {
      this.uppy.emit("restore-canceled");
    });
    __privateAdd(this, _generateLargeThumbnailIfSingleFile, () => {
      if (this.opts.disableThumbnailGenerator) {
        return;
      }
      const LARGE_THUMBNAIL = 600;
      const files = this.uppy.getFiles();
      if (files.length === 1) {
        const thumbnailGenerator = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
        thumbnailGenerator == null ? void 0 : thumbnailGenerator.setOptions({ thumbnailWidth: LARGE_THUMBNAIL });
        const fileForThumbnail = { ...files[0], preview: void 0 };
        thumbnailGenerator == null ? void 0 : thumbnailGenerator.requestThumbnail(fileForThumbnail).then(() => {
          thumbnailGenerator == null ? void 0 : thumbnailGenerator.setOptions({
            thumbnailWidth: this.opts.thumbnailWidth
          });
        });
      }
    });
    __privateAdd(this, _openFileEditorWhenFilesAdded, (files) => {
      const firstFile = files[0];
      const { metaFields } = this.getPluginState();
      const isMetaEditorEnabled = metaFields && metaFields.length > 0;
      const isImageEditorEnabled = this.canEditFile(firstFile);
      if (isMetaEditorEnabled && this.opts.autoOpen === "metaEditor") {
        this.toggleFileCard(true, firstFile.id);
      } else if (isImageEditorEnabled && this.opts.autoOpen === "imageEditor") {
        this.openFileEditor(firstFile);
      }
    });
    __publicField(this, "initEvents", () => {
      if (this.opts.trigger && !this.opts.inline) {
        const showModalTrigger = findAllDOMElements_default(this.opts.trigger);
        if (showModalTrigger) {
          showModalTrigger.forEach((trigger) => trigger.addEventListener("click", this.openModal));
        } else {
          this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning");
        }
      }
      this.startListeningToResize();
      document.addEventListener("paste", this.handlePasteOnBody);
      this.uppy.on("plugin-added", __privateGet(this, _addSupportedPluginIfNoTarget));
      this.uppy.on("plugin-remove", this.removeTarget);
      this.uppy.on("file-added", this.hideAllPanels);
      this.uppy.on("dashboard:modal-closed", this.hideAllPanels);
      this.uppy.on("complete", this.handleComplete);
      this.uppy.on("files-added", __privateGet(this, _generateLargeThumbnailIfSingleFile));
      this.uppy.on("file-removed", __privateGet(this, _generateLargeThumbnailIfSingleFile));
      document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener("click", this.recordIfFocusedOnUppyRecently, true);
      if (this.opts.inline) {
        this.el.addEventListener("keydown", this.handleKeyDownInInline);
      }
      if (this.opts.autoOpen) {
        this.uppy.on("files-added", __privateGet(this, _openFileEditorWhenFilesAdded));
      }
    });
    __publicField(this, "removeEvents", () => {
      const showModalTrigger = findAllDOMElements_default(this.opts.trigger);
      if (!this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach((trigger) => trigger.removeEventListener("click", this.openModal));
      }
      this.stopListeningToResize();
      document.removeEventListener("paste", this.handlePasteOnBody);
      window.removeEventListener("popstate", this.handlePopState, false);
      this.uppy.off("plugin-added", __privateGet(this, _addSupportedPluginIfNoTarget));
      this.uppy.off("plugin-remove", this.removeTarget);
      this.uppy.off("file-added", this.hideAllPanels);
      this.uppy.off("dashboard:modal-closed", this.hideAllPanels);
      this.uppy.off("complete", this.handleComplete);
      this.uppy.off("files-added", __privateGet(this, _generateLargeThumbnailIfSingleFile));
      this.uppy.off("file-removed", __privateGet(this, _generateLargeThumbnailIfSingleFile));
      document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently);
      document.removeEventListener("click", this.recordIfFocusedOnUppyRecently);
      if (this.opts.inline) {
        this.el.removeEventListener("keydown", this.handleKeyDownInInline);
      }
      if (this.opts.autoOpen) {
        this.uppy.off("files-added", __privateGet(this, _openFileEditorWhenFilesAdded));
      }
    });
    __publicField(this, "superFocusOnEachUpdate", () => {
      const isFocusInUppy = this.el.contains(document.activeElement);
      const isFocusNowhere = document.activeElement === document.body || document.activeElement === null;
      const isInformerHidden = this.uppy.getState().info.length === 0;
      const isModal = !this.opts.inline;
      if (
        // If update is connected to showing the Informer - let the screen reader calmly read it.
        isInformerHidden && // If we are in a modal - always superfocus without concern for other elements
        // on the page (user is unlikely to want to interact with the rest of the page)
        (isModal || // If we are already inside of Uppy, or
        isFocusInUppy || // If we are not focused on anything BUT we have already, at least once, focused on uppy
        //   1. We focus when isFocusNowhere, because when the element we were focused
        //      on disappears (e.g. an overlay), - focus gets lost. If user is typing
        //      something somewhere else on the page, - focus won't be 'nowhere'.
        //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently,
        //      to avoid focus jumps if we do something else on the page.
        //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode,
        //                     when file is uploading, - navigate via tab to the checkbox,
        //                     try to press space multiple times. Focus will jump to Uppy.
        isFocusNowhere && this.ifFocusedOnUppyRecently)
      ) {
        this.superFocus(this.el, this.getPluginState().activeOverlayType);
      } else {
        this.superFocus.cancel();
      }
    });
    __publicField(this, "afterUpdate", () => {
      if (this.opts.disabled && !this.dashboardIsDisabled) {
        this.disableInteractiveElements(true);
        return;
      }
      if (!this.opts.disabled && this.dashboardIsDisabled) {
        this.disableInteractiveElements(false);
      }
      this.superFocusOnEachUpdate();
    });
    __publicField(this, "saveFileCard", (meta, fileID) => {
      this.uppy.setFileMeta(fileID, meta);
      this.toggleFileCard(false, fileID);
    });
    __privateAdd(this, _attachRenderFunctionToTarget, (target) => {
      const plugin = this.uppy.getPlugin(target.id);
      return {
        ...target,
        icon: plugin.icon || this.opts.defaultPickerIcon,
        render: plugin.render
      };
    });
    __privateAdd(this, _isTargetSupported, (target) => {
      const plugin = this.uppy.getPlugin(target.id);
      if (typeof plugin.isSupported !== "function") {
        return true;
      }
      return plugin.isSupported();
    });
    __privateAdd(this, _getAcquirers, (targets) => {
      return targets.filter((target) => target.type === "acquirer" && __privateGet(this, _isTargetSupported).call(this, target)).map(__privateGet(this, _attachRenderFunctionToTarget));
    });
    __privateAdd(this, _getProgressIndicators, (targets) => {
      return targets.filter((target) => target.type === "progressindicator").map(__privateGet(this, _attachRenderFunctionToTarget));
    });
    __privateAdd(this, _getEditors, (targets) => {
      return targets.filter((target) => target.type === "editor").map(__privateGet(this, _attachRenderFunctionToTarget));
    });
    __publicField(this, "render", (state) => {
      const pluginState = this.getPluginState();
      const { files, capabilities, allowNewUpload } = state;
      const { newFiles, uploadStartedFiles, completeFiles, erroredFiles, inProgressFiles, inProgressNotPausedFiles, processingFiles, isUploadStarted, isAllComplete, isAllPaused } = this.uppy.getObjectOfFilesPerState();
      const acquirers = __privateGet(this, _getAcquirers).call(this, pluginState.targets);
      const progressindicators = __privateGet(this, _getProgressIndicators).call(this, pluginState.targets);
      const editors = __privateGet(this, _getEditors).call(this, pluginState.targets);
      let theme;
      if (this.opts.theme === "auto") {
        theme = capabilities.darkMode ? "dark" : "light";
      } else {
        theme = this.opts.theme;
      }
      if (["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0) {
        this.opts.fileManagerSelectionType = "files";
        console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`);
      }
      return Dashboard({
        state,
        isHidden: pluginState.isHidden,
        files,
        newFiles,
        uploadStartedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted,
        isAllComplete,
        isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload,
        acquirers,
        theme,
        disabled: this.opts.disabled,
        disableLocalFiles: this.opts.disableLocalFiles,
        direction: this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        saveFileEditor: this.saveFileEditor,
        closeFileEditor: this.closeFileEditor,
        disableInteractiveElements: this.disableInteractiveElements,
        animateOpenClose: this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        progressindicators,
        editors,
        autoProceed: this.uppy.opts.autoProceed,
        id: this.id,
        closeModal: this.requestCloseModal,
        handleClickOutside: this.handleClickOutside,
        handleInputChange: this.handleInputChange,
        handlePaste: this.handlePaste,
        inline: this.opts.inline,
        showPanel: this.showPanel,
        hideAllPanels: this.hideAllPanels,
        i18n: this.i18n,
        i18nArray: this.i18nArray,
        uppy: this.uppy,
        note: this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: this.toggleFileCard,
        toggleAddFilesPanel: this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: this.saveFileCard,
        openFileEditor: this.openFileEditor,
        canEditFile: this.canEditFile,
        width: this.opts.width,
        height: this.opts.height,
        showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: this.opts.hideCancelButton,
        hideRetryButton: this.opts.hideRetryButton,
        hidePauseResumeButton: this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        parentElement: this.el,
        allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
        requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
        showSelectedFiles: this.opts.showSelectedFiles,
        showNativePhotoCameraButton: this.opts.showNativePhotoCameraButton,
        showNativeVideoCameraButton: this.opts.showNativeVideoCameraButton,
        nativeCameraFacingMode: this.opts.nativeCameraFacingMode,
        singleFileFullScreen: this.opts.singleFileFullScreen,
        handleCancelRestore: this.handleCancelRestore,
        handleRequestThumbnail: this.handleRequestThumbnail,
        handleCancelThumbnail: this.handleCancelThumbnail,
        // drag props
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: this.handleDragOver,
        handleDragLeave: this.handleDragLeave,
        handleDrop: this.handleDrop
      });
    });
    __privateAdd(this, _addSpecifiedPluginsFromOptions, () => {
      const { plugins } = this.opts;
      plugins.forEach((pluginID) => {
        const plugin = this.uppy.getPlugin(pluginID);
        if (plugin) {
          ;
          plugin.mount(this, plugin);
        } else {
          this.uppy.log(`[Uppy] Dashboard could not find plugin '${pluginID}', make sure to uppy.use() the plugins you are specifying`, "warning");
        }
      });
    });
    __privateAdd(this, _autoDiscoverPlugins, () => {
      this.uppy.iteratePlugins(__privateGet(this, _addSupportedPluginIfNoTarget));
    });
    __privateAdd(this, _addSupportedPluginIfNoTarget, (plugin) => {
      var _a;
      const typesAllowed = ["acquirer", "editor"];
      if (plugin && !((_a = plugin.opts) == null ? void 0 : _a.target) && typesAllowed.includes(plugin.type)) {
        const pluginAlreadyAdded = this.getPluginState().targets.some((installedPlugin) => plugin.id === installedPlugin.id);
        if (!pluginAlreadyAdded) {
          ;
          plugin.mount(this, plugin);
        }
      }
    });
    __publicField(this, "install", () => {
      var _a;
      this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: void 0,
        showFileEditor: false,
        metaFields: this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });
      const { inline, closeAfterFinish } = this.opts;
      if (inline && closeAfterFinish) {
        throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.");
      }
      const { allowMultipleUploads, allowMultipleUploadBatches } = this.uppy.opts;
      if ((allowMultipleUploads || allowMultipleUploadBatches) && closeAfterFinish) {
        this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning");
      }
      const { target } = this.opts;
      if (target) {
        this.mount(target, this);
      }
      if (!this.opts.disableStatusBar) {
        this.uppy.use(StatusBar, {
          id: __privateMethod(this, _Dashboard_instances, getStatusBarId_fn).call(this),
          target: this,
          ...__privateMethod(this, _Dashboard_instances, getStatusBarOpts_fn).call(this)
        });
      }
      if (!this.opts.disableInformer) {
        this.uppy.use(Informer, {
          id: __privateMethod(this, _Dashboard_instances, getInformerId_fn).call(this),
          target: this,
          ...__privateMethod(this, _Dashboard_instances, getInformerOpts_fn).call(this)
        });
      }
      if (!this.opts.disableThumbnailGenerator) {
        this.uppy.use(ThumbnailGenerator, {
          id: __privateMethod(this, _Dashboard_instances, getThumbnailGeneratorId_fn).call(this),
          ...__privateMethod(this, _Dashboard_instances, getThumbnailGeneratorOpts_fn).call(this)
        });
      }
      this.darkModeMediaQuery = typeof window !== "undefined" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
      const isDarkModeOnFromTheStart = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : false;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnFromTheStart ? "on" : "off"}`);
      this.setDarkModeCapability(isDarkModeOnFromTheStart);
      if (this.opts.theme === "auto") {
        (_a = this.darkModeMediaQuery) == null ? void 0 : _a.addListener(this.handleSystemDarkModeChange);
      }
      __privateGet(this, _addSpecifiedPluginsFromOptions).call(this);
      __privateGet(this, _autoDiscoverPlugins).call(this);
      this.initEvents();
    });
    __publicField(this, "uninstall", () => {
      var _a;
      if (!this.opts.disableInformer) {
        const informer = this.uppy.getPlugin(`${this.id}:Informer`);
        if (informer)
          this.uppy.removePlugin(informer);
      }
      if (!this.opts.disableStatusBar) {
        const statusBar = this.uppy.getPlugin(`${this.id}:StatusBar`);
        if (statusBar)
          this.uppy.removePlugin(statusBar);
      }
      if (!this.opts.disableThumbnailGenerator) {
        const thumbnail = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
        if (thumbnail)
          this.uppy.removePlugin(thumbnail);
      }
      const { plugins } = this.opts;
      plugins.forEach((pluginID) => {
        const plugin = this.uppy.getPlugin(pluginID);
        if (plugin)
          plugin.unmount();
      });
      if (this.opts.theme === "auto") {
        (_a = this.darkModeMediaQuery) == null ? void 0 : _a.removeListener(this.handleSystemDarkModeChange);
      }
      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove("uppy-Dashboard-isFixed");
      }
      this.unmount();
      this.removeEvents();
    });
    this.id = this.opts.id || "Dashboard";
    this.title = "Dashboard";
    this.type = "orchestrator";
    this.defaultLocale = locale_default3;
    if (this.opts.doneButtonHandler === void 0) {
      this.opts.doneButtonHandler = () => {
        this.uppy.clear();
        this.requestCloseModal();
      };
    }
    (_a = this.opts).onRequestCloseModal ?? (_a.onRequestCloseModal = () => this.closeModal());
    this.i18nInit();
  }
  setOptions(opts) {
    var _a, _b;
    super.setOptions(opts);
    (_a = this.uppy.getPlugin(__privateMethod(this, _Dashboard_instances, getStatusBarId_fn).call(this))) == null ? void 0 : _a.setOptions(__privateMethod(this, _Dashboard_instances, getStatusBarOpts_fn).call(this));
    (_b = this.uppy.getPlugin(__privateMethod(this, _Dashboard_instances, getThumbnailGeneratorId_fn).call(this))) == null ? void 0 : _b.setOptions(__privateMethod(this, _Dashboard_instances, getThumbnailGeneratorOpts_fn).call(this));
  }
};
_disabledNodes = new WeakMap();
_generateLargeThumbnailIfSingleFile = new WeakMap();
_openFileEditorWhenFilesAdded = new WeakMap();
_attachRenderFunctionToTarget = new WeakMap();
_isTargetSupported = new WeakMap();
_getAcquirers = new WeakMap();
_getProgressIndicators = new WeakMap();
_getEditors = new WeakMap();
_addSpecifiedPluginsFromOptions = new WeakMap();
_autoDiscoverPlugins = new WeakMap();
_addSupportedPluginIfNoTarget = new WeakMap();
_Dashboard_instances = new WeakSet();
getStatusBarOpts_fn = function() {
  const { hideUploadButton, hideRetryButton, hidePauseResumeButton, hideCancelButton, showProgressDetails, hideProgressAfterFinish, locale: l3, doneButtonHandler } = this.opts;
  return {
    hideUploadButton,
    hideRetryButton,
    hidePauseResumeButton,
    hideCancelButton,
    showProgressDetails,
    hideAfterFinish: hideProgressAfterFinish,
    locale: l3,
    doneButtonHandler
  };
};
getThumbnailGeneratorOpts_fn = function() {
  const { thumbnailWidth, thumbnailHeight, thumbnailType, waitForThumbnailsBeforeUpload } = this.opts;
  return {
    thumbnailWidth,
    thumbnailHeight,
    thumbnailType,
    waitForThumbnailsBeforeUpload,
    // If we don't block on thumbnails, we can lazily generate them
    lazy: !waitForThumbnailsBeforeUpload
  };
};
getInformerOpts_fn = function() {
  return {
    // currently no options
  };
};
getStatusBarId_fn = function() {
  return `${this.id}:StatusBar`;
};
getThumbnailGeneratorId_fn = function() {
  return `${this.id}:ThumbnailGenerator`;
};
getInformerId_fn = function() {
  return `${this.id}:Informer`;
};
__publicField(Dashboard2, "VERSION", package_default5.version);

// node_modules/@uppy/react/lib/Dashboard.js
var import_react = __toESM(require_react(), 1);

// node_modules/@uppy/react/lib/getHTMLProps.js
var reactSupportedHtmlAttr = [
  // React-specific Attributes
  "defaultChecked",
  "defaultValue",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "dangerouslySetInnerHTML",
  // Standard HTML Attributes
  "accessKey",
  "className",
  "contentEditable",
  "contextMenu",
  "dir",
  "draggable",
  "hidden",
  "id",
  "lang",
  "placeholder",
  "slot",
  "spellCheck",
  "style",
  "tabIndex",
  "title",
  "translate",
  // Unknown
  "radioGroup",
  // WAI-ARIA
  "role",
  // RDFa Attributes
  "about",
  "datatype",
  "inlist",
  "prefix",
  "property",
  "resource",
  "typeof",
  "vocab",
  // Non-standard Attributes
  "autoCapitalize",
  "autoCorrect",
  "autoSave",
  "color",
  "itemProp",
  "itemScope",
  "itemType",
  "itemID",
  "itemRef",
  "results",
  "security",
  "unselectable",
  // Living Standard
  "inputMode",
  "is",
  // Clipboard Events
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  // Composition Events
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  // Focus Events
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  // Form Events
  "onChange",
  "onChangeCapture",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  // Image Events
  "onLoad",
  "onLoadCapture",
  "onError",
  // also a Media Event
  "onErrorCapture",
  // also a Media Event
  // Keyboard Events
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  // Media Events
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  // MouseEvents
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  // Selection Events
  "onSelect",
  "onSelectCapture",
  // Touch Events
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  // Pointer Events
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerMoveCapture",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerEnterCapture",
  "onPointerLeave",
  "onPointerLeaveCapture",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  // UI Events
  "onScroll",
  "onScrollCapture",
  // Wheel Events
  "onWheel",
  "onWheelCapture",
  // Animation Events
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  // Transition Events
  "onTransitionEnd",
  "onTransitionEndCapture"
];
var validHTMLAttribute = /^(aria-|data-)/;
var getHTMLProps = (props) => {
  return Object.fromEntries(Object.entries(props).filter(([key]) => validHTMLAttribute.test(key) || reactSupportedHtmlAttr.includes(key)));
};
var getHTMLProps_default = getHTMLProps;

// node_modules/@uppy/react/lib/nonHtmlPropsHaveChanged.js
function nonHtmlPropsHaveChanged(props, prevProps) {
  const htmlProps = getHTMLProps_default(props);
  return Object.keys(props).some((key) => !Object.hasOwn(htmlProps, key) && props[key] !== prevProps[key]);
}

// node_modules/@uppy/react/lib/Dashboard.js
var Dashboard3 = class extends import_react.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged(this.props, prevProps)) {
      const { uppy, ...options } = { ...this.props, target: this.container };
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { uppy, ...options } = {
      id: "Dashboard",
      ...this.props,
      inline: true,
      target: this.container
    };
    uppy.use(Dashboard2, options);
    this.plugin = uppy.getPlugin(options.id);
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      },
      ...getHTMLProps_default(this.props)
    });
  }
};
var Dashboard_default = Dashboard3;

// node_modules/@uppy/react/lib/DashboardModal.js
var import_react2 = __toESM(require_react(), 1);
var DashboardModal = class extends import_react2.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    const { uppy, open, onRequestClose } = this.props;
    if (prevProps.uppy !== uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged(this.props, prevProps)) {
      const { uppy: uppy2, ...options } = {
        ...this.props,
        inline: false,
        onRequestCloseModal: onRequestClose
      };
      this.plugin.setOptions(options);
    }
    if (prevProps.open && !open) {
      this.plugin.closeModal();
    } else if (!prevProps.open && open) {
      this.plugin.openModal();
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { target = this.container, open, onRequestClose, uppy, ...rest } = this.props;
    const options = {
      id: "DashboardModal",
      ...rest,
      inline: false,
      target,
      open,
      onRequestCloseModal: onRequestClose
    };
    uppy.use(Dashboard2, options);
    this.plugin = uppy.getPlugin(options.id);
    if (open) {
      this.plugin.openModal();
    }
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react2.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      },
      ...getHTMLProps_default(this.props)
    });
  }
};
__publicField(DashboardModal, "defaultProps", {
  open: void 0,
  onRequestClose: void 0
});
var DashboardModal_default = DashboardModal;

// node_modules/@uppy/drag-drop/package.json
var package_default6 = {
  name: "@uppy/drag-drop",
  description: "Droppable zone UI for Uppy. Drag and drop files into it to upload.",
  version: "4.2.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "drag-drop",
    "drag",
    "drop",
    "dropzone",
    "upload"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    preact: "^10.5.13"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  },
  devDependencies: {
    cssnano: "^7.0.7",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3"
  }
};

// node_modules/@uppy/drag-drop/lib/locale.js
var locale_default4 = {
  strings: {
    // Text to show on the droppable area.
    // `%{browse}` is replaced with a link that opens the system file selection dialog.
    dropHereOr: "Drop here or %{browse}",
    // Used as the label for the link that opens the system file selection dialog.
    browse: "browse"
  }
};

// node_modules/@uppy/drag-drop/lib/DragDrop.js
var defaultOptions5 = {
  inputName: "files[]",
  width: "100%",
  height: "100%"
};
var _DragDrop = class _DragDrop extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, {
      ...defaultOptions5,
      ...opts
    });
    // Check for browser dragDrop support
    __publicField(this, "isDragDropSupported", isDragDropSupported());
    __publicField(this, "fileInputRef");
    __publicField(this, "addFiles", (files) => {
      const descriptors = files.map((file) => ({
        source: this.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: file.relativePath || null
        }
      }));
      try {
        this.uppy.addFiles(descriptors);
      } catch (err) {
        this.uppy.log(err);
      }
    });
    __publicField(this, "onInputChange", (event) => {
      const files = toArray_default(event.currentTarget.files || []);
      if (files.length > 0) {
        this.uppy.log("[DragDrop] Files selected through input");
        this.addFiles(files);
      }
      event.currentTarget.value = "";
    });
    __publicField(this, "handleDragOver", (event) => {
      var _a, _b;
      event.preventDefault();
      event.stopPropagation();
      const { types } = event.dataTransfer;
      const hasFiles = types.some((type) => type === "Files");
      const { allowNewUpload } = this.uppy.getState();
      if (!hasFiles || !allowNewUpload) {
        event.dataTransfer.dropEffect = "none";
        return;
      }
      event.dataTransfer.dropEffect = "copy";
      this.setPluginState({ isDraggingOver: true });
      (_b = (_a = this.opts).onDragOver) == null ? void 0 : _b.call(_a, event);
    });
    __publicField(this, "handleDragLeave", (event) => {
      var _a, _b;
      event.preventDefault();
      event.stopPropagation();
      this.setPluginState({ isDraggingOver: false });
      (_b = (_a = this.opts).onDragLeave) == null ? void 0 : _b.call(_a, event);
    });
    __publicField(this, "handleDrop", async (event) => {
      var _a, _b;
      event.preventDefault();
      event.stopPropagation();
      this.setPluginState({ isDraggingOver: false });
      const logDropError = (error) => {
        this.uppy.log(error, "error");
      };
      const files = await getDroppedFiles(event.dataTransfer, { logDropError });
      if (files.length > 0) {
        this.uppy.log("[DragDrop] Files dropped");
        this.addFiles(files);
      }
      (_b = (_a = this.opts).onDrop) == null ? void 0 : _b.call(_a, event);
    });
    this.type = "acquirer";
    this.id = this.opts.id || "DragDrop";
    this.title = "Drag & Drop";
    this.defaultLocale = locale_default4;
    this.i18nInit();
  }
  renderHiddenFileInput() {
    var _a;
    const { restrictions } = this.uppy.opts;
    return u("input", { className: "uppy-DragDrop-input", type: "file", hidden: true, ref: (ref) => {
      this.fileInputRef = ref;
    }, name: this.opts.inputName, multiple: restrictions.maxNumberOfFiles !== 1, accept: (_a = restrictions.allowedFileTypes) == null ? void 0 : _a.join(", "), onChange: this.onInputChange });
  }
  static renderArrowSvg() {
    return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-DragDrop-arrow", width: "16", height: "16", viewBox: "0 0 16 16", children: u("path", { d: "M11 10V0H5v10H2l6 6 6-6h-3zm0 0", fillRule: "evenodd" }) });
  }
  renderLabel() {
    return u("div", { className: "uppy-DragDrop-label", children: this.i18nArray("dropHereOr", {
      browse: u("span", { className: "uppy-DragDrop-browse", children: this.i18n("browse") })
    }) });
  }
  renderNote() {
    return u("span", { className: "uppy-DragDrop-note", children: this.opts.note });
  }
  render() {
    const dragDropClass = `uppy-u-reset
      uppy-DragDrop-container
      ${this.isDragDropSupported ? "uppy-DragDrop--isDragDropSupported" : ""}
      ${this.getPluginState().isDraggingOver ? "uppy-DragDrop--isDraggingOver" : ""}
    `;
    const dragDropStyle = {
      width: this.opts.width,
      height: this.opts.height
    };
    return u("button", { type: "button", className: dragDropClass, style: dragDropStyle, onClick: () => this.fileInputRef.click(), onDragOver: this.handleDragOver, onDragLeave: this.handleDragLeave, onDrop: this.handleDrop, children: [this.renderHiddenFileInput(), u("div", { className: "uppy-DragDrop-inner", children: [_DragDrop.renderArrowSvg(), this.renderLabel(), this.renderNote()] })] });
  }
  install() {
    const { target } = this.opts;
    this.setPluginState({
      isDraggingOver: false
    });
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
};
__publicField(_DragDrop, "VERSION", package_default6.version);
var DragDrop = _DragDrop;

// node_modules/@uppy/react/lib/DragDrop.js
var import_react3 = __toESM(require_react(), 1);
var DragDrop2 = class extends import_react3.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged(this.props, prevProps)) {
      const { uppy, ...options } = { ...this.props, target: this.container };
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { uppy, locale, inputName, width, height, note, id } = this.props;
    const options = {
      id: id || "DragDrop",
      locale,
      inputName,
      width,
      height,
      note,
      target: this.container
    };
    uppy.use(DragDrop, options);
    this.plugin = uppy.getPlugin(options.id);
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react3.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      },
      ...getHTMLProps_default(this.props)
    });
  }
};
var DragDrop_default = DragDrop2;

// node_modules/@uppy/file-input/package.json
var package_default7 = {
  name: "@uppy/file-input",
  description: "Simple UI of a file input button that works with Uppy right out of the box",
  version: "4.2.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build"
  },
  keywords: [
    "file uploader",
    "upload",
    "uppy",
    "uppy-plugin",
    "file-input"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    preact: "^10.5.13"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  },
  devDependencies: {
    cssnano: "^7.0.7",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3"
  }
};

// node_modules/@uppy/file-input/lib/locale.js
var locale_default5 = {
  strings: {
    chooseFiles: "Choose files"
  }
};

// node_modules/@uppy/file-input/lib/FileInput.js
var defaultOptions6 = {
  pretty: true,
  inputName: "files[]"
};
var FileInput = class extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, { ...defaultOptions6, ...opts });
    __publicField(this, "input", null);
    this.id = this.opts.id || "FileInput";
    this.title = "File Input";
    this.type = "acquirer";
    this.defaultLocale = locale_default5;
    this.i18nInit();
    this.render = this.render.bind(this);
    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }
  addFiles(files) {
    const descriptors = files.map((file) => ({
      source: this.id,
      name: file.name,
      type: file.type,
      data: file
    }));
    try {
      this.uppy.addFiles(descriptors);
    } catch (err) {
      this.uppy.log(err);
    }
  }
  handleInputChange(event) {
    this.uppy.log("[FileInput] Something selected through input...");
    const files = toArray_default(event.currentTarget.files || []);
    this.addFiles(files);
    event.currentTarget.value = "";
  }
  handleClick() {
    this.input.click();
  }
  render() {
    var _a;
    const hiddenInputStyle = {
      width: "0.1px",
      height: "0.1px",
      opacity: 0,
      overflow: "hidden",
      position: "absolute",
      zIndex: -1
    };
    const { restrictions } = this.uppy.opts;
    return u("div", { className: "uppy-FileInput-container", children: [u("input", { className: "uppy-FileInput-input", style: this.opts.pretty ? hiddenInputStyle : void 0, type: "file", name: this.opts.inputName, onChange: this.handleInputChange, multiple: restrictions.maxNumberOfFiles !== 1, accept: (_a = restrictions.allowedFileTypes) == null ? void 0 : _a.join(", "), ref: (input) => {
      this.input = input;
    } }), this.opts.pretty && u("button", { className: "uppy-FileInput-btn", type: "button", onClick: this.handleClick, children: this.i18n("chooseFiles") })] });
  }
  install() {
    const { target } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
};
__publicField(FileInput, "VERSION", package_default7.version);

// node_modules/@uppy/react/lib/FileInput.js
var import_react4 = __toESM(require_react(), 1);
var FileInput2 = class extends import_react4.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { uppy, locale, pretty, inputName, id } = this.props;
    const options = {
      id: id || "FileInput",
      locale,
      pretty,
      inputName,
      target: this.container
    };
    uppy.use(FileInput, options);
    this.plugin = uppy.getPlugin(options.id);
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react4.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      }
    });
  }
};
// Must be kept in sync with @uppy/file-input/src/FileInput.js
__publicField(FileInput2, "defaultProps", {
  locale: void 0,
  pretty: true,
  inputName: "files[]"
});
var FileInput_default = FileInput2;

// node_modules/@uppy/react/lib/headless/generated/Dropzone.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);

// node_modules/@uppy/components/lib/hooks/dropzone.js
var fileInputId = "uppy-dropzone-file-input";
function createDropzone(ctx, options = {}) {
  const handleDrop = (event) => {
    var _a, _b;
    event.preventDefault();
    event.stopPropagation();
    const files = Array.from(((_a = event.dataTransfer) == null ? void 0 : _a.files) ?? []);
    if (!files.length)
      return;
    (_b = options.onDrop) == null ? void 0 : _b.call(options, files);
    ctx.uppy.addFiles(files.map((file) => ({
      name: file.name,
      type: file.type,
      data: file
    })));
  };
  const handleDragOver = (event) => {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    (_a = options.onDragOver) == null ? void 0 : _a.call(options, event);
  };
  const handleDragEnter = (event) => {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    (_a = options.onDragEnter) == null ? void 0 : _a.call(options, event);
  };
  const handleDragLeave = (event) => {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    (_a = options.onDragLeave) == null ? void 0 : _a.call(options, event);
  };
  const handleClick = () => {
    if (options.noClick)
      return;
    const input = document.getElementById(fileInputId);
    input == null ? void 0 : input.click();
  };
  const handleFileInputChange = (event) => {
    var _a;
    const input = event.target;
    const files = Array.from(input.files ?? []);
    if (!files.length)
      return;
    (_a = options.onFileInputChange) == null ? void 0 : _a.call(options, files);
    ctx.uppy.addFiles(files.map((file) => ({
      source: "drag-drop",
      name: file.name,
      type: file.type,
      data: file
    })));
    input.value = "";
  };
  return {
    getRootProps: () => ({
      onDragEnter: handleDragEnter,
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDrop: handleDrop,
      onClick: handleClick
    }),
    getInputProps: () => ({
      id: fileInputId,
      type: "file",
      multiple: true,
      onChange: handleFileInputChange
    })
  };
}

// node_modules/@uppy/components/lib/Dropzone.js
function Dropzone(props) {
  const { width, height, note, noClick, ctx } = props;
  if (!ctx.uppy) {
    throw new Error("Dropzone must be used within a UppyContextProvider");
  }
  const { getRootProps, getInputProps } = T(() => createDropzone(ctx, { noClick }), [ctx, noClick]);
  return u("div", { className: "uppy-reset", "data-uppy-element": "dropzone", role: "presentation", tabIndex: 0, children: [u("input", { ...getInputProps(), tabIndex: -1, name: "uppy-dropzone-file-input", className: "uppy:hidden" }), u("div", { ...getRootProps(), style: {
    width: width || "100%",
    height: height || "100%"
  }, className: clsx("uppy:border-2 uppy:border-dashed uppy:border-gray-300", "uppy:rounded-lg uppy:p-6 uppy:bg-gray-50", "uppy:transition-colors uppy:duration-200", {
    "uppy:cursor-pointer uppy:hover:bg-blue-50": !noClick
  }), children: [u("div", { className: "uppy:flex uppy:flex-col uppy:items-center uppy:justify-center uppy:h-full uppy:space-y-3", children: u("p", { className: "uppy:text-gray-600", children: "Drop files here or click to add them" }) }), note ? u("div", { className: "uppy:text-sm uppy:text-gray-500", children: note }) : null] })] });
}

// node_modules/pretty-bytes/index.js
var BYTE_UNITS = [
  "B",
  "kB",
  "MB",
  "GB",
  "TB",
  "PB",
  "EB",
  "ZB",
  "YB"
];
var BIBYTE_UNITS = [
  "B",
  "KiB",
  "MiB",
  "GiB",
  "TiB",
  "PiB",
  "EiB",
  "ZiB",
  "YiB"
];
var BIT_UNITS = [
  "b",
  "kbit",
  "Mbit",
  "Gbit",
  "Tbit",
  "Pbit",
  "Ebit",
  "Zbit",
  "Ybit"
];
var BIBIT_UNITS = [
  "b",
  "kibit",
  "Mibit",
  "Gibit",
  "Tibit",
  "Pibit",
  "Eibit",
  "Zibit",
  "Yibit"
];
var toLocaleString = (number, locale, options) => {
  let result = number;
  if (typeof locale === "string" || Array.isArray(locale)) {
    result = number.toLocaleString(locale, options);
  } else if (locale === true || options !== void 0) {
    result = number.toLocaleString(void 0, options);
  }
  return result;
};
function prettyBytes(number, options) {
  if (!Number.isFinite(number)) {
    throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
  }
  options = {
    bits: false,
    binary: false,
    space: true,
    ...options
  };
  const UNITS = options.bits ? options.binary ? BIBIT_UNITS : BIT_UNITS : options.binary ? BIBYTE_UNITS : BYTE_UNITS;
  const separator2 = options.space ? " " : "";
  if (options.signed && number === 0) {
    return ` 0${separator2}${UNITS[0]}`;
  }
  const isNegative = number < 0;
  const prefix = isNegative ? "-" : options.signed ? "+" : "";
  if (isNegative) {
    number = -number;
  }
  let localeOptions;
  if (options.minimumFractionDigits !== void 0) {
    localeOptions = { minimumFractionDigits: options.minimumFractionDigits };
  }
  if (options.maximumFractionDigits !== void 0) {
    localeOptions = { maximumFractionDigits: options.maximumFractionDigits, ...localeOptions };
  }
  if (number < 1) {
    const numberString2 = toLocaleString(number, options.locale, localeOptions);
    return prefix + numberString2 + separator2 + UNITS[0];
  }
  const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
  number /= (options.binary ? 1024 : 1e3) ** exponent;
  if (!localeOptions) {
    number = number.toPrecision(3);
  }
  const numberString = toLocaleString(Number(number), options.locale, localeOptions);
  const unit = UNITS[exponent];
  return prefix + numberString + separator2 + unit;
}

// node_modules/@uppy/components/lib/FilesGrid.js
function FilesGrid(props) {
  const [files, setFiles] = d(() => []);
  const { ctx, editFile } = props;
  function gridColsClass() {
    return {
      1: "uppy:grid-cols-1",
      2: "uppy:grid-cols-2",
      3: "uppy:grid-cols-3",
      4: "uppy:grid-cols-4",
      5: "uppy:grid-cols-5",
      6: "uppy:grid-cols-6"
    }[props.columns || 2] || "uppy:grid-cols-2";
  }
  y(() => {
    var _a;
    const onStateUpdate = (prev, next, patch) => {
      if (patch == null ? void 0 : patch.files) {
        setFiles(Object.values(patch.files));
      }
    };
    (_a = ctx.uppy) == null ? void 0 : _a.on("state-update", onStateUpdate);
    return () => {
      var _a2;
      (_a2 = ctx.uppy) == null ? void 0 : _a2.off("state-update", onStateUpdate);
    };
  }, [ctx.uppy]);
  return u("div", { "data-uppy-element": "files-grid", className: clsx("uppy:reset uppy:my-4 uppy:grid uppy:gap-4", gridColsClass()), children: files == null ? void 0 : files.map((file) => u("div", { className: "uppy:flex uppy:flex-col uppy:items-center uppy:gap-2", children: u(k, { children: [u(Thumbnail, { images: true, file }), u("div", { className: "uppy:w-full uppy-reset", children: [u("p", { className: "uppy:font-medium uppy:truncate", title: file.name, children: file.name }), u("div", { className: "uppy:flex uppy:items-center uppy:gap-2", children: [u("p", { className: " uppy:text-gray-500 uppy:tabular-nums ", children: prettyBytes(file.size || 0) }), editFile && u("button", { type: "button", className: "uppy:flex uppy:rounded uppy:text-blue-500 uppy:hover:text-blue-700 uppy:bg-transparent uppy:transition-colors", onClick: () => {
    editFile(file);
  }, children: "edit" }), u("button", { type: "button", className: "uppy:flex uppy:rounded uppy:text-blue-500 uppy:hover:text-blue-700 uppy:bg-transparent uppy:transition-colors", onClick: () => {
    var _a;
    (_a = ctx.uppy) == null ? void 0 : _a.removeFile(file.id);
  }, children: "remove" })] })] })] }) }, file.id)) });
}

// node_modules/@uppy/components/lib/FilesList.js
function FilesList(props) {
  const [files, setFiles] = d(() => []);
  const { ctx, editFile } = props;
  y(() => {
    var _a;
    const onStateUpdate = (prev, next, patch) => {
      if (patch == null ? void 0 : patch.files) {
        setFiles(Object.values(patch.files));
      }
    };
    (_a = ctx.uppy) == null ? void 0 : _a.on("state-update", onStateUpdate);
    return () => {
      var _a2;
      (_a2 = ctx.uppy) == null ? void 0 : _a2.off("state-update", onStateUpdate);
    };
  }, [ctx.uppy]);
  return u("ul", { "data-uppy-element": "files-list", className: "uppy-reset uppy:my-4", children: files == null ? void 0 : files.map((file) => {
    var _a, _b, _c;
    return u("li", { children: u(k, { children: [u("div", { className: "uppy:flex uppy:items-center uppy:gap-2", children: [u("div", { className: "uppy:w-[32px] uppy:h-[32px]", children: u(Thumbnail, { width: "32px", height: "32px", file }) }), u("p", { className: "uppy:truncate", children: file.name }), u("p", { className: "uppy:text-gray-500 uppy:tabular-nums uppy:min-w-18 uppy:text-right uppy:ml-auto", children: prettyBytes(file.size || 0) }), u(k, { children: [editFile && u("button", { type: "button", className: "uppy:flex uppy:rounded uppy:text-blue-500 uppy:hover:text-blue-700 uppy:bg-transparent uppy:transition-colors", onClick: () => {
      editFile(file);
    }, children: "edit" }), u("button", { type: "button", className: "uppy:flex uppy:rounded uppy:text-blue-500 uppy:hover:text-blue-700 uppy:bg-transparent uppy:transition-colors", onClick: () => {
      var _a2;
      (_a2 = ctx.uppy) == null ? void 0 : _a2.removeFile(file.id);
    }, children: "remove" })] })] }), u("progress", { max: "100", className: clsx("uppy:w-full uppy:h-[2px] uppy:appearance-none uppy:bg-gray-100 uppy:rounded-full uppy:overflow-hidden uppy:[&::-webkit-progress-bar]:bg-gray-100 uppy:block uppy:my-2", {
      "uppy:[&::-webkit-progress-value]:bg-green-500 uppy:[&::-moz-progress-bar]:bg-green-500": (_a = file.progress) == null ? void 0 : _a.uploadComplete,
      "uppy:[&::-webkit-progress-value]:bg-red-500 uppy:[&::-moz-progress-bar]:bg-red-500": file.error,
      "uppy:[&::-webkit-progress-value]:bg-blue-500 uppy:[&::-moz-progress-bar]:bg-blue-500": !((_b = file.progress) == null ? void 0 : _b.uploadComplete) && !file.error
    }), value: ((_c = file.progress) == null ? void 0 : _c.percentage) || 0 })] }) }, file.id);
  }) });
}

// node_modules/@uppy/components/lib/hooks/file-input.js
var fileInputId2 = "uppy-file-input";
function createFileInput(ctx, props = {}) {
  const handleClick = () => {
    const input = document.getElementById(fileInputId2);
    input == null ? void 0 : input.click();
  };
  const handleFileInputChange = (event) => {
    const input = event.target;
    const files = Array.from(input.files || []);
    if (!files.length)
      return;
    ctx.uppy.addFiles(files.map((file) => ({
      name: file.name,
      type: file.type,
      data: file
    })));
    input.value = "";
  };
  return {
    getInputProps: () => ({
      id: fileInputId2,
      type: "file",
      multiple: props.multiple ?? true,
      accept: props.accept,
      onChange: handleFileInputChange
    }),
    getButtonProps: () => ({
      type: "button",
      onClick: handleClick
    })
  };
}

// node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@uppy/components/lib/hooks/utils.js
var Subscribers = class {
  constructor() {
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "add", (listener) => {
      this.subscribers.add(listener);
      return () => this.subscribers.delete(listener);
    });
    __publicField(this, "emit", () => {
      for (const listener of this.subscribers) {
        listener();
      }
    });
    __publicField(this, "clear", () => {
      this.subscribers.clear();
    });
  }
};

// node_modules/@uppy/components/lib/hooks/remote-source.js
function createRemoteSourceController(uppy, sourceId) {
  const plugin = uppy.getPlugin(sourceId);
  if (!plugin) {
    throw new Error(`(${sourceId}) is not installed. Install the plugin or the preset @uppy/remote-sources and add it to the Uppy instance`);
  }
  const subscribers = new Subscribers();
  const view = plugin.view;
  let didFirstRender = false;
  const onStateUpdate = (prev, next, patch) => {
    var _a;
    if ((_a = patch == null ? void 0 : patch.plugins) == null ? void 0 : _a[sourceId]) {
      subscribers.emit();
    }
  };
  let cachedSnapshot = {
    state: {
      ...plugin.getPluginState(),
      // By default the partialTree is an array of all folders you have opened at some point,
      // not the contents of the current folder. We filter it here to make it more intuitive to work with.
      partialTree: view.getDisplayedPartialTree(),
      selectedAmount: view.getSelectedAmount(),
      error: view.validateAggregateRestrictions(plugin.getPluginState().partialTree),
      breadcrumbs: view.getBreadcrumbs()
    },
    login: view == null ? void 0 : view.handleAuth,
    logout: view == null ? void 0 : view.logout,
    open: view == null ? void 0 : view.openFolder,
    checkbox: view == null ? void 0 : view.toggleCheckbox,
    done: view == null ? void 0 : view.donePicking,
    cancel: view == null ? void 0 : view.cancelSelection
  };
  const getSnapshot = () => {
    const nextSnapshot = {
      ...cachedSnapshot,
      state: {
        ...plugin.getPluginState(),
        partialTree: view.getDisplayedPartialTree(),
        selectedAmount: view.getSelectedAmount(),
        error: view.validateAggregateRestrictions(plugin.getPluginState().partialTree),
        breadcrumbs: view.getBreadcrumbs()
      }
    };
    if (!dequal(cachedSnapshot.state, nextSnapshot.state)) {
      cachedSnapshot = nextSnapshot;
    }
    return cachedSnapshot;
  };
  const mount = () => {
    var _a, _b, _c;
    uppy.on("state-update", onStateUpdate);
    if (!didFirstRender) {
      (_a = view.openFolder) == null ? void 0 : _a.call(view, plugin.rootFolderId);
      (_c = (_b = view.provider).fetchPreAuthToken) == null ? void 0 : _c.call(_b);
      didFirstRender = true;
    }
  };
  const unmount = () => {
    didFirstRender = false;
    uppy.off("state-update", onStateUpdate);
  };
  return {
    mount,
    unmount,
    subscribe: subscribers.add,
    getSnapshot
  };
}

// node_modules/@uppy/components/lib/hooks/screencapture.js
var videoId = "uppy-screencapture-video";
var Subscribers2 = class {
  constructor() {
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "add", (listener) => {
      this.subscribers.add(listener);
      return () => this.subscribers.delete(listener);
    });
    __publicField(this, "emit", () => {
      for (const listener of this.subscribers) {
        listener();
      }
    });
    __publicField(this, "clear", () => {
      this.subscribers.clear();
    });
  }
};
function createScreenCaptureController(uppy, onSubmit) {
  const plugin = uppy.getPlugin("ScreenCapture");
  if (!plugin) {
    throw new Error("ScreenCapture plugin is not installed. Install @uppy/screen-capture and add it to the Uppy instance with `uppy.use(ScreenCapture)`.");
  }
  const subscribers = new Subscribers2();
  const onStateUpdate = (prev, next, patch) => {
    var _a;
    const screenCapturePatch = (_a = patch == null ? void 0 : patch.plugins) == null ? void 0 : _a.ScreenCapture;
    if (screenCapturePatch) {
      subscribers.emit();
    }
  };
  const stop = () => {
    uppy.off("state-update", onStateUpdate);
    plugin.stop();
  };
  const start = () => {
    uppy.on("state-update", onStateUpdate);
    plugin.start();
  };
  const getVideoProps = () => {
    const ref = document.getElementById(videoId);
    const { status, recordedVideo, capturedScreenshotUrl } = plugin.getPluginState();
    if (status === "captured" && recordedVideo) {
      if (ref) {
        ref.srcObject = null;
      }
      return {
        id: videoId,
        playsInline: true,
        controls: true,
        muted: false,
        src: recordedVideo,
        autoPlay: void 0
      };
    }
    if (status === "captured" && capturedScreenshotUrl) {
      if (ref) {
        ref.srcObject = null;
      }
      return {
        id: videoId,
        playsInline: true,
        controls: false,
        muted: false,
        poster: capturedScreenshotUrl,
        autoPlay: void 0
      };
    }
    if (ref && plugin.videoStream && !(capturedScreenshotUrl || recordedVideo)) {
      ref.srcObject = plugin.videoStream;
    }
    return {
      id: videoId,
      playsInline: true,
      autoPlay: true,
      muted: true,
      controls: void 0
    };
  };
  const getScreenshotButtonProps = () => {
    const { status } = plugin.getPluginState();
    return {
      type: "button",
      onClick: async () => {
        await plugin.captureScreenshot();
      },
      disabled: status !== "ready"
    };
  };
  const getRecordButtonProps = () => {
    const { status } = plugin.getPluginState();
    return {
      type: "button",
      onClick: () => {
        plugin.startRecording();
      },
      disabled: status !== "ready"
    };
  };
  const getStopRecordingButtonProps = () => {
    const { status } = plugin.getPluginState();
    return {
      type: "button",
      onClick: () => {
        plugin.stopRecording();
      },
      disabled: status !== "recording"
    };
  };
  const getSubmitButtonProps = () => {
    const { status } = plugin.getPluginState();
    return {
      type: "button",
      onClick: () => {
        plugin.submit();
        plugin.stop();
        onSubmit == null ? void 0 : onSubmit();
      },
      disabled: !(status === "captured")
    };
  };
  const getDiscardButtonProps = () => {
    const { status } = plugin.getPluginState();
    return {
      type: "button",
      onClick: () => {
        plugin.discardRecordedMedia();
      },
      disabled: !(status === "captured")
    };
  };
  const getSnapshot = () => ({
    state: plugin.getPluginState(),
    stop,
    start,
    getVideoProps,
    getScreenshotButtonProps,
    getRecordButtonProps,
    getStopRecordingButtonProps,
    getSubmitButtonProps,
    getDiscardButtonProps
  });
  let cachedSnapshot = getSnapshot();
  const getCachedSnapshot = () => {
    const nextSnapshot = getSnapshot();
    if (nextSnapshot.state === cachedSnapshot.state)
      return cachedSnapshot;
    cachedSnapshot = nextSnapshot;
    return cachedSnapshot;
  };
  return { subscribe: subscribers.add, getSnapshot: getCachedSnapshot };
}

// node_modules/@uppy/components/lib/hooks/webcam.js
var videoId2 = "uppy-webcam-video";
function createWebcamController(uppy, onSubmit) {
  const plugin = uppy.getPlugin("Webcam");
  if (!plugin) {
    throw new Error("Webcam plugin is not installed. Install @uppy/webcam and add it to the Uppy instance with `uppy.use(Webcam)`.");
  }
  const subscribers = new Subscribers();
  const onStateUpdate = (prev, next, patch) => {
    var _a;
    const webcamPatch = (_a = patch == null ? void 0 : patch.plugins) == null ? void 0 : _a.Webcam;
    if (webcamPatch) {
      subscribers.emit();
    }
  };
  const stop = () => {
    uppy.off("state-update", onStateUpdate);
    if (plugin.webcamActive || plugin.getPluginState().isRecording) {
      plugin.stop();
    }
  };
  const start = () => {
    uppy.on("state-update", onStateUpdate);
    plugin.start();
  };
  const getVideoProps = () => {
    const ref = document.getElementById(videoId2);
    plugin.getVideoElement = () => ref;
    const { recordedVideo, capturedSnapshot } = plugin.getPluginState();
    const status = plugin.getStatus();
    if (status === "captured" && recordedVideo) {
      if (ref) {
        ref.srcObject = null;
      }
      return {
        id: videoId2,
        "data-uppy-mirrored": false,
        playsInline: true,
        controls: true,
        muted: false,
        src: recordedVideo,
        autoPlay: void 0
      };
    }
    if (status === "captured" && capturedSnapshot) {
      if (ref) {
        ref.srcObject = null;
      }
      return {
        id: videoId2,
        "data-uppy-mirrored": false,
        playsInline: true,
        controls: false,
        muted: true,
        poster: capturedSnapshot,
        autoPlay: void 0
      };
    }
    if (ref && plugin.stream && !(capturedSnapshot || recordedVideo)) {
      ref.srcObject = plugin.stream;
    }
    return {
      id: videoId2,
      "data-uppy-mirrored": true,
      playsInline: true,
      autoPlay: true,
      muted: true,
      controls: void 0
    };
  };
  const getSnapshotButtonProps = () => ({
    type: "button",
    onClick: async () => {
      await plugin.takeSnapshot();
    },
    disabled: plugin.getStatus() !== "ready" || plugin.getPluginState().isRecording
  });
  const getRecordButtonProps = () => ({
    type: "button",
    onClick: () => {
      plugin.startRecording();
    },
    disabled: plugin.getStatus() !== "ready" || plugin.getPluginState().isRecording
  });
  const getStopRecordingButtonProps = () => ({
    type: "button",
    onClick: () => {
      plugin.stopRecording();
    },
    disabled: plugin.getStatus() !== "recording"
  });
  const getSubmitButtonProps = () => ({
    type: "button",
    onClick: () => {
      plugin.submit();
      plugin.stop();
      onSubmit == null ? void 0 : onSubmit();
    },
    disabled: plugin.getStatus() !== "captured"
  });
  const getDiscardButtonProps = () => ({
    type: "button",
    onClick: () => {
      plugin.discardRecordedMedia();
    },
    disabled: plugin.getStatus() !== "captured"
  });
  const getSnapshot = () => ({
    state: plugin.getPluginState(),
    stop,
    start,
    getVideoProps,
    getSnapshotButtonProps,
    getRecordButtonProps,
    getStopRecordingButtonProps,
    getSubmitButtonProps,
    getDiscardButtonProps
  });
  let cachedSnapshot = getSnapshot();
  const getCachedSnapshot = () => {
    const nextSnapshot = getSnapshot();
    if (nextSnapshot.state === cachedSnapshot.state)
      return cachedSnapshot;
    cachedSnapshot = nextSnapshot;
    return cachedSnapshot;
  };
  return { subscribe: subscribers.add, getSnapshot: getCachedSnapshot };
}

// node_modules/@uppy/components/lib/ProviderIcon.js
function ProviderIcon(props) {
  switch (props.provider) {
    case "device":
      return u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { d: "M8.45 22.087l-1.305-6.674h17.678l-1.572 6.674H8.45zm4.975-12.412l1.083 1.765a.823.823 0 00.715.386h7.951V13.5H8.587V9.675h4.838zM26.043 13.5h-1.195v-2.598c0-.463-.336-.75-.798-.75h-8.356l-1.082-1.766A.823.823 0 0013.897 8H7.728c-.462 0-.815.256-.815.718V13.5h-.956a.97.97 0 00-.746.37.972.972 0 00-.19.81l1.724 8.565c.095.44.484.755.933.755H24c.44 0 .824-.3.929-.727l2.043-8.568a.972.972 0 00-.176-.825.967.967 0 00-.753-.38z", "fill-rule": "evenodd", fill: props.fill || "currentcolor" }) });
    case "camera":
      return u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", "fill-rule": "nonzero", fill: props.fill || "#02B383" }) });
    case "screen-capture":
      return u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", children: u("g", { fill: "currentcolor", "fill-rule": "evenodd", children: [u("path", { d: "M24.182 9H7.818C6.81 9 6 9.742 6 10.667v10c0 .916.81 1.666 1.818 1.666h4.546V24h7.272v-1.667h4.546c1 0 1.809-.75 1.809-1.666l.009-10C26 9.742 25.182 9 24.182 9zM24 21H8V11h16v10z" }), u("circle", { cx: "16", cy: "16", r: "2" })] }) });
    case "audio":
      return u("svg", { "aria-hidden": "true", width: "32px", height: "32px", viewBox: "0 0 32 32", children: u("path", { d: "M21.143 12.297c.473 0 .857.383.857.857v2.572c0 3.016-2.24 5.513-5.143 5.931v2.64h2.572a.857.857 0 110 1.714H12.57a.857.857 0 110-1.714h2.572v-2.64C12.24 21.24 10 18.742 10 15.726v-2.572a.857.857 0 111.714 0v2.572A4.29 4.29 0 0016 20.01a4.29 4.29 0 004.286-4.285v-2.572c0-.474.384-.857.857-.857zM16 6.5a3 3 0 013 3v6a3 3 0 01-6 0v-6a3 3 0 013-3z", fill: "currentcolor", "fill-rule": "nonzero" }) });
    case "dropbox":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("path", { d: "M10.5 7.5L5 10.955l5.5 3.454 5.5-3.454 5.5 3.454 5.5-3.454L21.5 7.5 16 10.955zM10.5 21.319L5 17.864l5.5-3.455 5.5 3.455zM16 17.864l5.5-3.455 5.5 3.455-5.5 3.455zM16 25.925l-5.5-3.455 5.5-3.454 5.5 3.454z", fill: props.fill || "currentcolor", fillRule: "nonzero" }) });
    case "facebook":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("g", { fill: "none", fillRule: "evenodd", children: [u("path", { d: "M27 16c0-6.075-4.925-11-11-11S5 9.925 5 16c0 5.49 4.023 10.041 9.281 10.866V19.18h-2.793V16h2.793v-2.423c0-2.757 1.642-4.28 4.155-4.28 1.204 0 2.462.215 2.462.215v2.707h-1.387c-1.366 0-1.792.848-1.792 1.718V16h3.05l-.487 3.18h-2.563v7.686C22.977 26.041 27 21.49 27 16", fill: "#1777F2" }), u("path", { d: "M20.282 19.18L20.77 16h-3.051v-2.063c0-.87.426-1.718 1.792-1.718h1.387V9.512s-1.258-.215-2.462-.215c-2.513 0-4.155 1.523-4.155 4.28V16h-2.793v3.18h2.793v7.686a11.082 11.082 0 003.438 0V19.18h2.563", fill: "#FFFFFE" })] }) });
    case "instagram":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: [u("defs", { children: u("path", { d: "M16.825 5l.483-.001.799.002c1.168.005 1.598.021 2.407.057 1.17.05 1.97.235 2.67.506.725.28 1.34.655 1.951 1.265.613.61.99 1.223 1.273 1.946.273.7.46 1.498.516 2.67l.025.552.008.205c.029.748.037 1.51.042 3.777l.001.846v.703l-.001.398a50.82 50.82 0 01-.058 2.588c-.05 1.17-.235 1.97-.506 2.67a5.394 5.394 0 01-1.265 1.951c-.61.613-1.222.99-1.946 1.273-.699.273-1.498.46-2.668.516-.243.012-.451.022-.656.03l-.204.007c-.719.026-1.512.034-3.676.038l-.847.001h-1.1a50.279 50.279 0 01-2.587-.059c-1.171-.05-1.971-.235-2.671-.506a5.394 5.394 0 01-1.951-1.265 5.385 5.385 0 01-1.272-1.946c-.274-.699-.46-1.498-.517-2.668a88.15 88.15 0 01-.03-.656l-.007-.205c-.026-.718-.034-1.512-.038-3.674v-2.129c.006-1.168.022-1.597.058-2.406.051-1.171.235-1.971.506-2.672a5.39 5.39 0 011.265-1.95 5.381 5.381 0 011.946-1.272c.699-.274 1.498-.462 2.669-.517l.656-.03.204-.007c.718-.026 1.511-.034 3.674-.038zm.678 1.981h-1.226l-.295.001c-2.307.005-3.016.013-3.777.043l-.21.009-.457.02c-1.072.052-1.654.232-2.042.383-.513.2-.879.44-1.263.825a3.413 3.413 0 00-.82 1.267c-.15.388-.33.97-.375 2.043a48.89 48.89 0 00-.056 2.482v.398 1.565c.006 2.937.018 3.285.073 4.444.05 1.073.231 1.654.382 2.043.2.512.44.878.825 1.263.386.383.753.621 1.267.82.388.15.97.328 2.043.374.207.01.388.017.563.024l.208.007a63.28 63.28 0 002.109.026h1.564c2.938-.006 3.286-.019 4.446-.073 1.071-.051 1.654-.232 2.04-.383.514-.2.88-.44 1.264-.825.384-.386.622-.753.82-1.266.15-.389.328-.971.375-2.044.039-.88.054-1.292.057-2.723v-1.15-.572c-.006-2.936-.019-3.284-.074-4.445-.05-1.071-.23-1.654-.382-2.04-.2-.515-.44-.88-.825-1.264a3.405 3.405 0 00-1.267-.82c-.388-.15-.97-.328-2.042-.375a48.987 48.987 0 00-2.535-.056zm-1.515 3.37a5.65 5.65 0 11.021 11.299 5.65 5.65 0 01-.02-11.3zm.004 1.982a3.667 3.667 0 10.015 7.334 3.667 3.667 0 00-.015-7.334zm5.865-3.536a1.32 1.32 0 11.005 2.64 1.32 1.32 0 01-.005-2.64z", id: "a" }) }), u("g", { fill: "none", "fill-rule": "evenodd", children: [u("mask", { id: "b", fill: "#fff", children: u("use", { xlinkHref: "#a" }) }), u("image", { mask: "url(#b)", x: "4", y: "4", width: "24", height: "24", xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAALKADAAQAAAABAAAALAAAAAD8buejAAALZklEQVRYCVWZC2LbNhAFCRKykvP0bD1506SxRKIzbwHJoU3jv5h9WICU3P7+6zlG2zZvr8s/rW1tN7U0rMll8aDYufdzbLfc1JHmpv3jpPy8tsO+3O2s/O6YMSjTl/qdCds4mIIG60m8vdq2Z+phm2V4vAb9+o7BbZeuoM0NyYazvTvbvlN1MGjHUAesZ/IWWOsCeF0BOwAK4ITR0WYd/QKHEPv2DEymmorZtiubjOHEMYEzXmC9GMxu+95Kz+kuwxjDBKb8iUoCAdqZoAeyALreW6ZNx9Y4Jz8cLwjTZOEoR+HU05k2RzgP2iafGgfZiEdZbEr94zpX/xkPtDtGAxF+LRcgTsp9CAZg0rnEnXmPqFshY5vLnVWxLXO/bah2sZQgBZppGSe8NbjNPN5kc/WbIYEn8U+jXCOezT4zfgS1eoVEhceVeK74Fe4N6CoYEoLWykzHsd+GMAUqdTTVvvqT1uWqB3lVCLb12/ORAe8/5Zu9mp7lqoEFUCAFDIxqz7i1bq2AY1U9jqq2QK/7DYl+1AeZlAFcEc+U/jkRUqsvCHQ/nyGvjrOl6EuZWRWVGCKUMCkntQ5o+u2AZ3OxakbTcoBZnY0xhgGCUM4Kp1xtBTnBnXM5ASRms/Fs7d9OpX8bXN45pibQY/ML1MmA5G9CINBuCpdftexr6i2c5qd9J441LNJm3zk1GVusJ7v6mPJ7HPxJR0Li/vg9O1XHTEgvsQoSgExU0NnlLF0paK+6d06aOMKE2nCKV0ofNw4WsWmLsWrv6lPLnhGpr9E137QkHOMB/jh/T8MOqOadXarR44zPBW5NvDccnBxVmdK81+7RQ5p6qnQoRDZPh9+xWj0N2XpqxX1HzMty9UlFnKya/h3gulziAsyxwkSmpTIPB8vagKLyktRdDuBEHNGZMm4oCFWgjq31WPHpaC93gGNqpOpP4Ez4spa+nMNvhTWcuPKAJ79fqIxVoUvdjEG9qSy2WhpQlz61yG/gnKEA25IrIOYK6DIsQs2EE9LR/sTKq38Nd1y/X//FXG0QDHkEqSz3EYVV2dhb00rgLPSDcqmrScs55NNOD2zVqKmYnYTFnkACp520dkW5vBxK99BVzr792/iZ+VVo92UkKU2oG5WFTb6mNiA1H2C8KC0E44qaQleR3EQvQNwLrECOVAiSwM5gpF7nvDND0lZvYuQ9JbZfqdTrqCgwMcVrRS0z9QkLu9NWmkgEHb8p2zDRylj9VWA3lXD2vObEdWpT3w5MiFqQ1W/lteG4eipastxv2w+TeTBP0ypK84HiOW9fUzLcjRDwCW2b2VxmnGSKTX6uRSwMnC9YX4l05Mh2uwI+QVWdWUOSTWd5Xjjf7/tPYk2stSh053XTGN5RJMCMSajMcS8Trn3j/E1ajthlxCkmJXVi47PSUsyyq+jyexsayQNuv5GVYJaszprNsQD3RkgYiy49kFl2JlJJxlf8Uu/lpkq7+aWqzEzjr5cTVpFaJvSVr8AKRtiTlVPFk5t1nO30W+o6jrbAk76kxFa/tX+dom4C1wDPk03gqCw8HTBSxx4FHxIA+mh2pM3rKu5SNqBAuOSZnHzsB9JwW7DV/ge8dlVsOh375PvH8YO8EALU1HuecIC6qQgXifNuSx9XAoLaoGIYDjkWFrawX1U1XrknuMFw7QBSPtg79XovmBvwqnDICrhClEO6wgKFj9vPqJWlthUvdgH1DOA8+wFMexzQc5BUS1d1IsdBSjEv4Fe1LgBO1CpFPTpV1JuPSFNt4y/trzbtaUfwBWwM3/6JsrL6MSQYwLKXAm9YJBxsM8992MblZ63Gami0+rnwOMyPykVpQsyl9eYNOfVC6kRBkwaop//LgcAKWivkHF791g0JK5kMmCgKPas2QRkUFQsuTvm6R1946Wg95k764ZRLW59yO5UVGsawwELupCfAbdCuAwvcz5Xk18rIVEdgSRBRgO77R206QdXHuA2goaGiCQ0GmUfN1JlmFayjv0IcKGkfYt4HAj0yuQBRGDjzuS/rTmAf29Gov1S+FF7QBayNcpoBOEsMt3vFcIUC7VxOnE+pxmkgqEzduzwsPykrjBszCusgdarsRIAL6CM/KqsqcAf1vj8P1TXFyN6e5G8ao48fjKfDQJYizIdIfb+Xwp6Z2fE2C7mUfUEzMKqSBp4VUV1A49Sz1M2LzVzahEfyHUAcQNltR0nADYkBvHXDZQo8H9dQvHF7qhjPtSolBJ0A/vaLwdRz5YFFGoWBy8E/4aKcjqimaUBXXnjBpzOZnMlIVXsTVEBBUa+dD0BR0xVopgAD70psY0KjMHpmHB2kApea9o23NS83mpsref5OZet4U/0CMhSEDpwnxB9lVKSfk5djllXRFPizQmKcqMpnyZ3ycPntf96Ym9ChzU8vCQnhgWZ2UuySArw+cVBG4gqNCS6YoSEEziRWVStKUpe4FfCd91V0XA/qgOJuF7FpGjjyQgsFoNDtibp8cm+cyXxbB6zh4pMUO4H06yzsv4E/A6rg/uRJRnMRmrhMDIhyOjABX9CMDFhBFxx19KujjqWeim5PwVFU6IBiewfyk7IPETcg52kjXN7nsbaoEykKf/cjUgVxpTZZVtnqFMgv4FHa8oSOisawinMLHfUBzJcK1j8BeqquedKDtgcgnA4bym4P6gBWYVM3W/pn41ku5L4RElFWtlk5SXHEThhOWDiIyVROlQNM+wyHimlgATI/PPIm4BB8qfqwHnhgL89gzs+Ww1xQb4821SZ/4IwOJiRqH/X9u7Hj08JLSZfawOQcpRzwgk1oBNzzcgLn1FBNHspMENik9OG4awIDaUjw9rKNT1KXPl9neua6sSbkgqfs/CNfBdNfDDhQuL4AKXEXeOgZID91eOiRUnEFOIA5rnTkBU0/IT05gByoq5KBJF4Hym4Pxh3UcxZ7HjdhEhKWURbhavNR9rjLBwk3ryDcrGzfvk9I69b1yhMGWQ4bqMwv/RMSplQkjjVKXzZX8wESVcuB7QG0YUCMjk/aOmWgc/vC4oMCVYfghIGP6MT1zpeUhM1rQzOnGxmFKwTCir1Xaj5vN7T7nDZvnbDGHbCKnwji2zofNsOvbold3zlUtKGosBun3PbJSrrReHEaCQVCIDEMaCCBs+P+AbybkbIhmbNecGwF+E5/L2ECuPKCWsUESQkKnyyJ93TGACk7OrAY9P8XG//fGCoM7DAEUGnj5Mw7aQfelySWOm9iPuFyvrL8rKQR6mM6qdCUDQsfNPVu4yv/HaPOT1e/yDaviMKmTkg/I/F7MUG9OlrmDrBLRVd3c8KBJlPEKoVRcIJuhoQAmZDUkPC00W5OI1dOpQ1F61kFNqr9SmFcaHdBheOaDHF6QZMOP6QyiZ804oj98wLiAMIgcWw4UDYkDAWfR+4d5s0zP2GgUZX04i+NeSgYGokvbDhIZYUWHgd9K8zZzir264NxZUFbsfM1jdqpV2naA48tx6hsvBSabE4IMtlcOGgq8PqCjoly2rw2soqy4RJWQtPZl6PUCU14ZUWENuZV2Honn3f+k6R6wrkqgTStyQ0bFY+XAaafMRFgUlVeXxXFUcpLEYfZz3FrVUzZrOOJK+4B/wnIZ8TGRvb9OB8EUM0w8uNYj/oa9iK9AMoy6gA72o02srMxpAPUD+EDnVEF7P5xw896VyAbFk8MgnpVpR3gfLnt/wECq3rYFvYLcKCpqvcI+/hVl8AumXDeApklDRRKJSS+KOaq1Rgg4igOYtiQK1hJy46TBtDjznDp3iqJff5j0/LfSZbYVdauqXccJ9W+czupp0sU9gMlqkQ52lU1E6tUwoDUukAD6YRpAwqDrAErzA8QCRvXm98KEep0xIdY1CN1ye27IP0IHvvYIW18qGz8S7VWUZuMkUOb3P8DHTl67ur/i1UAAAAASUVORK5CYII=" })] })] });
    case "onedrive":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("g", { fill: "none", fillRule: "nonzero", children: [u("path", { d: "M13.39 12.888l4.618 2.747 2.752-1.15a4.478 4.478 0 012.073-.352 6.858 6.858 0 00-5.527-5.04 6.895 6.895 0 00-6.876 2.982l.07-.002a5.5 5.5 0 012.89.815z", fill: "#0364B8" }), u("path", { d: "M13.39 12.887v.001a5.5 5.5 0 00-2.89-.815l-.07.002a5.502 5.502 0 00-4.822 2.964 5.43 5.43 0 00.38 5.62l4.073-1.702 1.81-.757 4.032-1.685 2.105-.88-4.619-2.748z", fill: "#0078D4" }), u("path", { d: "M22.833 14.133a4.479 4.479 0 00-2.073.352l-2.752 1.15.798.475 2.616 1.556 1.141.68 3.902 2.321a4.413 4.413 0 00-.022-4.25 4.471 4.471 0 00-3.61-2.284z", fill: "#1490DF" }), u("path", { d: "M22.563 18.346l-1.141-.68-2.616-1.556-.798-.475-2.105.88L11.87 18.2l-1.81.757-4.073 1.702A5.503 5.503 0 0010.5 23h12.031a4.472 4.472 0 003.934-2.333l-3.902-2.321z", fill: "#28A8EA" })] }) });
    case "googlephotos":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "-7 -7 73 73", children: u("g", { fill: "none", fillRule: "evenodd", children: [u("path", { d: "M-3-3h64v64H-3z" }), u("g", { fillRule: "nonzero", children: [u("path", { fill: "#FBBC04", d: "M14.8 13.4c8.1 0 14.7 6.6 14.7 14.8v1.3H1.3c-.7 0-1.3-.6-1.3-1.3C0 20 6.6 13.4 14.8 13.4z" }), u("path", { fill: "#EA4335", d: "M45.6 14.8c0 8.1-6.6 14.7-14.8 14.7h-1.3V1.3c0-.7.6-1.3 1.3-1.3C39 0 45.6 6.6 45.6 14.8z" }), u("path", { fill: "#4285F4", d: "M44.3 45.6c-8.2 0-14.8-6.6-14.8-14.8v-1.3h28.2c.7 0 1.3.6 1.3 1.3 0 8.2-6.6 14.8-14.8 14.8z" }), u("path", { fill: "#34A853", d: "M13.4 44.3c0-8.2 6.6-14.8 14.8-14.8h1.3v28.2c0 .7-.6 1.3-1.3 1.3-8.2 0-14.8-6.6-14.8-14.8z" })] })] }) });
    case "googledrive":
      return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", children: u("g", { fillRule: "nonzero", fill: "none", children: [u("path", { d: "M6.663 22.284l.97 1.62c.202.34.492.609.832.804l3.465-5.798H5c0 .378.1.755.302 1.096l1.361 2.278z", fill: "#0066DA" }), u("path", { d: "M16 12.09l-3.465-5.798c-.34.195-.63.463-.832.804l-6.4 10.718A2.15 2.15 0 005 18.91h6.93L16 12.09z", fill: "#00AC47" }), u("path", { d: "M23.535 24.708c.34-.195.63-.463.832-.804l.403-.67 1.928-3.228c.201-.34.302-.718.302-1.096h-6.93l1.474 2.802 1.991 2.996z", fill: "#EA4335" }), u("path", { d: "M16 12.09l3.465-5.798A2.274 2.274 0 0018.331 6h-4.662c-.403 0-.794.11-1.134.292L16 12.09z", fill: "#00832D" }), u("path", { d: "M20.07 18.91h-8.14l-3.465 5.798c.34.195.73.292 1.134.292h12.802c.403 0 .794-.11 1.134-.292L20.07 18.91z", fill: "#2684FC" }), u("path", { d: "M23.497 12.455l-3.2-5.359a2.252 2.252 0 00-.832-.804L16 12.09l4.07 6.82h6.917c0-.377-.1-.755-.302-1.096l-3.188-5.359z", fill: "#FFBA00" })] }) });
    default:
      return null;
  }
}

// node_modules/@uppy/components/lib/Thumbnail.js
function Thumbnail(props) {
  var _a, _b;
  const width = props.width || "100%";
  const height = props.height || "100%";
  const fileTypeGeneral = ((_a = props.file.type) == null ? void 0 : _a.split("/")[0]) || "";
  const fileTypeSpecific = ((_b = props.file.type) == null ? void 0 : _b.split("/")[1]) || "";
  const isImage = props.file.type.startsWith("image/");
  const isArchive = fileTypeGeneral === "application" && [
    "zip",
    "x-7z-compressed",
    "x-zip-compressed",
    "x-rar-compressed",
    "x-tar",
    "x-gzip",
    "x-apple-diskimage"
  ].includes(fileTypeSpecific);
  const isPDF = fileTypeGeneral === "application" && fileTypeSpecific === "pdf";
  const objectUrl = T(() => {
    if (!props.images) {
      return "";
    }
    if (props.file.isRemote) {
      return props.file.preview;
    }
    return URL.createObjectURL(props.file.data);
  }, [props.file.data, props.images, props.file.isRemote, props.file.preview]);
  const showThumbnail = props.images && isImage && objectUrl;
  y(() => {
    return () => {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    };
  }, [objectUrl]);
  return u("div", { "data-uppy-element": "thumbnail", className: "uppy:relative uppy:overflow-hidden uppy:bg-gray-100 uppy:rounded-lg uppy:flex uppy:items-center uppy:justify-center", style: {
    width,
    height,
    aspectRatio: "1"
  }, children: [showThumbnail ? u("img", { className: "uppy:w-full uppy:h-full uppy:object-cover", src: objectUrl, alt: props.file.name }) : null, !showThumbnail ? u("div", { className: "uppy:flex uppy:flex-col uppy:items-center uppy:justify-center uppy:w-full uppy:h-full", children: u("div", { className: "uppy:flex-1 uppy:flex uppy:items-center uppy:justify-center uppy:w-full", children: [!props.file.type ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("g", { fill: "#A7AFB7", "fill-rule": "nonzero", children: [u("path", { d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z" }), u("path", { d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z" })] }) }) : null, fileTypeGeneral === "text" ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("path", { d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z", fill: "#5A5E69", "fill-rule": "nonzero" }) }) : null, fileTypeGeneral === "image" && !showThumbnail ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("g", { fill: "#686DE0", "fill-rule": "evenodd", children: [u("path", { d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z", "fill-rule": "nonzero" }), u("path", { d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z", "fill-rule": "nonzero" }), u("circle", { cx: "7.5", cy: "9.5", r: "1.5" })] }) }) : null, fileTypeGeneral === "audio" ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("path", { d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z", fill: "#049BCF", "fill-rule": "nonzero" }) }) : null, fileTypeGeneral === "video" ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("path", { d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z", fill: "#19AF67", "fill-rule": "nonzero" }) }) : null, isPDF ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("path", { d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z", fill: "#E2514A", "fill-rule": "nonzero" }) }) : null, isArchive ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("path", { d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z", fill: "#00C469", "fill-rule": "nonzero" }) }) : null, props.file.type && !fileTypeGeneral && !isPDF && !isArchive ? u("svg", { "aria-hidden": "true", className: "uppy:w-3/4 uppy:h-3/4", viewBox: "0 0 25 25", children: u("g", { fill: "#A7AFB7", "fill-rule": "nonzero", children: [u("path", { d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z" }), u("path", { d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z" })] }) }) : null] }) }) : null] });
}

// node_modules/@uppy/components/lib/UploadButton.js
function UploadButton(props) {
  var _a;
  const { ctx } = props;
  return u("div", { className: "uppy-reset uppy:space-y-2", children: [u("button", { type: "button", "data-uppy-element": "upload-button", "data-state": ctx.status, onClick: () => {
    var _a2;
    if (ctx.status === "ready") {
      (_a2 = ctx.uppy) == null ? void 0 : _a2.upload();
    }
  }, className: clsx("uppy:relative uppy:w-full uppy:p-2 uppy:rounded-lg", "uppy:text-white uppy:font-medium", "uppy:transition-all uppy:overflow-hidden", "uppy:bg-blue-500 uppy:hover:bg-blue-600", {
    "uppy:bg-red-500 uppy:hover:bg-red-600": ctx.status === "error",
    "uppy:bg-green-500 uppy:hover:bg-green-600": ctx.status === "complete"
  }, "uppy:disabled:hover:bg-blue-500 uppy:disabled:cursor-not-allowed"), disabled: ctx.status === "init" || ctx.status === "uploading" || ctx.status === "paused", children: [u("div", { className: clsx("uppy:absolute uppy:inset-0 uppy:origin-left uppy:transition-all", {
    "uppy:bg-red-700": ctx.status === "error",
    "uppy:bg-green-700": ctx.status === "complete",
    "uppy:bg-blue-700": ctx.status !== "error" && ctx.status !== "complete"
  }), style: {
    transform: `scaleX(${ctx.progress / 100})`
  } }), u("span", { className: "uppy:relative uppy:z-10", children: ctx.status === "uploading" || ctx.status === "paused" ? `Uploaded ${Math.round(ctx.progress)}%` : ctx.status === "error" ? "Retry" : ctx.status === "complete" ? "Complete" : "Upload" })] }), ctx.status === "uploading" || ctx.status === "paused" ? u("div", { className: "uppy:flex uppy:gap-2", children: [((_a = ctx.uppy) == null ? void 0 : _a.getState().capabilities.resumableUploads) ? u("button", { type: "button", "data-uppy-element": "pause-button", "data-state": ctx.status, onClick: () => {
    var _a2, _b;
    if (ctx.status === "paused") {
      (_a2 = ctx.uppy) == null ? void 0 : _a2.resumeAll();
    } else {
      (_b = ctx.uppy) == null ? void 0 : _b.pauseAll();
    }
  }, className: clsx("uppy:w-full uppy:p-2 uppy:rounded-lg uppy:text-amber-500 uppy:bg-gray-50 uppy:hover:bg-amber-50 uppy:font-medium uppy:transition-all", {
    "uppy:text-green-500 uppy:hover:bg-green-50": ctx.status === "paused"
  }), children: ctx.status === "paused" ? "Resume" : "Pause" }) : null, u("button", { type: "button", "data-uppy-element": "cancel-button", className: "uppy:w-full uppy:p-2 uppy:rounded-lg uppy:text-red-500 uppy:bg-gray-50 uppy:hover:bg-red-50 uppy:font-medium uppy:transition-all", "data-state": ctx.status, onClick: () => {
    var _a2;
    return (_a2 = ctx.uppy) == null ? void 0 : _a2.cancelAll();
  }, children: "Cancel" })] }) : null] });
}

// node_modules/@uppy/components/lib/uppyEventAdapter.js
function createUppyEventAdapter({ uppy, onStatusChange, onProgressChange }) {
  const onFileAdded = () => {
    onStatusChange("ready");
  };
  const onFileRemoved = () => {
    if (uppy.getFiles().length === 0) {
      onStatusChange("init");
    }
  };
  const onUploadStarted = () => {
    onStatusChange("uploading");
  };
  const onResumeAll = () => {
    onStatusChange("uploading");
  };
  const onComplete = (result) => {
    var _a, _b;
    if (((_a = result == null ? void 0 : result.failed) == null ? void 0 : _a.length) || ((_b = result == null ? void 0 : result.successful) == null ? void 0 : _b.length)) {
      onStatusChange("complete");
      onProgressChange(0);
    }
  };
  const onError = () => {
    onStatusChange("error");
    onProgressChange(0);
  };
  const onCancelAll = () => {
    onStatusChange("init");
    onProgressChange(0);
  };
  const onPauseAll = () => {
    onStatusChange("paused");
  };
  const onProgress = (p2) => {
    onProgressChange(p2);
  };
  uppy.on("file-added", onFileAdded);
  uppy.on("file-removed", onFileRemoved);
  uppy.on("progress", onProgress);
  uppy.on("upload", onUploadStarted);
  uppy.on("complete", onComplete);
  uppy.on("error", onError);
  uppy.on("cancel-all", onCancelAll);
  uppy.on("pause-all", onPauseAll);
  uppy.on("resume-all", onResumeAll);
  return {
    cleanup: () => {
      uppy.off("file-added", onFileAdded);
      uppy.off("progress", onProgress);
      uppy.off("upload", onUploadStarted);
      uppy.off("complete", onComplete);
      uppy.off("error", onError);
      uppy.off("cancel-all", onCancelAll);
      uppy.off("pause-all", onPauseAll);
      uppy.off("resume-all", onResumeAll);
    }
  };
}

// node_modules/@uppy/react/lib/headless/generated/Dropzone.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/@uppy/react/lib/headless/UppyContextProvider.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var UppyContext = (0, import_react5.createContext)({
  uppy: void 0,
  status: "init",
  progress: 0
});
function UppyContextProvider({ uppy, children }) {
  const [status, setStatus] = (0, import_react5.useState)("init");
  const [progress, setProgress] = (0, import_react5.useState)(0);
  (0, import_react5.useEffect)(() => {
    if (!uppy) {
      throw new Error("UppyContextProvider: passing `uppy` as a prop is required");
    }
    const uppyEventAdapter = createUppyEventAdapter({
      uppy,
      onStatusChange: (newStatus) => {
        setStatus(newStatus);
      },
      onProgressChange: (newProgress) => {
        setProgress(newProgress);
      }
    });
    return () => uppyEventAdapter.cleanup();
  }, [uppy]);
  return (0, import_jsx_runtime46.jsx)(UppyContext.Provider, { value: {
    uppy,
    status,
    progress
  }, children });
}
function useUppyContext() {
  const ctx = (0, import_react5.useContext)(UppyContext);
  if (!ctx.uppy) {
    throw new Error("Uppy hooks must be called within a UppyContextProvider");
  }
  return ctx;
}

// node_modules/@uppy/react/lib/headless/generated/Dropzone.js
function Dropzone2(props) {
  const ref = (0, import_react6.useRef)(null);
  const ctx = (0, import_react6.useContext)(UppyContext);
  (0, import_react6.useEffect)(() => {
    if (ref.current) {
      nn(_(Dropzone, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime47.jsx)("div", { ref });
}

// node_modules/@uppy/react/lib/headless/generated/FilesGrid.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
function FilesGrid2(props) {
  const ref = (0, import_react7.useRef)(null);
  const ctx = (0, import_react7.useContext)(UppyContext);
  (0, import_react7.useEffect)(() => {
    if (ref.current) {
      nn(_(FilesGrid, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime48.jsx)("div", { ref });
}

// node_modules/@uppy/react/lib/headless/generated/FilesList.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
function FilesList2(props) {
  const ref = (0, import_react8.useRef)(null);
  const ctx = (0, import_react8.useContext)(UppyContext);
  (0, import_react8.useEffect)(() => {
    if (ref.current) {
      nn(_(FilesList, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime49.jsx)("div", { ref });
}

// node_modules/@uppy/react/lib/headless/generated/ProviderIcon.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
function ProviderIcon2(props) {
  const ref = (0, import_react9.useRef)(null);
  const ctx = (0, import_react9.useContext)(UppyContext);
  (0, import_react9.useEffect)(() => {
    if (ref.current) {
      nn(_(ProviderIcon, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime50.jsx)("div", { ref });
}

// node_modules/@uppy/react/lib/headless/generated/Thumbnail.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function Thumbnail2(props) {
  const ref = (0, import_react10.useRef)(null);
  const ctx = (0, import_react10.useContext)(UppyContext);
  (0, import_react10.useEffect)(() => {
    if (ref.current) {
      nn(_(Thumbnail, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime51.jsx)("div", { ref });
}

// node_modules/@uppy/react/lib/headless/generated/UploadButton.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
function UploadButton2(props) {
  const ref = (0, import_react11.useRef)(null);
  const ctx = (0, import_react11.useContext)(UppyContext);
  (0, import_react11.useEffect)(() => {
    if (ref.current) {
      nn(_(UploadButton, {
        ...props,
        ctx
      }), ref.current);
    }
  }, [ctx, props]);
  return (0, import_jsx_runtime52.jsx)("div", { ref });
}

// node_modules/@uppy/progress-bar/package.json
var package_default8 = {
  name: "@uppy/progress-bar",
  description: "A progress bar UI for Uppy",
  version: "4.3.2",
  license: "MIT",
  main: "lib/index.js",
  style: "dist/style.min.css",
  type: "module",
  scripts: {
    build: "tsc --build tsconfig.build.json",
    "build:css": "sass --load-path=../../ src/style.scss dist/style.css && postcss dist/style.css -u cssnano -o dist/style.min.css",
    typecheck: "tsc --build"
  },
  keywords: [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress",
    "progress bar",
    "upload progress"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  dependencies: {
    "@uppy/utils": "^6.2.2",
    preact: "^10.5.13"
  },
  peerDependencies: {
    "@uppy/core": "^4.5.2"
  },
  devDependencies: {
    cssnano: "^7.0.7",
    postcss: "^8.5.6",
    "postcss-cli": "^11.0.1",
    sass: "^1.89.2",
    typescript: "^5.8.3"
  }
};

// node_modules/@uppy/progress-bar/lib/ProgressBar.js
var defaultOptions7 = {
  fixed: false,
  hideAfterFinish: true
};
var ProgressBar = class extends UIPlugin_default {
  constructor(uppy, opts) {
    super(uppy, { ...defaultOptions7, ...opts });
    this.id = this.opts.id || "ProgressBar";
    this.title = "Progress Bar";
    this.type = "progressindicator";
    this.render = this.render.bind(this);
  }
  render(state) {
    const { totalProgress } = state;
    const isHidden = (totalProgress === 0 || totalProgress === 100) && this.opts.hideAfterFinish;
    return u("div", { className: "uppy uppy-ProgressBar", style: { position: this.opts.fixed ? "fixed" : "initial" }, "aria-hidden": isHidden, children: [u("div", { className: "uppy-ProgressBar-inner", style: { width: `${totalProgress}%` } }), u("div", { className: "uppy-ProgressBar-percentage", children: totalProgress })] });
  }
  install() {
    const { target } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
};
__publicField(ProgressBar, "VERSION", package_default8.version);

// node_modules/@uppy/react/lib/ProgressBar.js
var import_react12 = __toESM(require_react(), 1);
var ProgressBar2 = class extends import_react12.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged(this.props, prevProps)) {
      const { uppy, ...options } = { ...this.props, target: this.container };
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { uppy, fixed, hideAfterFinish, id } = this.props;
    const options = {
      id: id || "ProgressBar",
      fixed,
      hideAfterFinish,
      target: this.container
    };
    uppy.use(ProgressBar, options);
    this.plugin = uppy.getPlugin(options.id);
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react12.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      },
      ...getHTMLProps_default(this.props)
    });
  }
};
var ProgressBar_default = ProgressBar2;

// node_modules/@uppy/react/lib/StatusBar.js
var import_react13 = __toESM(require_react(), 1);
var StatusBar2 = class extends import_react13.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container");
    __publicField(this, "plugin");
  }
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged(this.props, prevProps)) {
      const { uppy, ...options } = { ...this.props, target: this.container };
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const { uppy, hideUploadButton, hideRetryButton, hidePauseResumeButton, hideCancelButton, showProgressDetails, hideAfterFinish, doneButtonHandler, id } = this.props;
    const options = {
      id: id || "StatusBar",
      hideUploadButton,
      hideRetryButton,
      hidePauseResumeButton,
      hideCancelButton,
      showProgressDetails,
      hideAfterFinish,
      doneButtonHandler,
      target: this.container
    };
    uppy.use(StatusBar, options);
    this.plugin = uppy.getPlugin(options.id);
  }
  uninstallPlugin(props = this.props) {
    const { uppy } = props;
    uppy.removePlugin(this.plugin);
  }
  render() {
    return (0, import_react13.createElement)("div", {
      className: "uppy-Container",
      ref: (container) => {
        this.container = container;
      },
      ...getHTMLProps_default(this.props)
    });
  }
};
var StatusBar_default = StatusBar2;

// node_modules/@uppy/react/lib/useDropzone.js
var import_react14 = __toESM(require_react(), 1);
function useDropzone(options) {
  const ctx = useUppyContext();
  const dropzone = (0, import_react14.useMemo)(
    () => createDropzone(ctx, options),
    // We need every value on options to be memoized to avoid re-creating the dropzone on every render
    [
      ctx,
      options == null ? void 0 : options.noClick,
      options == null ? void 0 : options.onDragOver,
      options == null ? void 0 : options.onDragEnter,
      options == null ? void 0 : options.onDragLeave,
      options == null ? void 0 : options.onDrop,
      options == null ? void 0 : options.onFileInputChange,
      options
    ]
  );
  return dropzone;
}

// node_modules/@uppy/react/lib/useFileInput.js
var import_react15 = __toESM(require_react(), 1);
function useFileInput(props) {
  const ctx = useUppyContext();
  const fileInput = (0, import_react15.useMemo)(
    () => createFileInput(ctx, props),
    // We need every value on props to be memoized to avoid re-creating the file input on every render
    [ctx, props == null ? void 0 : props.accept, props == null ? void 0 : props.multiple, props]
  );
  return fileInput;
}

// node_modules/@uppy/react/lib/useRemoteSource.js
var import_react16 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
function useRemoteSource(sourceId) {
  const { uppy } = useUppyContext();
  const controller = (0, import_react16.useMemo)(() => createRemoteSourceController(uppy, sourceId), [uppy, sourceId]);
  const store = (0, import_shim.useSyncExternalStore)(controller.subscribe, controller.getSnapshot, controller.getSnapshot);
  (0, import_react16.useEffect)(() => {
    controller.mount();
    return () => {
      controller.unmount();
    };
  }, [controller]);
  return store;
}

// node_modules/@uppy/react/lib/useScreenCapture.js
var import_react17 = __toESM(require_react(), 1);
var import_shim2 = __toESM(require_shim(), 1);
function useScreenCapture({ onSubmit }) {
  const { uppy } = useUppyContext();
  const controller = (0, import_react17.useMemo)(() => createScreenCaptureController(uppy, onSubmit), [uppy, onSubmit]);
  const store = (0, import_shim2.useSyncExternalStore)(controller.subscribe, controller.getSnapshot, controller.getSnapshot);
  return store;
}

// node_modules/@uppy/react/lib/useUppyEvent.js
var import_react18 = __toESM(require_react(), 1);
function useUppyEvent(uppy, event, callback) {
  const [result, setResult] = (0, import_react18.useState)([]);
  const clear = () => setResult([]);
  (0, import_react18.useEffect)(() => {
    const handler = (...args) => {
      setResult(args);
      callback == null ? void 0 : callback(...args);
    };
    uppy.on(event, handler);
    return function cleanup() {
      uppy.off(event, handler);
    };
  }, [uppy, event, callback]);
  return [result, clear];
}

// node_modules/@uppy/react/lib/useUppyState.js
var import_react19 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
function useUppyState(uppy, selector) {
  const subscribe = (0, import_react19.useMemo)(() => uppy.store.subscribe.bind(uppy.store), [uppy.store]);
  const getSnapshot = (0, import_react19.useCallback)(() => uppy.store.getState(), [uppy.store]);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(
    subscribe,
    getSnapshot,
    // client
    getSnapshot,
    // server
    selector
  );
}

// node_modules/@uppy/react/lib/useWebcam.js
var import_react20 = __toESM(require_react(), 1);
function useWebcam({ onSubmit }) {
  const { uppy } = useUppyContext();
  const controller = (0, import_react20.useMemo)(() => createWebcamController(uppy, onSubmit), [uppy, onSubmit]);
  const store = (0, import_react20.useSyncExternalStore)(controller.subscribe, controller.getSnapshot, controller.getSnapshot);
  return store;
}
export {
  Dashboard_default as Dashboard,
  DashboardModal_default as DashboardModal,
  DragDrop_default as DragDrop,
  Dropzone2 as Dropzone,
  FileInput_default as FileInput,
  FilesGrid2 as FilesGrid,
  FilesList2 as FilesList,
  ProgressBar_default as ProgressBar,
  ProviderIcon2 as ProviderIcon,
  StatusBar_default as StatusBar,
  Thumbnail2 as Thumbnail,
  UploadButton2 as UploadButton,
  UppyContext,
  UppyContextProvider,
  useDropzone,
  useFileInput,
  useRemoteSource,
  useScreenCapture,
  useUppyEvent,
  useUppyState,
  useWebcam
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@uppy_react.js.map
